<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Daenerys Targaryen - The Queen]]></title>
    <url>%2F2019%2F08%2F29%2FDaenerys-Targaryen%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/Daenerys1.mp4","pic":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/2019-08-28%2F1566927552.png"},"danmaku":{"id":"Khaleesi","api":"https://dplayer.moerats.com/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>Share</tag>
        <tag>Inspirational</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析中的MySQL]]></title>
    <url>%2F2019%2F08%2F21%2FMySQL-dataanalysis%2F</url>
    <content type="text"><![CDATA[MySQL简单总结条件查找123456select * from dataAnalystwhere (city = &apos;上海&apos;and education = &apos;本科&apos;)or (city = &apos;北京&apos;and education = &apos;硕士&apos;) 1234567891011select * from dataAnalystwhere (city = &apos;上海&apos;and education = &apos;本科&apos;)or workYear = &apos;1-3年&apos;# 翻译：上海和本科同时满足，或者只满足workyearselect * from dataAnalystwhere city = &apos;上海&apos;and (education = &apos;本科&apos;or workYear = &apos;1-3年&apos;)# 翻译：上海的，学历或者工作经验满足 模糊查找1234567select * from dataAnalystwheresecondType like '%开发%'select * from dataAnalystwheresecondType like '后端%' Groupby12select city from dataAnalystgroup by city 123456select city,count(positionId) from dataAnalystgroup by city # count(positionId) = count(1) = count(*) # 对于包不包含控制计算有细微差异select city,count(1),count(*) from dataAnalystgroup by city 去重复——DISTINCT12select city,count(positionId),count(distinct companyId) from dataAnalystgroup by city 12select city,education,count(1) from dataAnalystgroup by city,education Having1234# having 就是对groupby进行过滤的select city,education,count(1) from dataAnalystgroup by city,educationhaving count(positionId) &gt;= 100 Like12345# 获取字段含有“电子商务”的用likeselect city,count(1) from dataAnalystwhere industryField like &apos;%电子商务%&apos;group by cityhaving count(positionId) &gt;= 50 count if1234# 这里只输出城市（嵌套查询）select city from dataAnalystgroup by cityhaving count(if(industryField like &apos;%电子商务%&apos;,1,null)) &gt;= 50 不同城市下面电商占这个城市的招聘人数的占比并过滤大于10 1234567select city,count(1),count(if(industryField like &apos;%电子商务%&apos;,industryField,null)),count(if(industryField like &apos;%电子商务%&apos;,industryField,null))/count(1)from dataAnalystGROUP BY cityhaving count(if(industryField like &apos;%电子商务%&apos;,industryField,null)) &gt;= 10ORDER BY count(if(industryField like &apos;%电子商务%&apos;,industryField,null)) 优雅的写法——As 1234567select city,count(1),count(if(industryField like &apos;%电子商务%&apos;,industryField,null)) as emarket,count(if(industryField like &apos;%电子商务%&apos;,industryField,null))/count(1)from dataAnalystGROUP BY city having emarket &gt;= 10ORDER BY emarket desc SQL函数left和locate和right1select left(salary,locate(&apos;k&apos;,salary)-1),salary from dataAnalyst 1234567select left(salary,locate(&apos;k&apos;,salary)-1),locate(&apos;-&apos;,salary),length(salary),left(RIGHT(salary,length(salary)-locate(&apos;-&apos;,salary)),length(salary)-locate(&apos;-&apos;,salary)-1),salarysalary from dataAnalyst substr substr(字符串，从哪里开始，截取长度) 1234select left(salary,locate(&apos;k&apos;,salary)-1),substr(salary,locate(&apos;-&apos;,salary)+1,length(salary)-locate(&apos;-&apos;,salary)-1),salary from dataAnalyst 子查询 基于查询结果的查询，嵌套查询 123456select (bottom + top)/2 from(select left(salary,locate(&apos;k&apos;,salary)-1) as bottom,substr(salary,locate(&apos;-&apos;,salary)+1,length(salary)-locate(&apos;-&apos;,salary)-1) as top,salary from dataAnalyst) as t 分组——case when 主要用来数据清洗 12345678910111213select case when (bottom+top)/2 &lt;= 10 then &apos;0-10&apos; when (bottom+top)/2 between 10 and 20 then &apos;10-20&apos; when (bottom+top)/2 &lt;= 30 then &apos;10-30&apos; else &apos;30+&apos; end, salary from( select left(salary,locate(&apos;k&apos;,salary)-1) as bottom, substr(salary,locate(&apos;-&apos;,salary)+1,length(salary)-locate(&apos;-&apos;,salary)-1) as top, salary from dataAnalyst) as t 过滤——where in1234select * from dataAnalystwhere city in(select city from dataAnalystgroup by city having count(positionId) &gt;= 100) 多表聚合查询——Join 某一个公司招聘职位，在另一个表中查找信息 12345select * from dataAnalystwhere companyId = (select companyId from companywhere companyShortName = &apos;唯医网&apos;) 连结两张表1234567select * from dataAnalyst ❌join company on companyId = companyId ❌# 没结果，因为companyId不唯一#正确写法select * from dataAnalyst as djoin company as c on d.companyId = c.companyId 左连接 保留左边，右边硬凑，没有就null 1234select * from dataAnalyst as dleft join(select * from companywhere companySize = &apos;150-500人&apos;) as ton t.companyId = d.companyId join就是取交集，left join就是A是全部B是部分 123456# 排除法统计select * from dataAnalyst as dleft join(select * from companywhere companySize = &apos;150-500人&apos;) as ton t.companyId = d.companyIdwhere t.companyId is null # 过滤重复的部分 150-500人的占比 1234select count(1),count(t.companyId),count(t.companyId)/count(1) from dataAnalyst as dleft join(select * from companywhere companySize = &apos;150-500人&apos;) as ton t.companyId = d.companyId LeetCode——训练刷题时间1select now() 1234select paidTime,date(paidTime),date_format(paidTime,&apos;%Y-%m-%d&apos;),date_format(date_add(paidTime,interval -1 day),&apos;%Y-%m-%d&apos;)from orderinfo 练习题 统计不同月份的下单人数统计用户三月份的回购率和复购率统计男女用户的消费频次是否有差异统计多次消费的用户，第一次和最后一次消费间隔是多少?统计不同年龄段，用户的消费金额是否有差异?统计消费的二八法则，消费的top20%用户，贡献了多少额度 统计不同月份的下单人数1234select month(paidTime),count(distinct userId)from orderinfowhere isPaid = &apos;已支付&apos;GROUP BY month(paidTime) 统计用户三月份的回购率和复购率123456# 统计用户三月份的复购率select count(ct),count(if(ct&gt;1,1,null)),count(if(ct&gt;1,1,null))/count(ct) from( select userId,count(userId) as ct from orderinfo where isPaid = &apos;已支付&apos; and month(paidTime) = 3 group by userId) as t 不是很好的方法： 1234567891011# 统计用户三月份的回购率SELECT count(DISTINCT userId) from orderinfowhere userId in ( select userId from orderinfo where isPaid = &apos;已支付&apos; and month(paidTime) = 3)and month(paidTime) = 4select count(DISTINCT userId) from orderinfowhere isPaid = &apos;已支付&apos;and month(paidTime) = 3 首先查找出userId在每个月份的支付情况 123select userId,date_format(paidTime,&apos;%Y-%m&apos;) as m from orderinfowhere isPaid = &apos;已支付&apos;GROUP BY userId,date_format(paidTime,&apos;%Y-%m&apos;) 然后左连接两张相同的表： 123456789select * from( select userId,date_format(paidTime,&apos;%Y-%m&apos;) as m from orderinfo where isPaid = &apos;已支付&apos; GROUP BY userId,date_format(paidTime,&apos;%Y-%m&apos;)) t1left join( select userId,date_format(paidTime,&apos;%Y-%m&apos;) as m from orderinfo where isPaid = &apos;已支付&apos; GROUP BY userId,date_format(paidTime,&apos;%Y-%m&apos;)) t2on t1.userId = t2.userId 此时得到的是两张表的笛卡尔积（左连接非唯一字段，是局部笛卡尔积。） 然后增加条件筛选，此时添加了非唯一条件，笛卡尔积自动去除 1234567891011可以统计所有的月份：select t1.m,count(t1.m),count(t2.m),count(t2.m)/count(t1.m) from( select userId,date_format(paidTime,&apos;%Y-%m-01&apos;) as m from orderinfo where isPaid = &apos;已支付&apos; GROUP BY userId,date_format(paidTime,&apos;%Y-%m-01&apos;)) t1left join( select userId,date_format(paidTime,&apos;%Y-%m-01&apos;) as m from orderinfo where isPaid = &apos;已支付&apos; GROUP BY userId,date_format(paidTime,&apos;%Y-%m-01&apos;)) t2on t1.userId = t2.userId and t1.m = date_sub(t2.m,interval 1 month)GROUP BY t1.m 统计男女用户的消费频次是否有差异平均数12345678select sex,avg(ct) from ( select o.userId,sex,count(1) as ct from orderinfo as o inner join( select * from userinfo where sex is not null) t on o.userId = t.userId group by userId,sex) t2group by sex 统计多次消费的用户，第一次和最后一次消费间隔是多少?1234select userId,datediff(max(paidTime),min(paidTime)) from orderinfowhere isPaid = &apos;已支付&apos;group by userId having count(1) &gt; 1# datediff把秒数变成天数 统计不同年龄段，用户的消费金额是否有差异?年龄除10然后取整数 123456select o.userId,age,count(o.userId) from orderinfo oinner join( select userId,ceil((year(now())-year(birth))/10) as age from userinfo where birth &gt; &apos;1900-00-00&apos;)ton o.userId = t.userIdgroup by o.userId,age 平均数 12345678select age,avg(ct) from ( select o.userId,age,count(o.userId) as ct from orderinfo o inner join( select userId,ceil((year(now())-year(birth))/10) as age from userinfo where birth &gt; &apos;1900-00-00&apos;)t on o.userId = t.userId group by o.userId,age)t2group by age 统计消费的二八法则，消费的top20%用户，贡献了多少额度先统计总人数 12345select count(userId)*0.2 from(select userId,sum(price) as total from orderinfo owhere isPaid = &apos;已支付&apos;group by userIdorder by total desc)as t 统计贡献 123456select count(userId),sum(total) from( select userId,sum(price) as total from orderinfo o where isPaid = &apos;已支付&apos; group by userId order by total desc limit 17000)t SQL连接PowerBI]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Data Analysis</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一天入门数据分析]]></title>
    <url>%2F2019%2F08%2F20%2Fintroduction-to-data-analysis%2F</url>
    <content type="text"><![CDATA[一、数据分析框架——15分钟七门课程 数据思维 业务知识 Excel 数据可视化 SQL 统计学 Python 分析师既可以用Excel完成一份最基础的数据报告，也能用Python深入挖掘 真正决定数据分析师上限的是能力，而不是工具 数据分析是解决问题的，锻炼出解决问题的思路框架，奠定能力发展的基础 二、数据分析思维——2小时1. 三种核心思维 结构化 公式化 业务化 结构化思维 现在有一个线下销售的产品。我们发现8月的销售额度下降，和去年同比下降了20%。我想先观察时间趋势下的波劢，看是突然暴跌，还是逐渐下降。再按照丌同地区的数据看一下差异，有没有地区性的因素影响。我也准备问几个销售员，看一下现在的市场环境怎么样，听说有几家竞争对手也缩水了，看一下是丌是这个原因。顾客访谈也要做，但是往常一直找丌出原因，这次我也丌抱希望，姑且试试吧。要是还找丌出原因，那我也很绝望. 思维的缺陷： 想到一点是一点 做假设，但乱打一枪 一次性分析，没有复用性 业务看了会流泪，老板看了想打人 还是没结果 将分析思维结构化 将论点归纳和整理 将论点递迚和拆解 将论点完善和补充 结构化思维： 核心论点：可以是假设、是问题、是预测、是原因 结构拆解：自上而下，将核心论点层层拆解成分论点，上下之间呈因果或者依赖关系 MECE：相互独立、完全穷尽。论点之间避免交叉和重复，分论点尽量完善 验证：论点可量化——用数据说话——可验证性 思维导图式的思维方式 查看资料及背景，将结论列成一张表/卡片 把表上的结论，依据主题分类 将同一类型的结论，按顺序区分 讨论同一级别的共通结论，将其结论放在上一段位置 公式化 业务化如何预估上海地区共享单车投放量？ 单车是有损耗的，计算公式中应该考虑单车的消耗因素 结构化+公式化——理性思考 业务化——感性分析 有没有从业务方的角度思考？ 真的分析出原因了吗？ 能不能将分析结果落地？ 用结构化思考+公式化拆解，获得的最终分析论点。很多时候，是现象。数据是某个结果的体现，但不代表原因。 换位思考也是业务化重要思维。 2. 数据分析的思维技巧七种方法 象限法 假设法 对比法 二八法 指数法 多维法 漏斗法 象限法 核心：象限法是一种策略驱动的思维 应用：适用范围广、戓略分析、产品分析、市场分析、客户管理、用户管理、商品管理等 优点：直观，清晰，对数据迚行人工的划分。划分结果可以直接应用于策略 须知：象限法划分可以按中位数，也可以按平均数，或者经验 多维法 用户统计维度:性别、年龄…用户行为维度:注册用户、用户偏好、用户兴趣、用户流失…消费维度:消费金额、消费频率、消费水平…商品维度:商品品类、商品品牌、商品属性… 假设法 没数据的时候怎么分析 很多时候，数据分析是没有数据可明确参考的:比如新迚入一个市场，公司开拓某样产品。老板让你预测一年后的销量，戒者产品的数据基础非常糟糕，你拿丌到数据。 核心：假设法是一种启发思考驱动的思维 应用：它更多的是一种思考方式，假设——验证——判断 优点：当没有直观数据或者线索分析时，以假设先行的方式进行推断，这是一个论证的过程。 须知：不知可以假设前提，也能假设概率或者比例，一切都能假设，只要能自圆其说。 指数法 中国今年的经济指标如何?美国NBA最佳球星是谁?竞争对手产品表现的如何?哪位是天善学院最帅的男人? NBA比赛数据贡献值: (得分+篮板+劣攻+抢断+封盖)-(出手次数-命中次数)-(罚球次数- 罚球命中次数)-(失误次数/球员上场比赛的场次) 很多时候，我们有数据，但丌知道怎么应用。就是因为缺乏了一个有效性的方向。这个方向可以成为目标指数。通过设置不同的权重，将数据加工成指数，达到聚焦的目的。 指数法举例：反比例： 收敛得更厉害：log/log加线性权重 总结核心：指数法是一种目标驱动的思维 应用：和假设法不同，假设法是缺乏有效的数据，指数法是无法利用数据，指数法是无法利用数据将其加工可利用的。 优点：目标驱动力强，直观、简洁、有效。对业务有一定的指导作用。一旦设立指数，不易频繁变动。 须知：指数法没统一的标准，很多指数更依赖经验的加工。 二八法百分之八十的数据是没有价值的，只有20%的用户才是有价值的 数据中20%的变量将直接产生80%的效果。 持续关注TopN的数据，是一个非常好的习惯 虽然指标很多，但是往往某些指标更有价值，二八法则不仅能分析数据，也能管理数据。 二八法：核心：二八法是一种抓重点的思维 应用：二八法则存在于几乎所有的领域，所以这种分析思维没有局限 优点：和业务紧密相关，和KPI更紧密相关。几乎花费最少的精力就能达到不错的效果，性价比很优 须知：在条件允许的情况下，数据分析依旧不能放弃全局 ，否则会让思路变得狭隘 对比法 节日大促，女生消费占比从60%变为70%，女生节日爱消费 ： 这个结论是有问题的 占比提高了，不代表绝对值提高了。某商品平时销售 额100万女生占60万，节日销售额80万女生占56 万，女生真的消费变高了? 谁说节日销售额会提高？别忘了竞争对手 孤数不证 竞争对手对比 类别对比 特征和属性对比 时间同比环比 转化对比 前后变化对比 对比法：核心：对比法是一种挖掘数据规律的思考方式 应用：对比更多是一种习惯，是数据分析的牛角尖，一次合格的分析，一定要用到N次对比 优点：对比法可以发想很多数据间的规律，它可以与任何思维技巧结合，比如多维对比、象限对比、假设对比等 须知：在条件允许的情况下，数据分析依旧不能放弃全局，否则会让思路变得狭隘。 3. 如何在业务时间锻炼数据分析思维好奇心尿布旁边放啤酒，增加啤酒的销量是假的！！ 买了尿布的人会买啤酒，但是买啤酒的人会买尿布么? 尿布旁边应该摆放其他东西么?啤酒是否是最好选择? 怎么摆放啤酒?部分还是全部品类? 场景型的摆放是否比品类摆放更好? 数据呢? 生活中的练习走在夜市： 这个夜市一天的人流量是多少?一年的 人流量又是多少? 「现煮小卷」每天的营业额是多少? 这个夜市，哪家店的利润是最高的?它 比最低的高出多少?原因是什么? 如何从数据分析的角度提高最低店的营业额? 夜店准备弄一次活劢，如何设计一套数 据评估方案评估活劢效果? 工作中： 为什么领导戒者同事丌认同这次分析?原因是什么? 如果我的职位比现在高两级，我会去怎么分析? 让我再次分析一年前做的那个案例，我 会怎么去优化和改迚? 我的历史分析，能用三种核心思维去优化和迭代吗? 三、业务——2小时1. 为什么业务重要？惟有理解业务，才能建立业务数据模型 2. 经典业务分析指标模型未动 ， 指标先行如果你不能衡量它，你就无法增长它 指标可以让老板更好地管理，需要建立分析框架，必须确立好指标 应该选取哪些指标分析： 核心指标 好的指标应该是比率 好的指标应该能带来显著效果 好的指标不应该虚荣 好的指标不应该复杂 2.1 市场营销指标客户/用户生命周期 企业/产品和消费者在整个业务关系阶段的周期。 不同业务划分的阶段丌同。传统营销中， 分为潜在用户，兴趣用户，新客户，老/ 熟客户，流失客户。 用户价值 业务领域千千万万，怎么定义最有效的用户呢?请出指数法，将业务最关注的几个指标一起加工吧。 用户贡献 = 产出量/投入量*100% 用户价值 = (贡献1+贡献2+……) 比如金融行业会以存款+贷款+信用卡+ 年费+……-风险-流失 RFM模型用户生命周期中，衡量客户价值的立方体模型。利用R最近一次消费时间，M总消费金额，F消费频次，将用户划分成多个群体。 用户分群，营销矩阵用户分群是市场营销中的一种常见策略，它提取用户的几个核心维度，用象限法将其归纳和分类。 AARRR框架Acquisition用户获取、Activation用户活跃、Retention用户留存、Revenue营收、Refer传播。 用户获取 渠道到达量: 俗称曝光量。有多少人看到了产品推广相关的线索。 渠道转化率: 有多少用户因为曝光而心 劢Cost Per，包含CPM、CPC、CPS、 CPD、CPT等。 渠道ROI: 推广营销的熟悉KPI，投资回报率，利润/投资*100%。 用户获取 日应用下载量: app的下载量，这里指 点击下载，丌代表下载完成 日新增用户数: 以用户注册提交资料为基准 获客成本: 为获取一位用户需要支付的成本 一次会话用户数占比: 指新用户下载完 App，仅打开过产品一次，且该次使用 时长在2分钟以内。「防止机器人刷单，灰色流量」 用户活跃 日/周/月活跃用户应用下载量:活跃 标准是用户用过产品，广义上，网页浏 览内容算「用」，在公众号下单算 「用」，不限于打开APP。 活跃用户占比:活跃用户数在总用户数的比例，衡量的是产品健康程度 用户活跃： 用户会话session次数: 用户打开产品操 作和使用，直到退出产品的整个周期。5 分钟内没有操作，默讣会话操作结束。 用户访问时长: 一次会话的持续时间。 用户平均访问次数: 一段时间内的用户平均产生会话次数。 用户留存 用户在某段时间内使用产品，过了一段时间后仍旧继续使用的用户。 假设产品某天新增用户1000个，第二天 仍旧活跃的用户有350个，那么称次日 留存率有35%，如果第七天仍旧活跃的 用户有100个，那么称七日留存率为 10%。 营收： 付费用户数: 花了钱的 付费用户数占比: 每日付费用户占活跃用户数比，也可以计算总付费用户占总用户数比 ARPU: 某时间段内每位用户平均收入 ARPPU: 某时间段内每位付费用户平均 收入，排除了未付费的 营收： 客单价: 每一位用户平均贩买商品的金额。销售总额/顾客总数 LTV: 用户生命周期价值，和市场营销 的客户价值接近，经常用在游戏运营电 商运营中。 LTV = ARPU * 1/流失率 传播2.2 用户行为指标用户行为 用户行为的数据分析是一个很广泛的课题，丌同业务领域背景的用户行为分析不一样。 这里简单概括说几个方法。 功能使用 功能使用率/渗透率:使用某功能的用户占总活跃数之比。 比如点赞、评论、收藏、关注、搜索、添加好友，均可以算做功能使用。这些指标在特定业务中均有作用。 用户会话会话session:也叫做session，是用户 在一次访问过程中，从开始到结束的整 个过程。 在网页端，30分钟内没有操作， 默讣会话操作结束。 用户路径路径图:用户在一次会话的过程中，其访问产品内部的浏览轨迹。通过此，可以加工出关键路径转化率。 2.3 电子商务指标购物篮分析 笔单价:用户每次贩买支付的金额，即每笔订单的支出。和客单价对应。件单价:商品的平均价格。 成交率:支付成功的用户在总的客流量中的占比。 贩物篮系数:平均每笔订单中，卖出了多少商品。贩物篮系数是多多益善，它也和商品关联规则有关系。 好基友:复购率和回购率 复贩率是一段时间内多次消费的用户占 总消费用户数乊比。有例如4月有1000 位用户消费，其中500位消费了两次以 上，则复贩率是50%。 回贩率是一段时间内消费过的用户，在 下一段时间内仍旧消费的占比。例如4月 的消费用户数1000，其中600位在5月 继续消费，则回贩率为60%。 2.4 流量指标浏览量和访客量 PV: 浏览次数。互联网早起的统计指标， 用户在网页的一次访问请求可以看作一 个PV，用户看了十个网页，则PV为10。 UV: 是一定时间内访问网页的人数，正式名称独立访客数。在同一天内，丌管 用户访问了多少网页，他都只算一个独立访客。 技术上，UV会通过cookie或IP衡量。 访客行为 新老访客占比: 衡量网站的生命力 访客时间: 衡量内容质量丌是看内容的 UV，而是看内容的访问时间。 新老访客占比: 衡量网站的生命力 来源: 访客从哪里来，技术上，通过来 源网站的参数提取，可以区分SEM， SEO或者外链等。 退出率和跳出率 退出率: 从该页退出的页面访问数/进入该页的访问数。 跳出率: 浏览单页即推出的次数/访问次数。 跳出率一般衡量各个落地页，营销页等页面。退出率则更偏产品，仸何页面都有退出率 2.5 怎么生成指标 访客访问时长 + UV = 重度访问用户占比 浏览时间5分钟以上的用户在整个访客中占比.用户会话次数 + 成交率 = 有效消费会话占比 用户在所有的会话中，其中有多少次有消费? 3. 业务的分析框架3.1 如何建立业务分析框架用指标建立业务分析框架 从指标的角度出发 从业务的角度出发 从流程的角度出发 市场营销模型 对机会客户线性加权的加工： 潜在客户转化率 机会客户转化率 新客付费转化率 不同渠道在新客中的占比 不同渠道在新客中的付费转化率 AARRR模型 二次激活的线性加权加工： 推送激活转化率 有效推送成功率 有效推送到达率 用户打开率 不同推送的转化率 用户行为模型（内容平台） 点赞/评论/收藏的线性加权： 点赞用户活跃占比 评论用户活跃占比 收藏用户活跃占比 内容指数 电子商务模型 购物车的线性加权： 不同商品类别的占比（对比法） 不同价格档次的占比（象限法） 不同商品下单支付率（漏斗法） 流量模型 搜索引擎流量、搜索引擎优化的线性加权 3.2 应对各类业务场景 Step.1 练习Step.2 熟悉业务Step.3 应用三种核心思维Step.4 归纳和整理出指标Step.5 画出框架Step.6 检查、应用、修正Step.7 应用和迭代 //TODO 视频2.30必看 4. 数据化管理业务 四、Excel——2小时（多练习） 不会因为你会Python而成为数据分析师，而是能用任何工具解决问题 1. 为什么用Excel？1.1 Excel的学习路径 Excel保证新版本 培养好的数据表格习惯 主动性搜索 多练习 1.2 Excel的常见函数 文本清洗函数 1 bit = 两种可能性，用0戒1存储1 byte = 8 bit，如00000001，一共有256种可能性1 byte可以存256个字符编码，最初的存储方式ASCII，就存了英文+数字+符号汉字远远大于256种可能性，于是用2byte组合表示，叫做GB2312后来为了表示更多的汉子，用了GBK，它是拓展版，连繁体字都包括了可是中国还有少数民族啊!少数民族的文字怎么办?于是又多了GB18030可是全世界有多少国家多少名族?于是@#¥%……&amp;*于是发明了一个万国码，叫做unicode 字符 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 中 x 01001110 00101101 11100100 10111000 10101101 Find Substitute Left Right Mid(提取需要的部分) Text(转换格式) Concatenate(拼接函数) Trim(规整字符串) Replace(替换函数) Len(长度) //TODO EXCEL操作见DataAnalyst 关联匹配函数 Lookup Row Vlookup(另一个表主键匹配添加) Column Index(索引) Offset(偏移) Match(查找相对位置) Hyperlink(超链接) Index和Match联合引用——「Match匹配出来的值的另一列」 逻辑运算函数 条件判断 And Not Or False True IF (加在后面加条件) Is 计算统计函数 Sum Rank(排名) Stdev Sumproduct(累加相乘) Rand RandBetween(随机函数) Substotal Count Average Int(取整) Max Min Quartile(分位数) Round(取整) 时间序列函数 2017/02/27 Year Day Month Date Weekday(判断一周中的周几) Now(返回当前的时间) Weeknum(一年中的第几周) Today(返回当前的日期) 1.3 Excel常见技巧快捷键： Ctrl+方向键 Ctrl+Shift +方向键 Ctrl+空格键 Shift+空格键 Ctrl+A 选择整张表 Alt+Enter 换行 数据类型数据透视表条件格式和迷你图分列数组自定义名称自定义下拉菜单冻结删除重复项分析工具库切片1.4 用Excel进行数据分析现在你有一份的餐食数据，我想通过Excel知道 ： 全国点评数最高的饭店是哪家? 哪个城市的饭店人均口味最好? 哪个类型的餐饮评价最好? 类型为川菜的店中，有多少个带「辣」字，又有多少个带「麻」字? 口味、环境、服务，三个评价都在8.0以上的饭店有几家?它们在哪个城市的占比最多? 上海地区中，各个类型饭店服务前五名? 没有评价的饭店有几家? 将人均价格划分成0~50，50~100，100~150，150~200，200+这几个档次， 各个城市分别有几家?其中占比又是多少? 将点评、人均、口味、环境、服务这几个指标加工出一个综合评价系数，并且计算 哪十家店是最好的(开放题)。 对上海地区的日本料理，做一次描述性分析(开放题) 五、数据可视化——2小时（下载Power BI、熟悉基本操作）1. 数据可视化数据可视化之美 数据可视化 数据可视化的目的是让数据更高效 让读者更高效阅读，而不单是自己使用 突出数据背后的规律 突出重要的因素 最后是美观 只要能从图中看到我所要的规律，那么就是靠谱的 2. 常见初级图表图表的基础概念 散点图 散点图 散点图主要解释数据之间的规律。 维度:0+，作为颜色 度量:2 气泡图 气泡图是散点图的变种，引入了第三个度量作为气泡的大小。 维度:1+，作为颜色 度量:3，其中1个是气泡大小 单轴散点图 维度作Y轴，更倾向于洞 察数据在不同类别下的 数据规律 维度:1+，Y轴 度量:2 客户消费维度 消费金额和消费次数的关系 消费金额和最后一次距今消费天数的关系 消费次数和最后一次距今消费天数的关系 客户其他消费维度 消费金额和消费折扣的关系 消费金额和会员积分的关系 消费次数和会员距离的关系 垂直领域消费维度 投资金额和投资次数的关系(金融) 最近一次距今消费和使用次数(SaaS) 折线图 折线图 折线图经常用来观察数据随时间变化的趋势。 折线图中的维度不宜过多，否则会非常混乱和复杂。 维度:1+ 可对比度量:1+ 时间维度:X轴 面积图 面积图是折线图的变种。 面积图更注重数据类别之间随着时间趋势的变化关系。 维度:1 度量:2 柱形图 柱形图 柱形图是类别之间的关系。 维度:2 度量:1+ 直方图 柱形图的统计型变种。 维度:0 度量:1 饼图 饼图（没什么屁用） 饼图可以理解为环状的 柱形图。 饼图的类别不宜过多。饼图除了PPT， 分析时没啥用。 维度:1 度量:1 漏斗图 漏斗图（也没啥用） 漏斗图是对转化过程的 直观展示。单一的漏斗 图没啥用，也是面向 PPT。漏斗图的转化步 骤不应该超过七个。 维度:1 度量:1 雷达图 雷达图 适用于个体的数据和属 性可视化，比较偏描述性数据，常见于CRM， 用户画像。 维度:1+ 度量:1+ 3. 常见的高级图表树形图 树形图（大数据量） 适合数据量较大的情况， 尤其类别较多。比如各 类电商的SKU ·维度:1+ 度量:1 桑基图 桑基图（网站流量、行为轨迹、活跃状态变化） 桑吉图是揭示数据复杂变化趋势的图表。面积图是线性维度，而桑基图可以一对多或者多对一。 维度:2 source,target 度量:1 热力图 热力图 数据在空间上的变化规律。譬如地理空间，譬如网页浏览 维度:2 度量:1 热力图（github、特殊的时间规律） 空间不一定是纯粹空间，也可以是属性和维度的规律组合，比如把它变成星期表。 维度:1 度量:1 关系图 关系图（社交、「很少用到」） 展现不同类别之间的数据关系，常见于各类社交社会媒体。 维度:2 source target 度量:0+ 箱线图 箱线图（数据的分布规律、统计学） 箱线图是统计用图表，用来研究和观察数据分布，也能对比数据分布。 维度:1+ 度量:1 标靶图 标靶图（销售业绩） 也称为子弹图，是变种的条形图。常用于衡量业务销售完成情况。 维度:1+ 度量:2 词云图 词云图（大数据必备图表） 文本分析利器，PPT常 客，卖弄大数据之必备 图表 维度:1 度量:0 地理图 地理图 数据和空间之间的关系。地理图即可以通过经纬度的数值度量绘制，也能通过省市的类别维度绘制。 维度:1(经纬或行政) 度量:1 4. 图表绘制 //TODO 具体见视频4.47～4.55 5. 可视化BI BI（Business Intelligence）即商务智能，它是一套完整的解决方案，用来将企业中现有的数据进行有效的整合，快速准确地提供报表并提出决策依据，帮助企业做出明智的业务经营决策。它是一种产品/服务，这个产品/服务可能包含报表，分析，管理等等利用计算机和编程技术自动化一些商业过程的行为。 商业智能 BI 就是一个把数据变为信息的过程 —— 将企业中的各个部分、各个业务系统中的数据统一的按照一定规则的抽取、清洗，最后加载到一个统一而集中的数据库中。在这个数据库之上，可以做报表展现、也可以做数据分析，最后这些展现和分析的结果将能成为一些决策的重要数据支持，这就是描述商业智能 BI 的一个最简单的价值。简单概括这个过程所体现的三个大的部分就是：Data Source 数据源，Data Warehouse 数据仓库的数据准备，Reporting 报表系统提供报表展现和数据分析。 你的图表，是原因，还是现象? 数据分析师在地理图上发现A省B省C省的某个指标 下跌了，你兴奋的告诉老大这是上个月数据表现不佳的原因。 老大肯定抽你，这是现象。具体的原因要结合更深的分析，这些省市经济程度如何、人口如何、有何 数据共性，这是地理图不会告诉你的 工具：Power BI //TODO Power BI的基本使用——视频4.57~4.60 单一图表的可视化没有意义——三表成虎 Dashboard Who 是谁在使用?What 用户的目的是什么?How 用户怎么使用? Prower BI有监控，可以知道哪些人看了哪些图表。可以进行简单地调研，来改进自己的BI。后台调用监控日志，砍掉不需要的BI，加强需要的BI。 主次分明 贴合场景 指标结构 DashBoard是一个不断改进不断更新的过程。 六、数据库——1小时（有基础、多练习）1. 数据库数据库相关 数据库是数据存储的集合，表是数据结构化的信息 列存储表中的组织信息，行存储表中的明细信息 主键是表中唯一标识，主键不具备业务意义 Tips： 表的主键不做强制要求，但建议设立主键值必须唯一每行必须有一个主键，不可为空主键值不可被修改主键值被删除后不可重用表A的主键，可以做为表B的字段，此时不受约束 2. Join Students.addressId = Address.idStudents.id = Scores.studentIdScores.courseId = Courses.id 3. SQL练习题统计不同月份的下单人数统计用户三月份的回购率和复购率统计男女用户的消费频次是否有差异统计多次消费的用户，第一次和最后一次消费间隔是多少?统计不同年龄段，用户的消费金额是否有差异?统计消费的二八法则，消费的top20%用户，贡献了多少额度 八、Python——N小时（数据分析、爬虫、深度学习）1. Python的数据科学环境2. Python基础3. NumPy和Pandas4. 数据可视化5. 数据分析案例6. 数据分析平台七、统计学——N小时（配合Python食用）1. 描述统计学拿到数据的时候怎么做？ 男——0，女——1 「分类数据」 分类数据的描述统计 频数统计——单纯对各分类计数 频数百分比——单纯对各分类计数就可 数值数据描述统计 统计度量： 图形 统计度量： 平均数、中位数、众数 分位数 //TODO 阅读 贾俊平版《统计学》]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Data Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot]]></title>
    <url>%2F2019%2F08%2F15%2FSpringBoot%2F</url>
    <content type="text"><![CDATA[一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备http://www.gulixueyuan.com/ 谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World!"; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")//@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.atguigu.springboot.service.HelloService"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println("配置类@Bean给容器中添加组件了..."); return new HelloService(); &#125;&#125; ##4、配置文件占位符 1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式1234567891011121314151617181920server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = "spring.http.encoding") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings("rawtypes")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = "http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志...");&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;springProfile name="dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name="!dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler("/webjars/**") .addResourceLocations( "classpath:/META-INF/resources/webjars/") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html"); public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path="/hello" view-name="success"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/hello"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = "spring.messages")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * "org.mypackage"), it will be resolved from the classpath root. */ private String basename = "messages"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="asserts/css/bootstrap.min.css" th:href="@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;" rel="stylesheet"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href="asserts/css/signin.css" th:href="@&#123;/asserts/css/signin.css&#125;" rel="stylesheet"&gt; &lt;/head&gt; &lt;body class="text-center"&gt; &lt;form class="form-signin" action="dashboard.html"&gt; &lt;img class="mb-4" th:src="@&#123;/asserts/img/bootstrap-solid.svg&#125;" src="asserts/img/bootstrap-solid.svg" alt="" width="72" height="72"&gt; &lt;h1 class="h3 mb-3 font-weight-normal" th:text="#&#123;login.tip&#125;"&gt;Please sign in&lt;/h1&gt; &lt;label class="sr-only" th:text="#&#123;login.username&#125;"&gt;Username&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="Username" th:placeholder="#&#123;login.username&#125;" required="" autofocus=""&gt; &lt;label class="sr-only" th:text="#&#123;login.password&#125;"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" placeholder="Password" th:placeholder="#&#123;login.password&#125;" required=""&gt; &lt;div class="checkbox mb-3"&gt; &lt;label&gt; &lt;input type="checkbox" value="remember-me"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#&#123;login.btn&#125;"&gt;Sign in&lt;/button&gt; &lt;p class="mt-5 mb-3 text-muted"&gt;© 2017-2018&lt;/p&gt; &lt;a class="btn btn-sm"&gt;中文&lt;/a&gt; &lt;a class="btn btn-sm"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = "spring.mvc", name = "locale") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter("l"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split("_"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style="color: red" th:text="$&#123;msg&#125;" th:if="$&#123;not #strings.isEmpty(msg)&#125;"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute("loginUser"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute("msg","没有权限请先登陆"); request.getRequestDispatcher("/index.html").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); registry.addViewController("/main.html").setViewName("dashboard"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**") .excludePathPatterns("/index.html","/","/user/login"); &#125; &#125;; return adapter; &#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert="~&#123;footer :: copy&#125;"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert="footer :: copy"&gt;&lt;/div&gt;&lt;div th:replace="footer :: copy"&gt;&lt;/div&gt;&lt;div th:include="footer :: copy"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 123456789101112131415161718&lt;nav class="col-md-2 d-none d-md-block bg-light sidebar" id="sidebar"&gt; &lt;div class="sidebar-sticky"&gt; &lt;ul class="nav flex-column"&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link active" th:class="$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;" href="#" th:href="@&#123;/main.html&#125;"&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"&gt; &lt;path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"&gt;&lt;/path&gt; &lt;polyline points="9 22 9 12 15 12 15 22"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class="sr-only"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace="commons/bar::#sidebar(activeUri='emps')"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type="email" class="form-control" placeholder="zhangsan@atguigu.com"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action="@&#123;/emp&#125;" method="post"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name="_method";值就是我们指定的请求方式--&gt; &lt;input type="hidden" name="_method" value="put" th:if="$&#123;emp!=null&#125;"/&gt; &lt;input type="hidden" name="id" th:if="$&#123;emp!=null&#125;" th:value="$&#123;emp.id&#125;"&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name="lastName" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name="email" type="email" class="form-control" placeholder="zhangsan@atguigu.com" th:value="$&#123;emp!=null&#125;?$&#123;emp.email&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class="form-control" name="department.id"&gt; &lt;option th:selected="$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;" th:value="$&#123;dept.id&#125;" th:each="dept:$&#123;depts&#125;" th:text="$&#123;dept.departmentName&#125;"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary" th:text="$&#123;emp!=null&#125;?'修改':'添加'"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each="emp:$&#123;emps&#125;"&gt; &lt;td th:text="$&#123;emp.id&#125;"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text="$&#123;emp.email&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.gender&#125;==0?'女':'男'"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.department.departmentName&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class="btn btn-sm btn-primary" th:href="@&#123;/emp/&#125;+$&#123;emp.id&#125;"&gt;编辑&lt;/a&gt; &lt;button th:attr="del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;" class="btn btn-sm btn-danger deleteBtn"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(".deleteBtn").click(function()&#123; //删除当前员工的 $("#deleteEmpForm").attr("action",$(this).attr("del_uri")).submit(); return false; &#125;);&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put("timestamp", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView("error", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value("$&#123;error.path:/error&#125;")private String path = "/error"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = "error/" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("code","user.notexist"); map.put("message",e.getMessage()); return map; &#125;&#125;//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute("javax.servlet.error.status_code"); */ request.setAttribute("javax.servlet.error.status_code",500); map.put("code","user.notexist"); map.put("message",e.getMessage()); //转发到/error return "forward:/error"; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put("company","atguigu"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125; 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),"/myServlet"); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet")); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir("tomcat")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式Servlet容器启动原理； 什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info("Root context already created (using as parent)."); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), "No SpringApplication sources have been defined. Either override the " + "configure method or add an @Configuration annotation"); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125; 7）、Spring的应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; ==启动Servlet容器，再启动SpringBoot应用== 五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看linux的ip地址 1ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤： 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装MySQL示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql "docker-entrypoint.sh" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql "docker-entrypoint.sh" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql "docker-entrypoint.sh" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数 六、SpringBoot与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = "spring.datasource.type")static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 4、DataSourceInitializer：ApplicationListener； ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： 123456schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源12345678910111213141516171819202122232425262728293031323334353637383940414243导入druid数据源@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; &#125;&#125; 3、整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select("select * from department where id=#&#123;id&#125;") public Department getDeptById(Integer id); @Delete("delete from department where id=#&#123;id&#125;") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = "id") @Insert("insert into department(departmentName) values(#&#123;departmentName&#125;)") public int insertDept(Department department); @Update("update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;") public int updateDept(Department department);&#125; 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = "com.atguigu.springboot.mapper")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125; 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA1）、SpringData简介 2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 12345678910111213//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = "tbl_user") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = "last_name",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） 123//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 3）、基本的配置JpaProperties 1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 2、运行run方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer 123456public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println("ApplicationContextInitializer...initialize..."+applicationContext); &#125;&#125; SpringApplicationRunListener 123456789101112131415161718192021222324252627282930313233public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void starting() &#123; System.out.println("SpringApplicationRunListener...starting..."); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get("os.name"); System.out.println("SpringApplicationRunListener...environmentPrepared.."+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextPrepared..."); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextLoaded..."); &#125; @Override public void finished(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println("SpringApplicationRunListener...finished..."); &#125;&#125; 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println("ApplicationRunner...run...."); &#125;&#125; CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println("CommandLineRunner...run..."+ Arrays.asList(args)); &#125;&#125; 八、自定义starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567891011121314151617181920212223242526package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = "atguigu.hello")public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 123456789101112131415161718package com.atguigu.starter;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellAtguigu(String name)&#123; return helloProperties.getPrefix()+"-" +name + helloProperties.getSuffix(); &#125;&#125; 12345678910111213141516171819202122package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>JavaWeb</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析与挖掘基础]]></title>
    <url>%2F2019%2F08%2F15%2Fdatadigging01-base%2F</url>
    <content type="text"><![CDATA[简介什么是数据分析和挖掘？所谓数据分析，即对已知的数据进行分析，然后提取出一些有价值的信息，比如统计出平均数、标准差等信息，数据分析的数据量有时可能不会太大，而数据挖掘，是指对大量的数据进行分析与挖掘，得到一些未知的、有价值的信息等，比如从网站的用户或用户行为数据中挖掘出用户的潜在需求信息，从而对网站进行改善等。 数据挖掘需要数据分析为基础 数据分析与数据挖掘能做什么事？数据挖掘技术可以帮助我们更好地发现事物之间的规律。所以，我们可以利用数据挖掘技术实现数据规律的探索，比如发现窃电用户、发掘用户潜在需求、实现信息的个性化推送、发现疾病与症状甚至疾病与药物之间的规律……等。 数据挖掘的过程？ 定义目标 （分析什么数据，解决什么问题） 获取数据（爬虫、下载统计网站的数据） 数据探索 数据预处理(数据清洗【去掉脏数据】、数据集成【集中】、数据变换【规范 化】、数据规约【精简、合并】) 挖掘建模(分类、聚类、关联、预测) 模型评价与发布 相关模块相关模块简介 numpy 可以高效处理数据、提供数组支持、很多模块都依赖他，比如pandas、 scipy、matplotlib都依赖他，所以这个模块是基础。 pandas 我们课程后续用得最多的一个模块，主要用于进行数据探索和数据分析。 matplotlib 作图模块，解决可视化问题。 scipy 主要进行数值计算，同时支持矩阵运算，并提供了很多高等数据处理功能， 比如积分、傅里叶变换、微分方程求解等。 statsmodels 这个模块主要用于统计分析 Gensim 这个模块主要用于文本挖掘 sklearn、keras 前者机器学习，后者深度学习 numpy、mkl和scipy模块建议下载安装 相关模块基本使用numpy1234567891011import numpyx = numpy.array(["a","9","2"])y = numpy.array([[1,2,3,4], [5,6,7,8], [9,0,1,2,3], [4,5,6,67]])print(y)print(y[1][2]) pandas12345678910111213141516171819202122232425262728293031323334353637import pandas as pda'''Series #index索引DataFrame'''a = pda.Series([8,9,2,1])print(a)# indexa = pda.Series([8,9,2,1],index=["one","two","three","four"])print(a)b = pda.DataFrame([[5,4,3,2],[6,4,3,4],[3,4,6,4]])print(b)b = pda.DataFrame([[5,4,3,2],[6,4,3,4],[3,4,6,4]],columns = ["one","two","three","four"])print(b)c = pda.DataFrame(&#123; "one":4, "two":[6,5,3], "three":list(str(982))&#125;)print(c)# 头部尾部数据，默认前五行d = c.head(2) # 前两行e = c.tail(1) # 后一行print(d)print(e)# 统计信息，总计、平均数、标准差、最小、分位数、最大print(b.describe())# 转置print(c.T) Python数据导入导入excel1234567891011import pandas as pdai = pda.read_csv("/Users/biandudu/Documents/webcrawerfiles/hexun.csv")print(i.describe())# 按照某一列排序print(i.sort_values(by="hits"))j = pda.read_excel("/Users/biandudu/Documents/webcrawerfiles/abc.xls")print(j) 导入mysql123456789import pandas as pdaimport pymysqlconn = pymysql.connect(host="127.0.0.1",user="root",passwd="123456",db="data_analysis")sql = "select * from company"k = pda.read_sql(sql,conn)print(k.describe()) 导入html 使用pandas，可以直接从html网页中加载对应table表格中的数据，但是在使用read_html()之前，需要先安装html5lib模块与beautifulsoup4模块。 pda.read_html() 导入文本pda.read_table()]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>DataMine</tag>
        <tag>Data Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反思和抉择]]></title>
    <url>%2F2019%2F06%2F23%2Fthink-out-loud%2F</url>
    <content type="text"><![CDATA[四年时光一晃而过，剩下个茫然无措的我 一直以来我都是信奉及时行乐的人，沉醉于当下的快乐让我在短时间里忘掉了所有需要我去直面的问题和困境。其实人都是很短视的动物，延迟满足感是很难的。过去的一年我所有的选择现在看来基本都是错误的，在决定了考研之后去参加了实习，在即将参加实习工作的时候又想要考研。多变让我没有办法在有限的时间致力于同一件事，总是会冒出一些奇怪的想法，然后做出乱七八糟的决定。这些小小的决定就一点点改变了我人生的走向。现在工作的同学都参与了工作积极转正，考研的同学都考上了自己期望中的学校准备深造。我便又一次陷入了迷茫，又开始质疑自己的决定。昨天看到了知乎对于20岁年轻人的建议，唯一的感悟就是，自己早一点看到这些就好了。但我看过的鸡汤以及人生建议还少吗？大道至简，知易行难，也便造就了不同人不同的人生。 那即将步入25岁的我们，到底应该做些什么呢？ 从不后悔自己走过的弯路，它是我自己的选择，也是我生命的一部分。 一个完全规律生活，事事精确控制的人，和一个不珍惜时间，生活彻底失控的人，在本质上都是一样的。辜负了生命赐予我们的无数精彩可能。经历本身也是一种财富。有些事现在不做，以后就真的再也没有机会了。在自己的青春了我做出了自己的选择，也必然要承受其中的代价。有得必有失，我只是想尽力留住那些我认为珍贵的东西，只是想要多留下一些珍贵的记忆。大不了，也就是年轻不成熟时“走过的弯路”罢了。]]></content>
      <tags>
        <tag>Reflect on myself</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How Africa is Becoming China's China]]></title>
    <url>%2F2019%2F05%2F24%2FAferica-China%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/China.mp4","pic":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/2019-08-28%2F1566993623.png"},"danmaku":{"id":"Africa","api":"https://dplayer.moerats.com/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>Share</tag>
        <tag>China</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MFCC探索]]></title>
    <url>%2F2019%2F01%2F16%2FMFCCExplore%2F</url>
    <content type="text"><![CDATA[毕业设计进展报告五——陶家成一周主要工作内容 了解特征提取的过程 了解MFCC及其实现原理 了解HMM 打了一些codeforces的题 《语音信号处理》、《Automatic Speech Recognition》 未完成： 了解傅立叶变换及其在深度学习中的应用 具体内容关于音频特征MFCC提取MFCC概述 根据人耳听觉机理的研究发现，人耳对不同频率的声波有不同的听觉敏感度。所以，人们从低频到高频这一段频带内按临界带宽的大小由密到疏安排一组带通滤波器，对输入信号进行滤波。将每个带通滤波器输出的信号能量作为信号的基本特征，对此特征经过进一步处理后就可以作为语音的输入特征。由于这种特征不依赖于信号的性质，对输入信号不做任何的假设和限制，又利用了听觉模型的研究成果。因此，这种参数比基于声道模型的LPCC相比具有更好的鲁邦性，更符合人耳的听觉特性，而且当信噪比降低时仍然具有较好的识别性能。 梅尔倒谱系数是在Mel标度频率域提取出来的倒谱参数，Mel标度描述了人耳频率的非线性特性，它与频率的关系可用下式近似表示： ​ $Mel(f) = 2595 · lg(1 + f/700)$ Mel频率与线性频率的关系： MFCC特征提取过程包括 对音频信号预加重、分帧和加窗 FFT(快速傅里叶变换)得到频谱 频谱通过Mel滤波器组得到Mel频谱 在Mel频谱上面进行倒谱分析得到MFCC特征 通过这个MFCC特征提取过程，语音就可以通过一系列的倒谱向量来描述了，每个向量就是每帧的MFCC特征向量。语音识别系统就可以接着在MFCC特征的基础上进行训练和识别了。 预加重 预加重的目的是提升高频部分，对语音的高频部分进行加重，去除口唇辐射的影响，增加语音的高频分辨率使信号的频谱变得平坦，保持在低频到高频的整个频带中，能用同样的信噪比求频谱。原因是因为对于语音信号来说，语音的低频段能量较大，能量主要分布在低频段，语音的功率谱密度随频率的增高而下降，这样，鉴频器输出就会高频段的输出信噪比明显下降，从而导致高频传输衰弱，使高频传输困难，这对信号的质量会带来很大的影响。因此，在传输之前把信号的高频部分进行加重，然后接收端再去重，能够提高信号传输质量。 预加重相当于图片处理中的灰度拉伸/二值化，「增加识别的准确性」 预加重其实是将语音信号通过一个高通滤波器： $x_p(n) = x(n) - k·(n-1)$ （任取k，但是语音处理通常用0.9-0.97） 分帧 语音信号的变化是非常迅速的，但是通常傅里叶变换适用于分析平稳的信号。我们假设在较短的时间跨度范围内，语音信号的变换是平坦的，一般取这个时间跨度为20ms-40ms。为什么取这个范围呢，因为能够保证一帧内既有足够多的周期，又不会变化太剧烈。 为了「分离平滑帧」 加窗 每帧信号通常要与一个平滑的窗函数相乘，让帧两端平滑地衰减到零，这样可以降低傅里叶变换后旁瓣的强度，取得更高质量的频谱。对每一帧，选择一个窗函数，窗函数的宽度就是帧长。常用的窗函数有矩形窗、汉明窗、汉宁窗、高斯窗等。 为了「取得更高质量的频谱」 假设分帧后的信号为S(n), n=0,1…,N-1, N为帧的大小，那么乘上汉明窗 后，W(n)的形式如下： FFT(快速傅立叶变换) 由于信号在时域上的变换通常很难看出信号的特性，所以通常将它转换为频域上的能量分布来观察，不同的能量分布，就能代表不同语音的特性。所以在乘上汉明窗后，每帧还必须再经过快速傅里叶变换以得到在频谱上的能量分布。 得到「频谱的能量分布」 对语音信号频谱取模平方得到语音信号谱线能量。 声谱图「重点部分」声谱图的作用： 音素以及它们的属性更易于观察 通过观察共振峰和它们的转变可以更好的识别声音 隐马尔科夫模型就是隐含地对声谱图进行建模以达到好的识别性能 能够直观的评估TTS系统（text to speech）的好坏，直接对比合成的语音和自然的语音声谱图的匹配度即可 经过前面的预处理，每帧语音都对应一个频谱。 「但是这部分还是看不太懂」 计算通过Mel滤波器的能量将能量谱通过一组Mel尺度的三角形滤波器组，定义一个有M个滤波器的滤波器组（滤波器的个数和临界带的个数相近），采用的滤波器为三角滤波器，中心频率为f(m) 。M通常取22-26。各f(m)之间的间隔随着m值的减小而缩小，随着m值的增大而增宽，如图所示： 对频谱进行平滑化，并消除谐波的作用，突显原先语音的共振峰。（因此一段语音的音调或音高，是不会呈现在MFCC 参数内，换句话说，以MFCC 为特征的语音辨识系统，并不会受到输入语音的音调不同而有所影响）此外，还可以降低运算量。 三角滤波器的频率响应定义为: 计算每个滤波器组输出的对数能量为 ： 计算DCT倒谱经离散余弦变换（DCT）得到MFCC系数 : 将上述的对数能量带入离散余弦变换，求出L阶的Mel参数。L阶指MFCC系数阶数，通常取12-16。这里M是三角滤波器个数。 在六大区实现的官方源码中使用HTK实现MFCC和HMM 整个HTK是使用HMM作为语音识别的核心，当HMM应用于孤立词语音识别时，它用不同的隐含状态来描述不同的语音发音，对于连续语音识别系统，多个孤立词HMM子模型按一定的语言模型组成的复合HMM模型序列来刻画连续的语音信号，在序列中每个模型直接对应于相关的发音，并且每一个模型都有进入和退出状态，这两个状态没有对应的观察矢量，只用于不同模型的连接。 HTK是英国剑桥大学开发的一套基于C语言的隐马尔科夫模型工具箱，主要应用于语音识别、语音合成的研究，也被用在其他领域，如字符识别和DNA排序等。HTK是重量级的HMM版本。 代码位置：inferenceLSTM/read_data和inferenceLSTM/HTKfile HTK文件结构：帧数：4字节（第0-第3字节） 采样周期：4字节（第4-第7字节） 每一帧的字节数：2字节（第8-第9字节） 参数类型：2字节（第10-第11字节） 数据：N字节（第12字节开始-文件结尾） TODO 把文件中的主要代码和预处理脚本都理清看懂 完成采集数据集的准备工作，弄清音频的要求 弄懂声谱图部分，性能调优的方向之一 看书《深度学习中文版》 第三章——概率与信息论 第八章——深度模型中的优化 第十章——循环和递归网络——LSTM 学好算法，打打codeforces ADD 了解傅立叶变换及其在深度学习中的应用]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>About</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语音识别初实现]]></title>
    <url>%2F2019%2F01%2F04%2FASRExplore%2F</url>
    <content type="text"><![CDATA[语音识别初实现——傅立叶变换、MFCC、HMM读取和绘制音频数据 读取音频文件并可视化展现 音频文件是实际音频信哈的数字化形式，实际的音频信号是复杂的连续波形。为了将其保存成数字化形式，需要对音频信号进行采样并将其转换成数字。语音通常以44100 Hz的频率进行采样，这就意味着每秒钟信号被分解成44100份，然后这些抽样值被保存。 代码实现：123456789101112131415161718192021222324252627282930import numpy as npimport matplotlib.pyplot as pltfrom scipy.io import wavfile# 使用wavfile包从input_read.wav中读取音频文件:sampling_freq, audio = wavfile.read('input_read.wav')# 打印信号相关参数print ('\nShape:', audio.shape)print ('Datatype:', audio.dtype)print ('Duration:', round(audio.shape[0] / float(sampling_freq), 3), 'seconds')# 标准化audio = audio / (2.**15)# 提取前30个值画图audio = audio[:30]# 建立时间轴，x轴按照采样频率因子进行缩放x_values = np.arange(0, len(audio), 1) / float(sampling_freq)# 单位转换为secondsx_values *= 1000# 画出声音信号图形plt.plot(x_values, audio, color='black')plt.xlabel('Time (ms)')plt.ylabel('Amplitude')plt.title('Audio signal')plt.show() 将音频信号转化为频域 音频信号是不同频率、幅度和相位的正弦波的复杂混合。正弦波也称作正弦曲线。音频信号的频率内容中隐藏了很多信息。事实上，一个音频信号的性质由其频率内容决定。世界上的语音和音乐都是基于这个事实的。 //Todo 傅立叶变换 123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npfrom scipy.io import wavfileimport matplotlib.pyplot as plt# Read the input filesampling_freq, audio = wavfile.read('input_freq.wav')# Normalize the valuesaudio = audio / (2.**15)# 提取数组长度len_audio = len(audio)# 傅立叶变换，因为傅立叶变换是关于中心点对称的，因此只需要转换信号的前半部分。# 最终目标是提取功率信号，先将信号的值平方transformed_signal = np.fft.fft(audio)half_length = np.ceil((len_audio + 1) / 2.0)transformed_signal = abs(transformed_signal[0:half_length])transformed_signal /= float(len_audio)transformed_signal **= 2# 提取信号长度len_ts = len(transformed_signal)# 将部分信号乘以2if len_audio % 2: transformed_signal[1:len_ts] *= 2else: transformed_signal[1:len_ts-1] *= 2# 获取功率信号power = 10 * np.log10(transformed_signal)# Build the time axisx_values = np.arange(0, half_length, 1) * (sampling_freq / len_audio) / 1000.0# Plot the figureplt.figure()plt.plot(x_values, power, color='black')plt.xlabel('Freq (in kHz)')plt.ylabel('Power (in dB)')plt.show() 提取频域特征 将信号转换为频域之后，还需要将其转换成有用的形式。梅尔频率倒谱系数(Mel Frequency Cepstrum Coefficient，MFCC)可以解决这个问题。MFCC首先计算信号的功率谱，然后用滤波器组和离散余弦变换的组合来提取特征。 //Todo 梅尔频率倒谱系数 1234567891011121314151617181920212223242526272829303132import numpy as npimport matplotlib.pyplot as pltfrom scipy.io import wavfile from features import mfcc, logfbank# Read input sound filesampling_freq, audio = wavfile.read("input_freq.wav")# Extract MFCC and Filter bank features# 提取MFCC和过滤器组特征mfcc_features = mfcc(audio, sampling_freq)filterbank_features = logfbank(audio, sampling_freq)# Print parameters# 查看可以生成多少个窗体print ('\nMFCC:\nNumber of windows =', mfcc_features.shape[0])print ('Length of each feature =', mfcc_features.shape[1])print ('\nFilter bank:\nNumber of windows =', filterbank_features.shape[0])print ('Length of each feature =', filterbank_features.shape[1])# Plot the features# 画出特征图mfcc_features = mfcc_features.Tplt.matshow(mfcc_features)plt.title('MFCC')# 滤波器组特征可视化，需要转换矩阵，使得域是水平的filterbank_features = filterbank_features.Tplt.matshow(filterbank_features)plt.title('Filter bank')plt.show() 创建一个隐马尔可夫模型 本例将用到隐马尔科夫模型(Hidden Markov Models，HMMs)来做语音识别。隐马尔科夫模型非常擅长建立时间序列数据模型。因为一个音频信号同时也是一个时间序列信号，因此隐马尔科夫模型也同样适用于音频信号的处理。假定输出是通过隐藏状态生成的，我们的目标是找到这些隐藏状态，以便对信号建模。 // Todo 隐马尔科夫模型 创建一个语音识别器 我们需要为每一类构建一个隐马尔科夫模型。如果想识别新的输入文件中的单词，需要对该文件运行所有的模型，并找出最佳分数的结果。下面将用到在前一节构建的隐马尔科夫类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import osimport argparse import numpy as npfrom scipy.io import wavfile from hmmlearn import hmmfrom features import mfcc# 用于解析命令行中输入的参数def build_arg_parser(): parser = argparse.ArgumentParser(description='Trains the HMM classifier') parser.add_argument("--input-folder", dest="input_folder", required=True, help="Input folder containing the audio files in subfolders") return parser# 创建类处理HHM相关过程class HMMTrainer(object): # 初始化该类。下面将用到高斯隐马尔科夫模型(Gaussian HMMs)来对数据建模。参数 n_components定义了隐藏状态的个数，参数cov_type定义了转移矩阵的协方差类型，参数 n_iter定义了训练的迭代次数 def __init__(self, model_name='GaussianHMM', n_components=4, cov_type='diag', n_iter=1000): # 初始化变量 self.model_name = model_name self.n_components = n_components self.cov_type = cov_type self.n_iter = n_iter self.models = [] # 用以下参数定义模型 if self.model_name == 'GaussianHMM': self.model = hmm.GaussianHMM(n_components=self.n_components, covariance_type=self.cov_type, n_iter=self.n_iter) else: raise TypeError('Invalid model type') # 输入数据是一个NumPy数组，数组的每个元素都是一个特征向量，每个特征向量都包含k 个维度 # X is a 2D numpy array where each row is 13D def train(self, X): np.seterr(all='ignore') self.models.append(self.model.fit(X)) # 基于该模型定义一个提取分数的方法 # Run the model on input data def get_score(self, input_data): return self.model.score(input_data) # 定义一个main函数，解析输入的参数if __name__=='__main__': args = build_arg_parser().parse_args() input_folder = args.input_folder # 初始化隐马尔科夫模型的变量 hmm_models = [] # 解析包含所有数据库音频文件的输入路径 for dirname in os.listdir(input_folder): # 提取子文件夹的名称 subfolder = os.path.join(input_folder, dirname) if not os.path.isdir(subfolder): continue # 子文件夹的名称即为该类的标记，提取标记 label = subfolder[subfolder.rfind('/') + 1:] # 初始化变量 X = np.array([]) y_words = [] # 迭代每一个子文件夹中的音频文件（分别保留一个进行测试） for filename in [x for x in os.listdir(subfolder) if x.endswith('.wav')][:-1]: # 读取每个音频文件 filepath = os.path.join(subfolder, filename) sampling_freq, audio = wavfile.read(filepath) # 提取MFCC特征 mfcc_features = mfcc(audio, sampling_freq) # 将MFCC特征添加到X变量 if len(X) == 0: X = mfcc_features else: X = np.append(X, mfcc_features, axis=0) # 添加标记 y_words.append(label) print 'X.shape =', X.shape # 一旦提取完当前类所有文件的特征，就可以训练并保存隐马尔科夫模型了。因为隐马尔科夫模型是一个无监督学习的生成模型，所以并不需要利用标记针对每一类构建隐马尔科夫模型。 # Train and save HMM model hmm_trainer = HMMTrainer() hmm_trainer.train(X) hmm_models.append((hmm_trainer, label)) hmm_trainer = None # Test files（获取一个未被用于训练的测试文件列表） input_files = [ 'data/pineapple/pineapple15.wav', 'data/orange/orange15.wav', 'data/apple/apple15.wav', 'data/kiwi/kiwi15.wav' ] # 为输入数据分类 for input_file in input_files: # Read input file sampling_freq, audio = wavfile.read(input_file) # 提取MFCC特征 mfcc_features = mfcc(audio, sampling_freq) # Define variables max_score = None output_label = None # 迭代HMM模型并选取得分最高的模型 # the one with the highest score for item in hmm_models: hmm_model, label = item # 提取并保存最大分数 score = hmm_model.get_score(mfcc_features) if score &gt; max_score: max_score = score output_label = label # Print the output print "\nTrue:", input_file[input_file.find('/')+1:input_file.rfind('/')] print "Predicted:", output_label]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>About</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习初探]]></title>
    <url>%2F2019%2F01%2F03%2FDLWithPyFirstExlpore%2F</url>
    <content type="text"><![CDATA[深度学习初探——基于Python的理论和实现此书特点： 从零开始实现深度学习程序 最终实现一个高精度识别图像的系统 从实现层面理解误差反向传播法、卷积运算 不介绍深度学习框架 不介绍参数调优 不进行GPU相关实现 目标：有能力进一步去阅读最新的论文或者神经网络相关的理论方面的技术书。 Python入门Numpy 在深度学习的实现中，经常出现数组和矩阵的计算。NumPy 的数组类 (numpy.array)中提供了很多便捷的方法，在实现深度学习时，我们将使用这些方法。 导入Numpy库Python中使用import语句来导入库。这里的import numpy as np，直译的话就是“将 numpy 作为 np 导入”的意思。通过写成这样的形式，之后NumPy 相关的方法均可通过 np 来调用。 生成Numpy数组生成 NumPy 数组，需要使用 np.array() 方法。 Numpy的算数运算当数组 x 和数组 y 的元素个数相同时，可以对各个元素进行算术运算。 Numpy的N维数组1A = np.array([[1, 2], [3, 4]]) 广播形状不同的数组之间也可以进行运算。标量数组扩展成2*2数组再计算，称之为广播。 访问元素逐个访问，for语句访问，数组访问 Matplotlib 在深度学习的实验中，图形的绘制和数据的可视化非常重要。Matplotlib是用于绘制图形的库，使用 Matplotlib 可以轻松地绘制图形和实现数据的可视化。 pyplot的功能添加标题和x轴标签名等功能 1234567891011121314151617# coding: utf-8import numpy as npimport matplotlib.pyplot as plt# 生成数据x = np.arange(0, 6, 0.1) # 以0.1为单位，生成0到6的数据y1 = np.sin(x)y2 = np.cos(x)# 绘制图形plt.plot(x, y1, label="sin")plt.plot(x, y2, linestyle = "--", label="cos")plt.xlabel("x") # x轴的标签plt.ylabel("y") # y轴的标签plt.title('sin &amp; cos')plt.legend()plt.show() 显示图像pyplot提供了用于显示图像的方法imshow()。另外，可以使用matplotlib.image 模块的 imread() 方法读入图像。 12345678# coding: utf-8import matplotlib.pyplot as pltfrom matplotlib.image import imreadimg = imread('../dataset/lena.png') #读入图像plt.imshow(img)plt.show() 图像放在dataset目录下，可以直接读取。 感知机感知机是什么？ 感知机是作为神经网络(深度学习)的起源的算法。感知机接收多个输入信号，输出一个信号。这里所说的“信号”可以想象成电流或河流那样具备“流动性”的东西。像电流流过导线，向前方输送电子一样，感知机的信号也会形成流，向前方输送信息。但是，和实际的电流不同的是，感知机的信号只有“流 / 不流”(1/0)两种取值。 x1、x2 是输入信号，y是输出信号，w1、w2 是权重(w是weight的首字母)。图中的○称为“神经元”或者“节点”。输入信号被送往神经元时，会被分别乘以固定的权重(w1x1、w2x2)。神经元会计算传送过来的信号的总和，只有当这个总和超过了某个界限值时，才会输出1。这也称为“神经元被激活”。b称为偏置的参数，用于控制神经元被激活的容易程度。 数学表示： 感知机多个输入信号有各自的权重，这些权重发挥着控制着各个信号的重要性的作用。权重越大，信号的重要性就越高。（权重相当于电流中的电阻，电阻决定电流流动难度的参数） 简单逻辑电路我们已经知道使用感知机可以表示与门、与非门、或门的逻辑电路。这里重要的一点是:与门、与非门、或门的感知机构造是一样的。实 际 上 ， 3 个门电路只有参数的值(权重和阈值)不同 。 感知机的实现使用权重和偏置实现与门： 123456789101112131415161718# coding: utf-8import numpy as npdef AND(x1, x2): x = np.array([x1, x2]) w = np.array([0.5, 0.5]) b = -0.7 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 else: return 1if __name__ == '__main__': for xs in [(0, 0), (1, 0), (0, 1), (1, 1)]: y = AND(xs[0], xs[1]) print(str(xs) + " -&gt; " + str(y)) 使用感知机可以实现与门、与非门、或门三种逻辑电路。 感知机的局限性 感知机无法实现异或门 感知机无法表示曲线 多层感知机 通过组合与门、与非门、或门实现异或门 通过叠加层(加深层)，感知机能进行更加灵活的表示。 神经网络 感知机的作用是：即便对于复杂的函数，也隐含着能够表示它的可能性。神经网络的一个重要性质是可以自动从数据中学习合适的权重参数。 从感知机到神经网络神经网络的例子用图来表示神经网络，分为输入层、输出层和中间层。中间层也叫隐藏层，隐藏层的神经元肉眼看不见。神经元的连接方式而言，与感知机并无差别。 复习感知机明确表示出偏置，简化式子，引入新函数h(x) ： 激活函数h(x)函数会将输入信号的总和转换为输出信号，这种函数一般称为激活函数(activation function)。激活函数的作用在于决定如何来激活输入信号的总和。 先计算输入信号的加权总和，然后用激活函数转换这一总和： 明确显示激活函数计算过程的神经元 ： 信号的加权总和为节点 a，然后节点 a 被激活函数 h() 转换成节点 y。“神经元”和“节点”两个术语的含义相同。 激活函数是连接感知机和神经网络的桥梁。 激活函数 激活函数以阈值为界，一旦输入超过阈值，就切换输出。这样的函数称为“阶跃函数”。因此，可以说感知机中使用了阶跃函数作为激活函数。也就是说，在激活函数的众多候选函数中，感知机使用了阶跃函数。那么，如果感知机使用其他函数作为激活函数的话会怎么样呢?实际上，如果将激活函数从阶跃函数换成其他函数，就可以进入神经网络的世界了。 sigmoid函数神经网络经常使用的一个激活函数sigmoid函数： 神经网络利用sigmoid函数作为激活函数，进行信号的转换，转换后的信号被传送到下一个神经元。感知机和神经网络的主要区别就在于这个激活函数。在其它方面，比如神经元的多层连接的构造，信号的传递方法等，基本上和感知机是一样的。 阶跃函数的实现简单的阶跃函数： 12345def step_function(x): if x &gt; 0: return 1 else: return 0 支持NumPy数组的实现： 123def step_function(x): y = x &gt; 0 return y.astype(np.int) NumPy数组进行不等号运算后，数组的各个元素都会进行不等号运算，生成一个布尔型的数组。数组y是个布尔型的数组，但是阶跃函数是会输出int型的0或1的函数。因此需要转换为int型。 可以用 astype() 方法转换 NumPy 数组的类型。astype() 方法通过参数指定期望的类型，这个例子中是 np.int 型。 阶跃函数的图形图形上表示上面定义的阶跃函数，需要用到matplotlib库： 12345678910111213import numpy as npimport matplotlib.pylab as pltdef step_function(x): return np.array(x &gt; 0, dtype = np.int)#−5.0到5.0的范围内，以0.1为单位，生成 NumPy数组([-5.0, -4.9, ..., 4.9])x = np.arange(-5.0,5.0,0.1)#step_function()以该NumPy数组为 参数，对数组的各个元素执行阶跃函数运算，并以数组形式返回运算结果。y = step_function(x)plt.plot(x,y)plt.ylim(-0.1,1.1) #指定y轴的范围plt.show() 阶跃函数以 0 为界，输出从 0 切换为 1(或者从 1 切换为 0)。 它的值呈阶梯式变化，所以称为阶跃函数。 sigmoid函数的实现12345def sigmoid(x): return 1 / (1 + np.exp(-x))x = np.array([-1.0, 1.0, 2.0])sigmoid(x) 在python中可以如此表示sigmoid函数，当传入参数x为NumPy数组时，也能被正确计算，是因为NumPy的广播功能。 现在把上面的阶跃函数换成sigmoid函数： sigmoid函数和阶跃函数的比较： sigmoid函数是一条平滑的曲线，输入输出发生连续的变化。阶跃则是以0为界，急剧变化。 阶跃函数只能返回0和1，sigmoid函数可以返回实数 都是非线性函数： 激活函数不能使用线性函数，使用线性函数，加深网络的层数就没有意义了。 线性函数无法发挥多层网络带来的优势 ReLU函数sigmoid早就开始用了，现在主要使用ReLU（Rectified Linear Unit）函数。 ReLU函数输入大于 0 时，直接输出该值;在输入小于等于 0 时，输出 0 ： ReLU函数的实现： 12def relu(x): return np.maximum(0,x) 多维数组的运算多维数组运算可以高效实现神经网络 二维矩阵1B = np.array([[1,2], [3,4], [5,6]]) 矩阵的乘积：（np.dot(A, B)和np.dot(B, A)不同） 123A = np.array([[1,2], [3,4]])B = np.array([[5,6], [7,8]])np.dot(A, B) A的列数必须和B的行数相等才能计算np.dot(A,B) 神经网络的内积使用NumPy矩阵实现神经网络：（省略了偏置和激活函数，只有权重） 三层神经网络的实现巧妙使用NumPy数组，可以使用很少的代码实现神经网络的前向处理。 符号确认 表示前一层的第 2 个神经元 x2 到后一层的第 1 个神经元 的权重。w(weight) 各层间信号传递的实现 矩阵乘法运算，则可以表示成： 代码简单实现上述式子： 123456X = np.array([1.0, 0.5])W1 = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.6]]) B1 = np.array([0.1, 0.2, 0.3])A1 = np.dot(X, W1) + B1 #x的列数和w的行数相同，w和x对应维度的个数也保持一致#前面的乘积的到一个3列，加上B的3列 隐藏层的加权和(加权信号和偏置的总和)用 a 表示，被激活函数转换后的信号用 z 表示。此外，图中 h() 表示激活函数，这里我们使用的是 sigmoid 函数： 1234Z1 = sigmoid(A1)print(A1)print(Z1) 下面实现第一层到第二层的信号传递： 1234567W2 = np.array([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]])B2 = np.array([0.1, 0.2])print(Z1.shape) # (3,) print(W2.shape) # (3, 2) print(B2.shape) # (2,)A2 = np.dot(Z1, W2) + B2 Z2 = sigmoid(A2) 实现基本相同，但是最后的激活函数和隐藏层的有所不同。 12345678def identity_function(x): return xW3 = np.array([[0.1, 0.3], [0.2, 0.4]]) B3 = np.array([0.1, 0.2])A3 = np.dot(Z2, W3) + B3Y = identity_function(A3) # 或者Y = A3 这里的identity_function()函数（恒等函数），并将其作为输出层的激活函数。这样实现只是为了和之前的流程保持统一。 输出层所用的函数：根据求解问题的性质决定： 回归问题用恒等函数 二元分类问题使用sigmoid函数 多元分类问题使用softmax函数 代码实现小结12345678910111213141516171819202122232425def init_network(): #初始化为字典变量&#123;&#125; network = &#123;&#125; network['W1'] = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.6]]) network['b1'] = np.array([0.1, 0.2, 0.3]) network['W2'] = np.array([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]]) network['b2'] = np.array([0.1, 0.2]) network['W3'] = np.array([[0.1, 0.3], [0.2, 0.4]]) network['b3'] = np.array([0.1, 0.2]) return networkdef forward(network,x): W1, W2, W3 = network['W1'], network['W2'], network['W3'] b1, b2, b3 = network['b1'], network['b2'], network['b3'] a1 = np.dot(x, W1) + b1 z1 = sigmoid(a1) a2 = np.dot(z1, W2) + b2 z2 = sigmoid(a2) a3 = np.dot(z2, W3) + b3 y = identity_function(a3) return ynetwork = init_network()x = np.array([1.0, 0.5])y = forward(network, x)print(y) # [ 0.31682708 0.69627909] 定义了init_network()和forward()函数，分别进行权重的初始化和信号处理。后面会有backword()处理函数（从输出往输入方向的处理）。通过NumPy的多维数组，高效地实现了神经网络。 输出层的设计神经网络可以用在分类问题和回归问题上，需要根据情况改变输出层的激活函数，回归问题用恒等函数，分类问题用softmax函数。 恒等函数和softmax 函数和前面隐藏层的激活函数一样，恒等函数进行的转换处理可以用一根箭头表示。 分类问题中的softmax函数可以用下面的式子表示： softmax 函数的分子是输入信号 ak 的指数函数，分母是所有输入信号的指数函数的和。 softmax函数的输出通过肩头和所有的信号相连，输出层的各个神经元都受到输入信号的影响。 softmax函数的实现： 123456def softmax(a): exp_a = np.exp(a) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y 实现softmax函数的注意事项上面的softmax的实现存在溢出问题，指数运算的值很容易溢出，如果超大的值进行除法运算就会出现不确定的情况。溢出问题在进行计算的运算时必须注意！ 改进： 指数运算时加上某个常数并不会改变运算结果，这里的C‘为了防止溢出，一般使用输入信号中的最大值的相反数。 softmax改进后的函数实现： 1234567def softmax(a): c = np.max(a) exp_a = np.exp(a-c) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y softmax的函数特征 因为指数函数是单调递增函数，即便使用了softmax函数各个元素之间的大小关系也不会改变。一般来说，神经网络只把输出值最大的神经元对应的类别作为识别结果。即便使用softmax函数，输出值最大的神经元也不会改变，在神经网络分类时，softmax函数可以省略。 求解机器学习问题的步骤可以分为“学习”A 和“推理”两个阶段。首先，在学习阶段进行模型的学习 B，然后，在推理阶段，用学到的模型对未知的数据进行推理(分类)。如前所述，推理阶段一般会省略输出层的 softmax 函数。在输出层使用 softmax 函数是因为它和神经网络的学习有关系。 softmax的函数输出总是在0.0到1.0之间 softmax函数的输出值总和为1，所以softmax可以解释为概率。 通过使用softmax函数，可以使用概率论统计的方法处理问题 输出层神经元数量输出层的神经元数量需要根据待解决的问题来决定。对于分类问题，输出层的神经元数量一般设定为类别的数量。 手写数字识别使用学习到的参数，先实现神经网络的“推理处理”。这个推理处理也称为神经网络的前向传播(forward propagation)。 MNIST数据集什么是MNIST？ MNIST手写数据集，是机器学习最有名的数据集之一。MNIST有训练图像6w张，测试图像1w张。 一般使用方法：先用训练图像进行学习，再用学习到的模型度量能够多大程度上对测试图像进行正确的分类。 MNIST图像数据是28像素x28像素的灰度图像，各个像素取值在0-255之间，每个图像对应有数字标签。 ch03/mnist_show.py使用mnist.py中的load_mnist()函数，就可以读取MNIST数据： 1234567891011121314151617181920212223242526# coding: utf-8import sys, ossys.path.append(os.pardir) # 为了导入父目录的文件而进行的设定import numpy as npfrom dataset.mnist import load_mnist # 调入自定义的load_mnist函数from PIL import Imagedef img_show(img): # Image.fromarray把保存为 NumPy 数组的图像数据转换为 PIL 用 的数据对象 pil_img = Image.fromarray(np.uint8(img)) pil_img.show()(x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=False)# 当flatten=True时读入的图像是以一列NumPy数组的形式保存的，显示图像时需要调用reshape()方法img = x_train[0]label = t_train[0]print(label) # 5print(img.shape) # (784,)img = img.reshape(28, 28) # 通过 reshape() 方法的参数指定期望的形状，更改 NumPy 数组的形状。print(img.shape) # (28, 28)img_show(img) 关于PIL（Python Image Library）是Python的图像处理标准库，功能非常强大，API简单易用。 PIL中的Image和NumPy中的array相互转换 PIL Image转换为array 1img = np.asarray(image 如果出现read-only错误，并不是转换的错误，一般是你读取的图片的时候，默认选择的是”r”,”rb”模式有关。 1img.flags.writeable = True # 将数组改为读写模式 array转换成image 1Image.fromarray(np.unit8(img)) 关于load_mnist函数的解释位于dataset/mnist.py的load_mnist`函数： 123456789101112131415161718192021222324def load_mnist(normalize=True, flatten=True, one_hot_label=False): # 如果数据不存在，调用init方法下载并转换 if not os.path.exists(save_file): init_mnist() # with能够自动处理上下文环境产生的异常 with open(save_file, 'rb') as f: dataset = pickle.load(f) if normalize: for key in ('train_img', 'test_img'): dataset[key] = dataset[key].astype(np.float32) dataset[key] /= 255.0 if one_hot_label: dataset['train_label'] = _change_one_hot_label(dataset['train_label']) dataset['test_label'] = _change_one_hot_label(dataset['test_label']) if not flatten: for key in ('train_img', 'test_img'): dataset[key] = dataset[key].reshape(-1, 1, 28, 28) return (dataset['train_img'], dataset['train_label']), (dataset['test_img'], dataset['test_label']) 通过传入布尔值来执行相关操作的函数： normalize（正规化）：将图像的像素值正规化为0.0~1.0。 将图像的各个像素值除以 255，使得数据的值在 0.0~1.0 的范围内。像这样把数据限定到某个范围内的处理称为正规化(normalization)。 flatten（扁平化）：是否将图像展开为一维数组。 one_hot_label（一条标签数组）：one_hot_label为True的情况下，标签作为one-hot数组返回。「one-hot数组是指[0,0,1,0,0,0,0,0,0,0]这样的数组」 读入MNIST数据集，返回(训练图像, 训练标签), (测试图像, 测试标签) 神经网路的推理处理神经网络输入层有784个神经元，输出层有10个神经元，输入层784源于图像大小28 x 28，输出层的10来源于10类别分类。此外还有两个隐藏层，第一层50个神经元，第二层100个神经元。50和100可以为任意值。 定义 get_data()、init_network()、predict() ：【neuralnet_mnist.py】 1234567891011121314151617181920212223242526272829303132333435363738394041424344# coding: utf-8import sys, ossys.path.append(os.pardir) # 为了导入父目录的文件而进行的设定import numpy as npimport picklefrom dataset.mnist import load_mnistfrom common.functions import sigmoid, softmax# 返回测试图像和测试标签def get_data(): (x_train, t_train), (x_test, t_test) = load_mnist(normalize=True, flatten=True, one_hot_label=False) return x_test, t_test# 读入保存在pickle文件sample_weight.pkl中的权重参数，这个文件以字典变量的形式保存了权重和偏置参数def init_network(): with open("sample_weight.pkl", 'rb') as f: network = pickle.load(f) return networkdef predict(network, x): W1, W2, W3 = network['W1'], network['W2'], network['W3'] b1, b2, b3 = network['b1'], network['b2'], network['b3'] a1 = np.dot(x, W1) + b1 z1 = sigmoid(a1) a2 = np.dot(z1, W2) + b2 z2 = sigmoid(a2) a3 = np.dot(z2, W3) + b3 y = softmax(a3) return yx, t = get_data() # 取出数据network = init_network()accuracy_cnt = 0for i in range(len(x)): y = predict(network, x[i]) p= np.argmax(y) # 获取概率最高的元素的索引 if p == t[i]: accuracy_cnt += 1print("Accuracy:" + str(float(accuracy_cnt) / len(x))) 这三个函数实现了神经网络的推理处理，然后评价识别精度（accuracy）： 获取MNIST的数据集，生成网络。 用 for 语句逐一取出保存在 x 中的图像数据，用 predict() 函数进行分类。「predict() 函数以 NumPy 数组的形式输出各个标签对应的概率」 取出这个概率列表中的最大值的索引，作为预测结果。「np.argmax(x) 将获取被赋给参数 x 的数组中的最大值元素的索引」 比较神经网络所预测的答案和正确解标签，将回答正确的概率作为识别精度 「注:」此处是假设学习已经完成，学习中的参数保存在sample_weight.pkl文件中，在推理阶段，直接加载这些学习到的参数 在刚才的例子中，作为一种预处理，我们将各个像素值除以 255，进行了简单的正规化。实际上，很多预处理都会考虑到数据的整体分布。比如，利用数据整体的均值或标准差，移动数据，使数据整体以 0 为中心分布，或者进行正规化，把数据的延展控制在一定范围内。除此之外，还有将数据整体的分布形状均匀化的方法，即数据白化(whitening)等。 批处理多维数组对应维度的元素个数一致，输入由784个元素组成的一维数组，最终输出元素个数为10的一维数组： 这是只输入一张图像数据时的处理流程。 比如，我们想用 predict()函数一次性打包处理 100 张图像。为此，可以把 x 的形状改为 100 × 784，将100 张图像打包作为输入数据： 此时，输入的100张图像的结果被一次性输出了。 12345678910111213x, t = get_data()network = init_network()batch_size = 100 # 批数量accuracy_cnt = 0for i in range(0, len(x), batch_size): x_batch = x[i:i+batch_size] y_batch = predict(network, x_batch) p = np.argmax(y_batch, axis=1) accuracy_cnt += np.sum(p == t[i:i+batch_size])print("Accuracy:" + str(float(accuracy_cnt) / len(x))) 批处理代码实现中的不同之处： 首先是range()函数： range(start, end)生成一个start到end-1之间的整数构成的列表 range(start, end, step)下一个元素会增加step x[i:i+batch_n]会取出从第 i 个到第 i+batch_n 个之间的数据。 通过 argmax() 获取值最大的元素的索引。不过这里需要注意的是，我们给定了参数 axis=1。这指定了在 100 × 10 的数组中，沿着第 1 维方向(以第 1 维为轴)找到值最大的元素的索引(第 0 维对应第 1 个维度)。 最后，比较一下以批为单位进行分类的结果和实际的答案 本章介绍的神经网络和上一章的感知机在信号的按层传递这一点上是相同的，但是，向下一个神经元发送信号时，改变信号的激活函数有很大差异。神经网络中使用的是平滑变化的 sigmoid函数，而感知机中使用的是信号急剧变化的阶跃函数。 神经网络学习 “学习”是指从训练数据中自动获取最优权重参数的过程。为了使神经网络能进行学习，将导入损失函数这一指标。而学习的目的就是以该损失函数为基准，找出能使它的值达到最小的权重参数。为了找出尽可能小的损失函数的值，利用了函数斜率的梯度法。 误差反向传播法 数值微分虽然简单，也容易实现，但缺点是计算上比较费时间。误差反向传播法能够高效计算权重参数的梯度。正确理解误差反向传播法，有两种方法：数学式和计算图 与学习相关的技巧 神经网络的学习中一些重要观点，主题涉及寻找最优权重参数的最优化方法、权重参数的初始值、超参数设定方法等。为了应对过拟合，还将介绍权值衰减、Dropout 等正则化方法，并进行实现。 卷积神经网络 本章主题是卷积神经网络（CNN），CNN用于图像识别、语音识别等场合，在图像识别比赛中，基于深度学习的方法几乎都以CNN为基础。 深度学习 深度学习是加深了层的深度神经网络。基于之前介绍的网络，只需通过叠加层，就可以创建深度网络。 关于神经网络，已经学了很多：构成神经网络的各种层、学习时的有效技巧、对图像特别有效的CNN、参数的最优方法等。本章将这些知识汇总起来，创建一个深度网络，挑战MNIST数据集的手写数字识别。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02 熟悉Urllib库]]></title>
    <url>%2F2018%2F12%2F12%2FPython-data-analysis02%2F</url>
    <content type="text"><![CDATA[三、Urllib库1. Urllib基础方法 urlretrieve() 爬一个网页 urlcleanup() 清除urlretrieve()生成的缓存 info() 展现基本环境信息 getcode() 当前网页的状态码 geturl() 当前网页的网址 1234567891011import urllib.requestimport sslssl._create_default_https_context = ssl._create_unverified_contexturllib.request.urlretrieve("http://hellobi.com",filename="/Users/biandudu/Documents/webcrawerfiles/1.html")urllib.request.urlcleanup()file = urllib.request.urlopen("http://www.hellobi.com"，timeout=5)print(file.info())print(file.getcode())print(file.geturl()) 2. 超时设置 并抛出异常 有些网站反应快，我们希望2秒钟没有反应，则判断为超时，那么此时，timeout的值就是2，再比如，有些网站服务器反应慢，那么此时，我们希望100秒没有反应，才判断为超时，那么此时timeout的值就是100。 1234567891011121314import urllib.requestimport sslssl._create_default_https_context = ssl._create_unverified_contextfor i in range(1,30): try: file = urllib.request.urlopen("http://hellobi.com", timeout=0.5) data = file.read() print(len(data)) except Exception as e: print("异常："+str(e))file.close() 3. 自动模拟HTTP请求 客户端如果要与服务器端进行通信，需要通过http请求进行，http请求有很多种，我们在此会讲post与get两种请求方式。比如登陆、搜索某些信息的时候会用到。 12345678910111213import urllib.requestimport sslssl._create_default_https_context = ssl._create_unverified_contextkeywd = "张译天"keywd = urllib.request.quote(keywd) # 对中文编码url = "http://www.baidu.com/s?wd="+keywd+"&amp;ie=utf-8&amp;tn=96542061_hao_pg"req = urllib.request.Request(url)data = urllib.request.urlopen(req).read()fh = open("/Users/biandudu/Documents/webcrawerfiles/2.html","wb")fh.write(data)fh.close() 自动提交post请求首先登陆这个网站：www.iqianyue.com/mypost/ 并分析源码 12345678910111213141516171819import urllib.requestimport urllib.parseimport sslssl._create_default_https_context = ssl._create_unverified_context# 设置表单内容url = "http://www.iqianyue.com/mypost/"mydata = urllib.parse.urlencode(&#123; "name":"ceo@sfsfd", "pass":"1232jas"&#125;).encode("utf-8") # 设置对应的信息，对应的编码# 封装请求req = urllib.request.Request(url,mydata) # 提交到的地址，提交的数据data = urllib.request.urlopen(req).read() # urlopen将对应请求提交过去，爬数据fh = open("/Users/biandudu/Documents/webcrawerfiles/3.html","wb") # 写入本地文件，wb二进制写入fh.write(data)fh.close() Tips： 找到登录，只需要关注 form 里的 name属性 找不到登录，隐藏在js文件中，我们需要通过 抓包 来进行分析 4. 异常处理 301 Moved Permanently 重定向到新的URL，永久性 302 Found 重定向到临时的URL，非永久性 304 Not Modified 请求的资源未更新 400 Bad Request 非法请求 401 Unauthorized 请求未经授权 403 Forbidden 禁止访问 404 Not Found 未找到对应页面 500 Internal Server Error 服务器内部错误 501 Not Implemented 服务器不支持实现请求所需要的功能 URLError和HTTPError12345678910111213import urllib.errorimport urllib.requestimport sslssl._create_default_https_context = ssl._create_unverified_contexttry: urllib.request.urlopen("http://blog.csdksdfjs.net/dsd") # csdn爬取会被屏蔽except urllib.error.URLError as e: # 捕获异常 if hasattr(e,"code"): # 是否有这个状态码属性，判断有没有code print(e.code) if hasattr(e,"reason"): # 判断是否有reason这个属性 print(e.reason) 5. 浏览器伪装技术 我们可以试试爬取csdn博客，我们发现会返回403，因为对方服务器会 对爬虫进行屏蔽。此时，我们需要伪装成浏览器才能爬取。浏览器伪装我们一般通过报头进行，接下来我们通过实战分析一下。 如果没有伪装会报403禁止访问错误1234567891011121314import urllib.requestimport sslssl._create_default_https_context = ssl._create_unverified_contexturl = "https://ask.hellobi.com/blog/weiwei/5322"headers=("User-Agent","Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36")opener = urllib.request.build_opener() # 创建一个opener对象opener.addheaders = [headers] # 添加报头信息data = opener.open(url).read()fh = open("/Users/biandudu/Documents/webcrawerfiles/6.html","wb")fh.write(data)fh.close() 6. Python新闻爬虫实战 需求:将新浪新闻首页(http://news.sina.com.cn/)所有新闻都爬到 本地。 思路:先爬首页，通过正则获取所有新闻链接，然后依次爬各新闻，并存储到本地。 12345678910111213141516import urllib.requestimport reimport sslssl._create_default_https_context = ssl._create_unverified_contextdata = urllib.request.urlopen("http://news.sina.com.cn/").read()data2 = data.decode("utf-8","ignore") # 有时候设置utf-8还会报错，就添加一个ignorepat='href="(https://news.sina.com.cn/.*?)"'allurl = re.compile(pat).findall(data2)for i in range(0,len(allurl)): thisurl = allurl[i] file = "/Users/biandudu/Documents/webcrawerfiles/sinanews/"+str(i)+".html" urllib.request.urlretrieve(thisurl,file) 作业三: 提取出版社信息并写入文件中12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from urllib import requestimport re,xlwt,datetimehtml=request.urlopen("https://read.douban.com/provider/all").read() #读取网页源代码内容html.decode("utf-8")wzgz="&lt;a href=\"(.*?)\" class=\"provider-item\"&gt;&lt;div class=\"col-media\"&gt;&lt;div class=\"cm-left avatar\"&gt;&lt;div class=\"avatar\"&gt;&lt;img src=\"(.*?)\"/&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"cm-body\"&gt;&lt;div class=\"name\"&gt;(.*?)&lt;/div&gt;&lt;div class=\"works-num\"&gt;(.*?) 部作品在售&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/a&gt;"xx=re.compile(wzgz).findall(str(html,"utf-8")) #通过正则表达式匹配在网页源代码中提取所需内容#print(xx)#创建workbook和sheet对象workbook = xlwt.Workbook()sheet1 = workbook.add_sheet('sheet1',cell_overwrite_ok=True)#初始化excel样式style = xlwt.XFStyle()#为样式创建字体font = xlwt.Font()font.name = 'Times New Roman'font.bold = True#设置样式的字体style.font = font#在sheet1表的第1行设置字段名称并写入数据sheet1.write(0,0,"序号",style)sheet1.write(0,1,"出版社-URL",style)sheet1.write(0,2,"LOGO-URL",style)sheet1.write(0,3,"出版社名称",style)sheet1.write(0,4,"在售作品数量",style)a=0 #定义行号初始值h=0 #定义在售数量初始值for i in xx: #print(str(a+1),i[0]) sheet1.write(a+1,0,a+1,style) #在第a+1行第1列写入序号 sheet1.write(a+1,1,"https://read.douban.com"+str(i[0]),style) #在第a+1行第2列写入出版社URL sheet1.write(a+1,2,i[1],style) #在第a+1行第3列写入LOGO-URL sheet1.write(a+1,3,i[2],style) #在第a+1行第4列写入出版社名称 sheet1.write(a+1,4,int(i[3]),style) #在第a+1行第5列写入在售数量 h+=int(i[3]) #在售数量累计求和 a+=1 if a==a: #判断XX列表是否遍历结束，并在sheet1表尾行写入在售数量求和的值 t=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S") t1=datetime.datetime.now().strftime("%Y%m%d%H%M%S") sheet1.write(a+1,3,"合计",style) #在sheet1表尾行写入“合计” sheet1.write(a+1,4,h,style) #在sheet1表尾行写入在售数量累计值 sheet1.write(a+2,3,"采集时间",style) #在sheet1表尾行写入数据采集时间 sheet1.write(a+2,4,t,style) #在sheet1表尾行写入数据采集时间workbook.save("d:/豆瓣出版社汇总表"+str(t1)+".xls") #保存该excel文件,有同名文件时无法直接覆盖print("数据写入excel文件完毕！")print("在售书数量合计："+str(h))]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Data Analysis</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 爬虫入门]]></title>
    <url>%2F2018%2F12%2F12%2FPython-data-analysis%2F</url>
    <content type="text"><![CDATA[一. Python初识一些简单概念 Python中没有数组的概念 列表[] 123可以存储元素: abc=[“My”, “You”]如果要选取列表中的元素 abc[1] 输出 ‘You’要替换列表中的元素: abc[1]=”He” 元祖() 12Cde=(“My”, “You”)选取元素同样用 cde[1] 列表和元组的区别 列表中的元素是可以修改的 但是元组这种数据类型呢 是不能修改的 集合 123parame = &#123;value01,value02,...&#125;或者set(value) 字典 1d = &#123;key1 : value1, key2 : value2 &#125; 简单代码展示函数的使用： 123456789101112def abc(): print("abcd!")def function1(a,b): if(a&gt;b): print(a) else: print(b)function1(10,19)abc() 模块： 12345import data_05functiondefinitiondata=data_05functiondefinition.function1(19,10)print(data) 文件写入： 12345fh = open("/Users/biandudu/Desktop/PythonDataAnalysis/file1.txt","w")contents1 = "我是文件内容"fh.write(contents1)fh.close() 文件读取： 1234567891011fh1 = open("/Users/biandudu/Desktop/PythonDataAnalysis/file2.txt","r")# data2 = fh1.read()# print(data2)while True: line = fh1.readline() if len(line)==0: break print(line)fh1.close() 异常抛出： 1234567# 中间异常不处理，会导致程序的崩溃try: print("my") printasa("sss")except Exception as err: print(err) print("hello") 作业作业一：输出乘法口诀12345for i in range(1,10): for j in range(1,i+1): print(str(i)+"*"+str(j)+"="+str(i*j)+" ",end="") # end=""意思是末尾不换行，加空格 print() 作业二：将多个Excel表格内容合并思路可以采用一些操作Excel的模块来实现，比如xlrd、xlwt、openyxl、xlsxwriter等模块。xlrd模块主要用于读取Excel表，xlwt与xlsxwriter模块主要用于将数据写入表中，两个模块任选其一即可，但是xlwt与xlsxwriter模块不支持修改表，所以在信息追加的时候会较麻烦，其实这个问题至少有两种思路解决： A、换成其他模块，比如openpyxl等，这个模块实现起来会相对简单一些 B、仍然使用xlwt与xlsxwriter等模块，但是先将每次读取的信息存储到list（列表）中，然后，最后一次写入。这一种方式稍微复杂一些 此外，还有一个难点，即一个表格中有多个sheet，我们希望能够用程序自动获取这多个sheet，然后将各sheet中的内容一并写入到最终表格中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import xlrd,xlsxwriter #设置要合并的所有文件allxls=["F:/第一个测试文件.xls","F:/第二个测试文件.xls","F:/第三个测试文件.xls"]#设置合并到的文件endxls ="F:/endxls.xls"#打开表格def open_xls(file): try: fh=xlrd.open_workbook(file) return fh except Exception as e: print(str("打开出错，错误为："+e))#获取所有sheetdef getsheet(fh): return fh.sheets()#读取某个sheet的行数def getnrows(fh,sheet): table=fh.sheets()[sheet] content=table.nrows return content#读取某个文件的内容并返回所有行的值def getfilect(fh,fl,shnum): fh=open_xls(fl) table=fh.sheet_by_name(shname[shnum]) num=getnrows(fh,shnum) lenrvalue=len(rvalue) for row in range(0,num): rdata=table.row_values(row) rvalue.append(rdata) #print(rvalue[lenrvalue:]) filevalue.append(rvalue[lenrvalue:]) return filevalue#存储所有读取的结果filevalue=[]#存储一个标签的结果svalue=[]#存储一行结果rvalue=[]#存储各sheet名shname=[]#读取第一个待读文件，获得sheet数fh=open_xls(allxls[0])sh=getsheet(fh)x=0for sheet in sh: shname.append(sheet.name) svalue.append([]) x+=1#依次读取各sheet的内容#依次读取各文件当前sheet的内容for shnum in range(0,x): for fl in allxls: print("正在读取文件："+str(fl)+"的第"+str(shnum)+"个标签的…") filevalue=getfilect(fh,fl,shnum) svalue[shnum].append(filevalue) #print(svalue[0]) #print(svalue[1])#由于append具有叠加关系，分析可得所有信息均在svalue[0][0]中存储#svalue[0][0]元素数量为sheet标签数(sn)*文件数(fn)sn=xfn=len(allxls)endvalue=[]#设置一个函数专门获取svalue里面的数据，即获取各项标签的数据def getsvalue(k): for z in range(k,k+fn): endvalue.append(svalue[0][0][z]) return endvalue#打开最终写入的文件wb1=xlsxwriter.Workbook(endxls)#创建一个sheet工作对象ws=wb1.add_worksheet()polit=0linenum=0#依次遍历每个sheet中的数据for s in range(0,sn*fn,fn): thisvalue=getsvalue(s) tvalue=thisvalue[polit:] #将一个标签的内容写入新文件中 for a in range(0,len(tvalue)): for b in range(0,len(tvalue[a])): for c in range(0,len(tvalue[a][b])): #print(linenum) #print(c) data=tvalue[a][b][c] ws.write(linenum,c,data) linenum+=1 #叠加关系，需要设置分割点 polit=len(thisvalue)wb1.close() 二. 爬虫初识 简单来说，网络爬虫就是自动从互联网中定向或不定向地采集信息的一种程序。网络爬虫有很多种类型，常用的有通用网络爬虫（搜索引擎）、聚焦网络爬虫（定向采集「信息过滤提取规则」）等。 通用网络爬虫可以应用在搜索引擎中，聚焦网络爬虫可以从互联网中自动采集信息并代替我们筛选出相关的数据出来 搜索引擎 采集金融数据 采集商品数据 自动过滤广告 采集竞争对手的客户数据 采集行业相关数据，进行数据分析 ……. 爬虫运行原理通用爬虫 聚焦网络爬虫 对爬取目标的定义和描述。在聚焦网络爬虫中，我们首先要依据爬取需求定义好该聚焦网络爬虫爬取的目标，以及进行相关的描述 获取初始的URL 根据初始的URL爬取网页，并获得新的URL 从新的URL中 过滤 掉与爬取目标无关的链接。因为聚焦网络爬虫对网页的抓取是有目的性，所以与目标无关的网页将会被过滤掉。同时，也需要将已爬取的URL地址存放到一个列表中，用于去重和判断爬取的进程 将 过滤后的链接放到URL队列 中 从URL队列中，根据 搜索算法 ，确当URL的 优先级 ，并确定下一步要抓取的URL地址。在通用网络爬虫中，下一步爬取那些URL，是不太重要的，但是在聚焦网络爬虫中，由于其具有目的性，故而下一步爬取哪些URL地址相对来说是比较重要的。对于聚焦网络爬虫来说，不同的爬取顺序，可能导致爬虫的执行效率不同，所以，我们需要依据搜索策略来确定下一步需要爬取那些URL地址 从下一步要爬取的URL地址中，读取新的URL，然后依据新的URL地址爬取网页，并重复上述爬取的过程 满足系统中设置的停止条件时，或无法获取新的URL地址时，停止爬行 正则表达式什么是正则表达式 提取出关键的数据，可以通过一些表达式进行提取，正则表达式就是其中一种进行数据筛选的表达式。 原子 原子是正则表达式中最基本的组成单位，每个正则表达式中至少要包含一个原子。常见的原子类型有: 普通字符 非打印字符 通用字符 原子表 普通字符和非打印字符123456789101112131415161718import repat="yue"pat2="\n" # 非打印字符string="http://yum.iqianyue.com"string2="abcd"string3='''absbddfsdfsfdfsfdfsf''' # 三引号可以加入换行的句子rst1=re.search(pat,string)rst2=re.search(pat,string2)rst3=re.search(pat2,string3)print(rst1)print(rst2)print(rst3) 通用字符和原子表\w——匹配任意字母数字下划线 \d ——匹配任意十进制数 \s ——匹配空白字符 \W ——和\w互补的关系，匹配任意除了字母数字下划线的字符 \D ——和\d互补 \S ——和\s互补 1234567891011121314import repat3 = "\w\dpython\w"pat4 = "pytho[ajs]n" # ajs任意其一都可以匹配 [原子表]string = "hohoiha3python3oioih"string2 = "sfsdkfpythoandsfd"rst3 = re.search(pat3,string)rst4 = re.search(pat4,string2)print(rst3)print(rst4) 元字符 所谓的元字符，就是正则表达式中具有一些特殊含义的字符，比如重复N次前面的字符等。 全部元字符：菜鸟教程——元字符 12345678910111213import repat = ".python..."pat2 = "python|php"string = "sfafapythonfaf"string2 = "shshdsphpskfdsfpythonsfsdf"rst = re.search(pat,string)rst2 = re.search(pat2,string2)print(rst)print(rst2) 模式修正符 所谓的模式修正符，即可以在不改变正则表达式的情况下，通过模式修正符改变正则表达式的含义，从而实现一些匹配结果的调整等功能。 模式修正符 说明 i 表示在和模式进行匹配进不区分大小写 m 将模式视为多行，使用^和$表示任何一行都可以以正则表达式开始或结束 s 如果没有使用这个模式修正符号，元字符中的”.”默认不能表示换行符号,将字符串视为单行 x 表示模式中的空白忽略不计 e 正则表达式必须使用在preg_replace替换字符串的函数中时才可以使用(讲这个函数时再说) A 以模式字符串开头，相当于元字符^ Z 以模式字符串结尾，相当于元字符$ U 正则表达式的特点：就是比较“贪婪”，使用该模式修正符可以取消贪婪模式 123456789import repat = ".python..."string = "sfafaPythonfaf"rst = re.search(pat,string,re.I) # 模式修正；不区分大小写print(rst) 贪婪模式与懒惰模式 贪婪模式的核心点就是尽可能多的匹配，而懒惰模式的核心点就是尽可能少的匹配。 123456789101112import repat = "p.*y" # 贪婪模式pat2 = "p.*?y"string = "sfafapythonfafsfsfsfpythonsdfsfpython"rst = re.search(pat,string)rst2 = re.search(pat2,string)print(rst)print(rst2) 正则表达式函数 正则表达式函数有re.match()函数、re.search()函数、全局匹配函数、re.sub()函数 re.match() 如果开头不是就直接返回None re.search 可以出现在字符串的任意位置 re.sub() re.compile 可以搜索匹配全部满足条件的 1rst = re.compile(pat1).findall(string) 常见正则实例123456789import repat = "[a-zA-Z]+://[^\s]*[.com|.cn]"string = '&lt;a herf="http://www.baidu,com&gt;hshfhksdf&lt;/a&gt;'rst = re.compile(pat).findall(string)print(rst) 简单的爬虫提取CSDN的QQ群1234567891011121314import urllib.requestimport reimport sslpat = "学员群(.*?)&lt;/span&gt;"ssl._create_default_https_context = ssl._create_unverified_contextdata = urllib.request.urlopen("https://edu.csdn.net/course/detail/4358").read()result = re.compile(pat).findall(str(data))print(result)]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Data Analysis</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Heart of a Lio]]></title>
    <url>%2F2018%2F10%2F17%2FLioMessi%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/Videos/Gatorade%20-%20Heart%20of%20a%20Lio.mp4","pic":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/2019-08-28%2F1566963521.png"},"danmaku":{"id":"LioMessi","api":"https://dplayer.moerats.com/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>Share</tag>
        <tag>Inspirational</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM02-Java内存区域与内存溢出异常]]></title>
    <url>%2F2018%2F10%2F05%2FJVMpro02%2F</url>
    <content type="text"><![CDATA[概述对C、C++开发人员来说，在内存管理领域，他们有着最高的权力，但同时肩负着每一个对象从开始到终结的维护责任。而对于Java程序员而言，由于JVM的自动内存管理机制，Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将为成为一项十分艰难的工作。 运行时数据区域Java 虚拟机在执行 Java 程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java 虚拟机规范将 JVM 所管理的内存分为以下几个运行时数据区：程序计数器、Java 虚拟机栈、本地方法栈、Java 堆、方法区。下面详细阐述各数据区所存储的数据类型。 程序计数器(Program Counter Register) 作用：记录当前线程所执行到字节码的行号。字节码解释器工作的时就是通过改变这个计数器的值来选取下一条所需要执行的字节码指令。 意义：由于JVM的多线程是通过线程轮换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令。所以为了实现并行，并保证各个线程指令安全顺利执行，每条线程都需要有一个独立的程序计数器。 记录内容： 如果线程正在执行一个Java方法，计数器记录的是正在执行的虚拟字节码指令的地址。 如果正在执行Native方法，计数器值为空(Undefined)。 可能出现的异常：此内存区域是唯一一个在Java虚拟机规范中没有任何内存溢出异常(OutOfMemoryError)的区域。 Java虚拟机栈(Java Virtual Machine Stacks) Java内存区常被分为堆内存（Heap）和栈内存（Stack），其中栈内存其实指的就是虚拟机栈，或者说是虚拟机栈中的局部变量表部分 作用：虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个线帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 特点： Java虚拟机栈也是线程私有的，它的生命周期与线程相同。 每一个方法从调用直至执行完成的过程就对应着一个线帧在虚拟机栈中从入栈到出栈的过程。 存储内容： 局部变量表，包括编译期可知的各种基本数据类型、对象引用(reference类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或次对象相关位置)、指向一条字节码指令的returnAddress类型 值得注意的是：局部变量表所需的内存空间在编译期间完成分配。在方法运行的阶段是不会改变局部变量表的大小的 可能出现的异常： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 如果在动态扩展内存的时候无法申请到足够的内存，就会抛出OutOfMemoryError异常。 本地方法栈(Native Method Stack) 特点：与虚拟机栈类似，区别在于虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法则为虚拟机所使用的Native方法服务 可能抛出的异常：与虚拟机栈一样，本地方法栈区域也乎抛出StackOverflowError和OutOfMemoryError异常。 Java堆(Java Heap) Java堆是垃圾收集器管理的主要区域（GC堆），可细分为：新生代，老年代，按空间可细分为：Eden空间，From Survivor空间，To Survivor空间 作用： Java Heap是被所有线程共享的一块区域，在虚拟机启动时创建。 此内存区域的唯一目的就是存放对象实例，让对象实例更好地分配内存。 垃圾回收机制(GC)：堆是垃圾收集器管理的主要区域，可以更好地回收内存。 存储内容： 存放对象实例，几乎所有的对象实例都在这里进行分配。堆可以处于物理上不连续的内存空间，只要逻辑上是连续的就可以。 值得注意的是：在JIT编译器等技术的发展下，所有对象都在堆上进行分配已变得不那么绝对。有些对象实例也可以分配在栈中。 可能出现的异常： 实现堆可以是固定大小的，也可以通过设置配置文件设置该为可扩展的。 如果堆上没有内存进行分配，并无法进行扩展时，将会抛出OutOfMemoryError异常。 方法区(Method Area) 作用：方法区和Java堆一样，是各个线程共享的内存区域。 意义：对运行时常量池、常量、静态变量等数据做出了规定。 存储内容：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 可能出现的异常：当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池(Runtime Constant Pool) 作用用于存放编译期生成的各种字面量和符号的引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 特征运行时常量池对于Class文件常量池的另一个特征是具备动态性，在运行期间也可能将新的常量放入池中，例如String类的intern() 可能抛出的异常运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 直接内存(Direct Memory) 作用JDK1.4中新加入NIO类，引入一种基于通道与缓冲的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffeer对象作为这块内存的引用进行操作。（在一些场景中显著提高性能，因为避免了Java堆和Native堆中来回复制数据） 可能抛出的异常服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常会忽略直接内存，使得内存区域总和大于物理内存限制(包括物理等和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。 HotSpot虚拟机对象对象创建 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。 内存分配的两种方式： 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定 指针碰撞Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离 空闲列表Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值 对象的内存布局 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding） HotSpot虚拟机的对象头包括两部分信息： Mark Word第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit。 类型指针对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。 对象的访问定位 建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。 目前主流的访问方式有使用句柄和直接指针两种： 句柄访问 直接指针访问 对比优势： 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。Sun HotSpot虚拟机是使用第二种方式进行对象虚拟机访问的。 OutOfMemoryError异常 除了程序计数器，其他运行时区域都有可能抛出OutOfMemoryError异常 Java堆溢出 内存泄露查看泄露对象到GC Roots的引用链，定位泄露代码位置。 内存溢出如果不存在泄露，即内存中的对象确实都还必须活着，检查JVM堆参数（-Xmx与-Xms），调大参数，检查代码是否存在某些对象生命周期过长，持有状态过长的情况，减少程序运行期的内存消耗。 虚拟机栈、本地方法栈溢出HotSpot不区分虚拟机栈和本地方法栈，栈容量只能由-Xss参数设定。 StackOverFlow：线程申请的栈深度超过允许的最大深度 OutOfMemoryError： 虚拟机扩展时无法申请到足够的内存空间 StackOverFlow的情况：递归调用方法，定义大量的本地变量，增大此方法帧中本地变量表的长度。 OutOfMemoryError：多线程下的内存溢出，与栈空间是否足够大并不存在任何联系。为每个线程的栈分配的内存越大（参数-Xss），那么可以建立的线程数量就越少，建立线程时就越容易把剩下的内存耗尽，越容易内存溢出。在这种情况下，如果不能减少线程数目或者更换64位虚拟机时，减少最大堆和减少栈容量能够换区更多的线程。 方法区和运行时常量池溢出 运行时常量池String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的引用。JDK7的intern()方法的实现有所不同，当常量池中没有该字符串时，不再是在常量池中创建与此String内容相同的字符串，而改为在常量池中记录堆中首次出现的该字符串的引用，并返回该引用 方法区方法区用于存放Class的相关信息，如果运行时产生大量的类去填满方法区，就可能发生方法区的内存溢出。 例如主流框架Spring、Hibernate对大量的类进行增强时，利用CGLib字节码生成动态类；大量JSP或动态JSP(JSP第一次运行时需要编译为Java类）。 本机直接内存溢出Java虚拟机可以通过参数-XX:MaxDirectMemorySize设定本机直接内存可用大小，如果不指定，则默认与java堆内存大小相同。JDK中可以通过反射获取Unsafe类(Unsafe的getUnsafe()方法只有启动类加载器Bootstrap才能返回实例)直接操作本机直接内存。通过使用-XX:MaxDirectMemorySize=10M，限制最大可使用的本机直接内存大小为10MB。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Reading</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM01-走近Java]]></title>
    <url>%2F2018%2F10%2F04%2FJVMpro01%2F</url>
    <content type="text"><![CDATA[第一章的内容大致翻阅了一下感觉还是挺多的，大致都是关于Java的特点、发展史、Java未来的走向以及阅读OpenJDK源码的指导。对于第一章的内容我也准备做一些总结，以备以后的扩充和温故。 Java的特性和优点 提升了开发效率 结构严谨，面向对象 摆脱硬件束缚，“一次编写，到处运行” 相对安全的内存管理和访问机制，避免了绝大部分的内存泄漏和指针越界问题(内存回收机制) 热点代码检测和运行时编译及优化，运行次数越多性能越好 完善的应用程序接口(第三方类库) Java的技术体系Sun公司所定义的Java技术体系包括以下几个组成部分： Jav程序设计语言 各种硬件平台上的Java虚拟机 Class文件格式（面向对象的载体） Java API库（Java自带可调用的库） 来自商业机构和开源社区的第三方Java类库（封装好的库） JDK(Java Development Kit)：1+2+4，也就是支持Java开发的最小环境。JRE(Java Runtime Environment)：JavaSE(Java Standard Edition)的API+虚拟机。 Java技术体系模块图： 按照技术服务领域划分，Java技术体系可以分为4个平台： JavaCard：支持一些Java小程序运行在小内存设备上的平台，如智能卡 JavaME(Micro Edition)：支持Java运行在移动终端上的平台，对JavaAPI有所精简，并加入了针对移动端的支持 JavaSE(Standard Edition)：支持面向桌面级应用(如Windows下的应用程序)的Java平台，提供了完整的Java核心API。 JavaEE(Enterprise Edition)：支持使用多层架构的企业应用(如ERP、CRM应用)的Java平台，对JavaSE API做了大量的扩充并提供相关的部署支持 入门版(Card)👉阉割版(ME)👉标配(SE)👉Pro(EE) Java发展史 1991年，提出绿色项目（猜想可能是针对c/c++中的垃圾回收，内存处理之类的问题而提出的一个更友好的语言概念）; 创立oak（java语言的前身，为了解决家用电器的通信问题而诞生，没有理想市场，不久后将要失败）;设计出硬件原型；同时设计出注释器。 1992年，更名为java; Star-Seven Prototype(七星原型，度娘上查了好久没找到，有机会去翻墙再查吧。 猜想可能是当时那个版本的七大基本规范吧。。。先记下来); 1993年，TV Set-top Box ( 可能是在电视机顶盒 试用吧)；发布应用开发平台。。 1994年，LiveOak（可能是oak发展有一些起色的意思吧。英语不好真的很忧伤。）;发布Era浏览器；继而发布HotJava浏览器；设计出java编译器； 1995年，正式注册java,并相继获得Netscape,Oracle,Microsoft的支持，HotJava进一步发展。 1996年，java1.0发布。 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术 1997年，java1.1发布。 1997年9月，JavaDeveloperConnection社区成员超过十万 。 1998年2月，JDK1.1被下载超过2,000,000次 1998年，java1.2发布。 1998年12月8日，JAVA2企业平台J2EE发布。 1999年6月，SUN公司发布Java的三个版本：标准版、企业版和微型版（J2SE、J2EE、J2ME） 2000年，java1.3发布。 2002年，java1.4发布，自此Java的计算能力有了大幅提升。 2004年，java5.0发布，J2SE1.5发布，是Java语言的发展史上的又一里程碑事件。为了表示这个版本的重要性，J2SE1.5更名为J2SE5.0 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字“2”：J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。 2006年，java6.0发布，并半开源。 2010年，Oracle收购Sun公司，苹果不再支持java 2011年，java7.0发布。 2014年，java8.0发布。 Java虚拟机发展史 Sun Classic/Exact VM(初代)：世界上第一款商用Java虚拟机，Sun公司研发，主要特点：慢。 Sun HotSpot VM(新技术)：目前使用范围最广的虚拟机，是Sun从一家名为Longview Technologies公司收购来的。主要特点：热点探测技术。 Sun Mobile-Embedded VM/Meta-Circular VM(探索)：面对移动嵌入式市场的探索 BEA JRockit /IBM J9 VM(其它公司)：当时号称”世界上最快的Java虚拟机” Azul VM/BEA Liquid VM(特定硬件)：高性能Java的武器，特定硬件可以最大限度地发挥硬件的能力，提升Java程序的执行能力。 Apache Harmony/Google Android Dalvik VM(高速发展)：安卓虚拟机。是Android平台的核心组成部分之一。 Microsoft JVM(彩蛋)：2333 Java的未来 模块化：说起来也就是解除功能模块和功能模块之间的耦合，降低系统维护消耗。(书上也没仔细说，大家看着标题脑补一下也就知道是干嘛的) 混合语言：对系统来说是好事(因为不同语言有不同语言的特点 也就是擅长的地方)，但是对于Java程序员的要求也会因此而提高。 多核并行：顺应发展 丰富语法：更新JDK版本 64位虚拟机：现在64位虚拟机速度没有32位快，主要是Java EE对64位虚拟机的要求比较急迫。 自己编译JDK想要一探JDK内部的实现机制，最便捷的路径之一就是自己编译一套JDK，通过阅读和跟踪调试JDK源码去了解Java技术体系的原理，虽然门槛会高一点，但肯定会比阅读各种书籍、文章更加贴近本质。另外，JDK中很多底层方法都是本地化的，需要跟踪这些方法的运作或对JDK进行Hack的时候，都需要自己编译一套JDK。 OpenJDK源码结构图： 123456789101112131415161718192021222324252627282930313233343536373839├─agent Serviceability Agent的客户端实现 ├─make 用来build出HotSpot的各种配置文件 ├─src HotSpot VM的源代码 │ ├─cpu CPU相关代码（汇编器、模板解释器、ad文件、部分runtime函数在这里实现） │ ├─os 操作系相关代码 │ ├─os_cpu 操作系统+CPU的组合相关的代码 │ └─share 平台无关的共通代码 │ ├─tools 工具 │ │ ├─hsdis 反汇编插件 │ │ ├─IdealGraphVisualizer 将server编译器的中间代码可视化的工具 │ │ ├─launcher 启动程序“Java” │ │ ├─LogCompilation 将-XX:+LogCompilation输出的日志（hotspot.log）整理成更容易阅读的格式的工具 │ │ └─ProjectCreator 生成Visual Studio的project文件的工具 │ └─vm HotSpot VM的核心代码 │ ├─adlc 平台描述文件（上面的cpu或os_cpu里的*.ad文件）的编译器 │ ├─asm 汇编器接口 │ ├─c1 client编译器（又称“C1”） │ ├─ci 动态编译器的公共服务/从动态编译器到VM的接口 │ ├─classfile 类文件的处理（包括类加载和系统符号表等） │ ├─code 动态生成的代码的管理 │ ├─compiler 从VM调用动态编译器的接口 │ ├─gc_implementation GC的实现 │ │ ├─concurrentMarkSweep Concurrent Mark Sweep GC的实现 │ │ ├─g1 Garbage-First GC的实现（不使用老的分代式GC框架） │ │ ├─parallelScavenge ParallelScavenge GC的实现（server VM默认，不使用老的分代式GC框架） │ │ ├─parNew ParNew GC的实现 │ │ └─shared GC的共通实现 │ ├─gc_interface GC的接口 │ ├─interpreter 解释器，包括“模板解释器”（官方版在用）和“C++解释器”（官方版不在用） │ ├─libadt 一些抽象数据结构 │ ├─memory 内存管理相关（老的分代式GC框架也在这里） │ ├─oops HotSpot VM的对象系统的实现 │ ├─opto server编译器（又称“C2”或“Opto”） │ ├─prims HotSpot VM的对外接口，包括部分标准库的native部分和JVMTI实现 │ ├─runtime 运行时支持库（包括线程管理、编译器调度、锁、反射等） │ ├─services 主要是用来支持JMX之类的管理功能的接口 │ ├─shark 基于LLVM的JIT编译器（官方版里没有使用） │ └─utilities 一些基本的工具类 └─test 单元测试]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Reading</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何编写Alfred Workflow]]></title>
    <url>%2F2018%2F09%2F21%2FAlfredKnowledgeBase%2F</url>
    <content type="text"><![CDATA[语言基础Alfred官方并没有给出详细的Alfred Workflow撰写教程，原因是写一个Workflow的实际门槛是很低的。他们大部分是使用一门了解的语言来书写的。在Alfred也罗列了这些语言： 包括： bash, zsh, PHP, Ruby, Python, Perl, AppleScript, JavaScript 开发者只需要会使用上面任意的语言，就可以开始编写自己的Alfred Workflow了。 如何使用Alfred？Alfred有个很好的地方，就是能在Alfred中看到你所使用的Alfred的具体实现，workflow也都是开源的。大部分workflow都可以直接在Alfred的workflows选项卡下看到，部分workflow可能需要调用一些脚本文件，你也可以进入对应的workflow文件夹下打开具体的脚本文件（可以通过workflows👉Show in Finder打开对应的workflow文件夹） Alfred workflow有几个关键组成部分，包括Triggers、Inputs、Actions、Outputs。 Triggers用于设置快捷键，并不是必备的，因为Option+Space快捷键就可以快捷打开Alfred输入框 Inputs定义了在Alfred输入框中输入对应的keyword调用相关的操作 Action就是keyword调用的操作 Outputs一般用于显示操作的结果，提示操作成功与否，以Post Notification较为常见，通过Mac的notification center提示。 🤨Alfred使用手册🤨👉Alfred2.5.1使用全攻略👉Alfred：基础功能及设置👉编写 Alfred 使用的 Workflow]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Alfred</tag>
        <tag>Workflow</tag>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alfred的OSS图床Workflow(python)]]></title>
    <url>%2F2018%2F09%2F20%2FAlfredWorkflowOSS%2F</url>
    <content type="text"><![CDATA[前言什么是Alfred？Alfred依靠它强大的工作流机制，可以极大地提高Mac系统的工作效率。 作为 Mac 上最强大的效率工具，Alfred 在 Spotlight（MacOS X 自带的搜索和快速启动引擎）的基础上优化了快速启动与搜索的功能，还引入了 Workflows 等强大的扩展功能，使之成为了一个拥有无限自动化潜力的「工具平台」软件，可以用它来实现近乎一切有关自动的想法。 为什么要使用这个Workflow？因为在编写个人博客，每次插入图片的时候都需要将图片上传到OSS图床，具体需要以下步骤： 截图 保存图片到桌面 打开浏览器 登陆阿里云 打开OSS控制台 上传图片 等待并获取url 回到markdown编辑器粘贴到![]()中 而现在使用这款插件只需要三步： 截图 Toggle Alfred 并键入：OSS 回到markdown编辑器粘贴 好吧，其实主要还是因为穷QAQ，因为不需要折腾的iPic需要订阅，每年¥68。 安装及配置环境 一台MacOS的电脑 Alfred 阿里云OSS python3环境 python3依赖oss2和pyobjc包 👉python3安装教程 安装依赖打开命令行输入：1pip install oss2 1pip install pyobjc 脚本需要修改的参数修改位置：右键OSS - 选择Open in Finder - 修改其中的clipboard_data.py文件 修改下面这三行的内容： 123access_key_id = &apos;&lt;yourAccessKeyId&gt;&apos;access_key_secret = &apos;&lt;yourAccessKeySecret&gt;&apos;bucket_name = &apos;&lt;yourBucketName&gt;&apos; 1bucket = oss2.Bucket(auth, &apos;http://oss-cn-hangzhou.aliyuncs.com&apos;, bucket_name) 👉如何获取AccessKey ID和Secret 如何使用复制一张图片，调用alfred，输入oss命令稍等一小会儿，会显示url和md两种返回格式，点击url或者md便可以获得对应地址在剪切板中，粘贴，所见即所得 👉GIthub地址 最后，感谢 @CQhui 写的AlfredWorkflow！]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Alfred</tag>
        <tag>tech</tag>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识遗传算法]]></title>
    <url>%2F2018%2F09%2F18%2FGeneticAlgorithm01%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/Videos/AI%20learns%20to%20play%20Google%20Chrome%20Dinosaur%20Game%20--%20Can%20you%20beat%20it.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() Github源码链接 什么是遗传算法？遗传算法的由来 Species to survive, is not the most strong, is not the most intelligent， but those who make a rapid response to change. 物尽天择，适者生存。 查尔斯达尔文在一百多年前提出的“生物进化论”，他证明生物的起源是在遗传、变异、生存斗争和自然选择中，从简单到复杂、从低等到高等不断地发展变化而来的。达尔文的进化论给美国的科学家霍兰德留下了深刻的印象，他从计算机角度思考了这个问题，也就是遗传算法的由来。遗传算法也便继承了“进化论”的思想，将需要解决的问题模拟成一个生物进化的过程，通过复制、交叉、突变等操作产生下一代的解，并逐步淘汰适应度(Fitness)低的解，经过N代自然选择后，会进化出适应度函数值很高的个体。 定义：&emsp;&emsp;遗传算法（Genetic Algorithm, GA）起源于对生物系统所进行的计算机模拟研究。它是模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种高效、并行、全局搜索的方法，能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最佳解。 相关术语 table th:nth-of-type(1){ width: 25%; } table th:nth-of-type(2){ width: 75%; } 相关术语 解释 基因型(genotype) 性状染色体的内部表现 表现型(phenotype) 染色体决定的性状的外部表现，或者说，根据基因型形成的个体的外部表现 进化(evolution) 种群逐渐适应生存环境，品质不断得到改良。生物的进化是以种群的形式进行的 适应度(fitness) 度量某个物种对于生存环境的适应程度 选择(selection) 以一定的概率从种群中选择若干个个体。一般，选择过程是一种基于适应度的优胜劣汰的过程 复制(reproduction) 细胞分裂时，遗传物质DNA通过复制而转移到新产生的细胞中，新细胞就继承了旧细胞的基因。 交叉(crossover) 两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交 变异(mutation) 复制时可能（很小的概率）产生某些复制差错，变异产生新的染色体，表现出新的性状 编码(coding) DNA中遗传信息在一个长链上按一定的模式排列。遗传编码可看作从表现型到基因型的映射 解码(decoding) 基因型到表现型的映射 个体（individual） 指染色体带有特征的实体 种群（population） 个体的集合，该集合内个体数称为种群的大小 遗传算法的应用遗传算法的有趣应用很多，诸如寻路问题，8数码问题，囚犯困境，动作控制，找圆心问题（在一个不规则的多边形中，寻找一个包含在该多边形内的最大圆圈的圆心），TSP问题，生产调度，模式识别，神经网络，自适应控制等。 一个简单的例子求解函数 f(x) = x + 10*sin(5*x) + 7*cos(4*x) 在区间[0,9]的最大值 那么如何通过遗传算法找到这个函数的最大值呢？ 事实上，不管一个函数的形状多么奇怪，遗传算法都能在很短的时间内找到它在一个区间内的(近似)最大值。 👉具体分析 遗传算法思想GA的组成： 编码(产生初始种群)👉创造染色体 个体👉种群 适应度函数 遗传算子(选择、交叉、变异) 运行参数 种群大小 染色体长度 最大迭代次数 交叉概率 变异概率 是否选择精英操作 GA算法特点遗传算法的优点 群体搜索，易于并行化处理； 不是盲目穷举，而是启发式搜索； 适应度函数不受连续、可微等条件的约束，适用范围很广。 容易实现。一旦有了一个遗传算法的程序，如果想解决一个新的问题，只需针对新的问题重新进行基因编码就行；如果编码方法也相同，那只需要改变一下适应度函数就可以了。 遗传算法的缺点 全局搜索能力不强,很容易陷入局部最优解跳不出来；(可结合SA进行改进,因为SA在理率上是100%得到全局最优的,但搜索代价高) 将遗传算法用于解决各种实际问题后，人们发现遣传算法也会由于各种原因过早向目标函数的局部最优解收敛，从而很难找到全局最优解。其中有些是由于目标函数的特性造成的，例如函数具有欺骗性，不满足构造模块假说等等；另外一些则是由于算法设计不当。为此，不断有人对遗传算法提出各种各样的改进方案。例如：针对原先的定长二进制编码方案；提出了动态编码、实数编码等改进方案；针对按比例的选择机制，提出了竞争选择、按续挑选等改进方案；针对原先的一点交算子，提出了两点交、多点交、均匀交等算子；针对原先遗传算法各控制参数在进化过程中不变的情况，提出了退化遗传算法、自适应遗传算法等。另外，针对不同问题还出现了分布式遗传算法、并行遗传算法等等。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云产品]]></title>
    <url>%2F2018%2F09%2F16%2FAbout-AliCloud%2F</url>
    <content type="text"><![CDATA[产品及功能ESC(Elastic Compute Service)以虚拟机的方式将一台物理机分成多台云服务器，提供可伸缩的计算服务。 衍生产品： 阿里云从云服务器ESC衍生出来很多云服务器系列，例如适用于初级用户的轻量应用服务器，还有 为了迎合各种高性能场景的云服务器，诸如GPU云服务器、FPGA云服务器等，总之都是云服务器，是企业上云的基本款。 关于轻量应用服务器： 精简了一些 ECS 的功能，比如说安骑士。把安全组的操作也做了适当减法更适合用户操作。 轻量应用服务器有轻量两个字，意味着其无法持续进行高负载运行（即 CPU 长时间高负载占用），如果我们要利用 轻量应用服务器 来进行持续的渲染、转码、机器学习等持续高负载操作那么就不可以了，也不支持 Nvme 这样的超高性能的 SSD，这对于读写敏感的操作就不好了。 阿里云的“云翼计划”的学生服务器就是轻量应用服务器。 RDS(Relational Database Service)通过云服务的方式让关系型数据库管理、操作和扩展变得更加简单。 OSS(Open Store Service)对任意大小数据对象提供高可用、高可靠的海量存储服务。 相关文章： 阿里云对象存储OSS SLB(Server Load Balance)基于LVS和Tengine实现的4层和7层负载均衡，有动态扩容。 OCS(Open Cache Service)基于内部Tair，增加一层Proxy，支持海量小数据的高速访问。 OTS(Open Table Service)海量(结构化)数据存储和实时查询服务 CDN(Content Delevery Network)通过覆盖全网的缓存服务以及负载均衡等技术将用户请求定向到最合适的区域，提高用户服务的响应速度及网站服务能力。 OAS(Open Archive Service)离线归档，冷数据备份，类似Amazon Glacier ODPS(Open Data Processing Service)海量数据处理和分析平台。 SLS(Simple Log Service)解决异构、分布式系统中日志实时收集、存储与查询的基础服务]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>About</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云对象存储OSS]]></title>
    <url>%2F2018%2F09%2F14%2FAliCloudOSS%2F</url>
    <content type="text"><![CDATA[OSS阿里云对象存储服务（Object Storage Service，简称 OSS），提供海量、安全、低成本、高可靠的云存储服务。其性质相当于阿里云提供的网盘服务，支持最基本的上传和下载，支持外链。OSS的存储空间以外网流出流量都是要收费的 CDN（CDN加速）全称：Content Delivery Network，内容分发网络是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络，替代传统以WEB Server为中心的数据传输模式。相当于访问就近的服务器点就个人博客而言，不需要CDN加速 存储量存储量指占用的存储空间容量 流量流量指您使用的网络带宽流量累计值，包括外网流出流量、内网流出流量、外网流入流量、内网流入流量、CDN回源流出流量、跨区域复制流量： 外网流出流量(收费): 通过互联网从 OSS 下载数据到本地端所产生的下行流量 内网流出流量(免费): 通过阿里云内网从 OSS 下载数据到 ECS 服务器所产生的下行流量 外网流入流量(免费) : 通过互联网从本地端上传数据到 OSS 所产生的上行流量 内网流入流量(免费) : 通过阿里云内网从 ECS 服务器上传数据到 OSS 所产生的上行流量 CDN回源流出流量(收费) : 通过 CDN 服务层下载 OSS 的数据所产生的回源下行流量 跨区域复制流量(收费) : 使用跨区域复制功能将源 Bucket 的数据同步复制到目标 Bucket 时所产生的流出流量 请求次数调用 OSS OPEN API 的请求次数。比如: 你的一篇博客中有6张图片(都是使用OSS存储做外链),那么当你打开这篇博客时就产生了6次请求。另外: OSS 控制台操作也是通过 OSS OPEN API 调用实现的，因此使用 OSS 控制台也会产生请求次数。 收费模式： 按量付费： 存储费用：存储单价 x 存储量 流量费用：外网流出流量忙时单价 x 流量 请求费用：Put请求 + Get请求汇总的费用 包年包月： 存储费用：存储包平均每月的费用 流量费用：外网流出流量包平均每月的费用 请求费用：Put请求 + Get请求汇总的费用 OSS+CDN组合： 存储费用：存储包平均每月的费用 流量费用：CDN公网流量费用 + CDN回源流量费用 请求费用：CDN回源请求费用 总结：个人博客建议按流量计费]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo进阶]]></title>
    <url>%2F2018%2F09%2F04%2FAdvancedOperationInHexo%2F</url>
    <content type="text"><![CDATA[目录结构12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 为什么在custom.styl修改CSS文件?👉Stylus让CSS也能编程 修改文章页宽打开\themes\next\source\css\ _variables\base.styl文件，找到以下字段并修改为合适的宽度: 1content-desktop-large = 1000px 修改小型代码块颜色修改\themes\next\source\css\ _variables\base.styl文件，修改代码加入自定义颜色： 123456789$black-deep = #222$red = #ff2a2a$blue-bright = #87daff$blue = #0684bd$blue-deep = #262a30$orange = #fc6423// 下面是我自定义的颜色$my-code-foreground = #dd0055 // 用``围出的代码块字体颜色$my-code-background = #eee // 用``围出的代码块背景颜色 修改$code-background和$code-foreground的值 123456// Code &amp; Code Blocks // 用``围出的代码块 // -------------------------------------------------- $code-font-family = $font-family-monospace $code-font-size = 15px $code-background = $my-code-background $code-foreground = $my-code-foreground $code-border-radius = 4px 添加文章结束标记同样在themes/next/layout/_macro/post.swig 中，在 wechat-subscriber.swig之前添加如下代码： 1&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------- The End ----------------&lt;/div&gt; 把侧边栏头像变成圆形，并且鼠标停留在上面发生旋转效果修改themes\next\source\css\_common\components\sidebar\sidebar-author.styl： 1234567891011121314151617181920212223242526272829.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: site-author-image-border-color; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 修改链接文字样式打开themes\next\source\css\_common\components\post\post.styl添加以下代码，给链接添加颜色： 12345678.post-body p a&#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #ff106c; text-decoration: underline; &#125;&#125; 为next主题的主页文章添加阴影效果打开themes/next/source/css/_custom/custom.styl文件添加： 1234567.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 为next主题添加nest背景特效背景几何线条是采用的nest效果，一个基于html5 canvas绘制的网页背景效果，非常赞！来自github的开源项目canvas-nest 特性 不依赖任何框架或者内库，比如不依赖 非常小，只有1.66kb 非常容易实现，配置简单，即使不是web的开发者，也能简单搞定 配置选项 color: 线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B)，注意用,分割 opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 不足：CPU占用过高 修改_layout.swig打开next/layout/_layout.swig在&lt;/body&gt;之前添加如下代码 可参考官方文档：Canvas-Nest 123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 修改主题配置文件打开/next/_config.yml，添加如下代码 1234567# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 运行hexo clean 和 hero g -d 之后就可以在网页上看到效果了。 隐藏网页底部powered by hexo/强力驱动打开hexo/themes/next/layout/_partials/footer.swig 找到下面这段代码，用第一行和最后一行注释掉即可 123456789101112131415&lt;!--&lt;div class="powered-by"&gt;&#123;# #&#125;&#123;&#123; __('footer.powered', '') &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class="theme-info"&gt; &#123;&#123; __('footer.theme') &#125;&#125; &lt;/div&gt;--&gt; 侧栏加入已运行时间themes/next/layout/_custom中添加sidebar.swig文件: 1234567891011121314151617181920212223242526&lt;div id="days"&gt;&lt;/div&gt; &lt;script&gt; function show_date_time()&#123; window.setTimeout("show_date_time()", 1000); BirthDay=new Date("01/10/2017 12:34:56"); today=new Date(); timeold=(today.getTime()-BirthDay.getTime()); sectimeold=timeold/1000 secondsold=Math.floor(sectimeold); msPerDay=24*60*60*1000 e_daysold=timeold/msPerDay daysold=Math.floor(e_daysold); e_hrsold=(e_daysold-daysold)*24; hrsold=setzero(Math.floor(e_hrsold)); e_minsold=(e_hrsold-hrsold)*60; minsold=setzero(Math.floor((e_hrsold-hrsold)*60)); seconds=setzero(Math.floor((e_minsold-minsold)*60)); document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"; &#125;function setzero(i)&#123; if (i&lt;10) &#123;i="0" + i&#125;; return i;&#125;show_date_time();&lt;/script&gt; 在themes/next/layout/_macro/sidebar.swig中的&lt;/section&gt;之前添加: 1&#123;% include &apos;../_custom/sidebar.swig&apos; %&#125; 设置时间样式： 1234567// 自定义的侧栏时间样式#days &#123; display: block; color: #fffa74; font-size: 14px; margin-top: 15px;&#125; 更改tagcloud为彩色themes/next/layout/page.swig找到tagcloud并替换: 1&#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: '#9733EE', end_color: '#FF512F'&#125;) &#125;&#125; 设置动态titlethemes/next/source/js/src下创建dytitle.js： 12345678910111213141516var OriginTitile = document.title;var titleTime;document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="shortcut icon"]').attr('href', "/TEP.png"); document.title = 'w(ﾟДﾟ)w 出BUG啦！！！！'; clearTimeout(titleTime); &#125; else &#123; $('[rel="shortcut icon"]').attr('href', "/favicon.png"); document.title = '♪(^∇^*)又好了。。。 ' + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125;&#125;); 修改themes/next/layout/layout.swing,在 &lt;/body&gt; 之前添加: 1&lt;script type="text/javascript" src="/js/src/dytitle.js"&gt;&lt;/script&gt; 修改文章底部带#的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 文字样式先在themes/next/source/css/_custom/custom.styl中添加以下样式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221// 下载样式a#download &#123;display: inline-block;padding: 0 10px;color: #000;background: transparent;border: 2px solid #000;border-radius: 2px;transition: all .5s ease;font-weight: bold;&amp;:hover &#123;background: #000;color: #fff;&#125;&#125;/ /颜色块-黄span#inline-yellow &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #f0ad4e;&#125;// 颜色块-绿span#inline-green &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #5cb85c;&#125;// 颜色块-蓝span#inline-blue &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #2780e3;&#125;// 颜色块-紫span#inline-purple &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #9954bb;&#125;// 左侧边框红色块级p#div-border-left-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#125;// 左侧边框黄色块级p#div-border-left-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #f0ad4e;&#125;// 左侧边框绿色块级p#div-border-left-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #5cb85c;&#125;// 左侧边框蓝色块级p#div-border-left-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #2780e3;&#125;// 左侧边框紫色块级p#div-border-left-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #9954bb;&#125;// 右侧边框红色块级p#div-border-right-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #df3e3e;&#125;// 右侧边框黄色块级p#div-border-right-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #f0ad4e;&#125;// 右侧边框绿色块级p#div-border-right-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #5cb85c;&#125;// 右侧边框蓝色块级p#div-border-right-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #2780e3;&#125;// 右侧边框紫色块级p#div-border-right-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #9954bb;&#125;// 上侧边框红色p#div-border-top-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #df3e3e;&#125;// 上侧边框黄色p#div-border-top-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #f0ad4e;&#125;// 上侧边框绿色p#div-border-top-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #5cb85c;&#125;// 上侧边框蓝色p#div-border-top-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#125;// 上侧边框紫色p#div-border-top-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #9954bb;&#125; 用法如下： 12&lt;span id=&quot;inline-blue&quot;&gt;站点配置文件&lt;/span&gt;， &lt;span id=&quot;inline-purple&quot;&gt;主题配置文件&lt;/span&gt; 站点配置文件，主题配置文件 12&lt;p id="div-border-left-red"&gt;左边红色&lt;/p&gt;&lt;p id="div-border-top-blue"&gt;上边蓝色&lt;/p&gt; 左边红色上边蓝色 在文档中增加图标采用的是Font Awesome的图标。 给文档加密打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在开头的四个meta之后插入以下代码：1234567891011121314&lt;script&gt; (function () &#123; if ('&#123;&#123; page.password &#125;&#125;') &#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;') &#123; alert('密码错误！'); if (history.length === 1) &#123; location.replace("http://xxxxxxx.xxx"); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 然后在MD文章头文件中加入 password: password 侧边栏推荐阅读打开主题配置文件修改成这样就行了（links里面写你想要推荐的链接）：1234567891011# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 优设: http://www.uisdc.com/ 张鑫旭: http://www.zhangxinxu.com/ Web前端导航: http://www.alloyteam.com/nav/ 前端书籍资料: http://www.36zhen.com/t?id=3448 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/ 新增评论系统去除评论系统下方的powered by valine打开/next/layout/_third-party/comments/valine.swig文件，123456789101112131415161718new Valine(&#123; el: '#comments' , verify: &#123;&#123; theme.valine.verify &#125;&#125;, notify: &#123;&#123; theme.valine.notify &#125;&#125;, appId: '&#123;&#123; theme.valine.appid &#125;&#125;', appKey: '&#123;&#123; theme.valine.appkey &#125;&#125;', placeholder: '&#123;&#123; theme.valine.placeholder &#125;&#125;', avatar:'&#123;&#123; theme.valine.avatar &#125;&#125;', guest_info:guest, pageSize:'&#123;&#123; theme.valine.pageSize &#125;&#125;' || 10,&#125;);//新增以下代码即可，可以移除.info下所有子节点。var infoEle = document.querySelector('#comments .info');if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0)&#123; infoEle.childNodes.forEach(function(item) &#123; item.parentNode.removeChild(item); &#125;);&#125;]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP三次握手和四次挥手]]></title>
    <url>%2F2018%2F08%2F07%2FTCPShakeandWave%2F</url>
    <content type="text"><![CDATA[TCP三次握手建立连接 第一次握手：客户端发送syn包(seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 通俗一点来讲，就是 主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。 为什么要三次握手？ 在谢希仁著《计算机网络》中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误” 在谢希仁著《计算机网络》书中同时举了一个例子，如下： “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 所以三次握手是为了防止服务器端一直等待而浪费资源。 TCP四次挥手 当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要四次挥手？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。 FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方） FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方） CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方） LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方） TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方） CLOSED: 表示连接中断。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Communication Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通信协议 —— TCP UDP HTTP]]></title>
    <url>%2F2018%2F08%2F07%2FTCP-UDP-HTTP%2F</url>
    <content type="text"><![CDATA[什么是Http、Socket、TCP/IP？HTTP ( HyperText Transfer Protocal ) ，即：超文本传输协议，从1990年开始就在WWW上广泛应用，是当今在WWW上应用最多的协议，Http是应用层协议，当浏览网页的时候，浏览爱和Web服务器之间就会通过HTTP在Internet上进行数据的发送和接收，Http是一个基于请求/响应模式的、无状态的协议。即我们通常所说的Request/Response。HTTP是利用TCP在两台电脑（通常是Web服务器和客户端）之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。 Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。Socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。 TCP/IP 模型在原有OSI模型的基础上进行了简化，由原先的八层（应用层、表示层、会话层、传输层、网络层、数据链路层、物理层）变成了四层（应用层、传输层、网际层IP、网络接口层） TCP HTTP UDP SOCKET四者的关系？ IP是网络层协议，相当于高速公路；TCP和UDP是传输层协议，相当于卡车；HTTP是应用层的协议，相当于货物；SOCKET是TCP/IP网络的API，相当于码头和车站 TCP/IP是一个协议组，可以分为四个层次：网络接口层、网络层、传输层、和应用层。 在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 在传输层中有TCP协议和UDP协议。 在应用层中有FTP、HTTP、TELNET、SMTP、DNS等协议。 HTTP是从Web服务器传输超文本到本地浏览器的传送协议。 TCP和UDP的区别TCP（Transmission Control Protocol）传输控制协议：类似打电话 面向连接、传输可靠、有序、传输大量数据、速度慢、对系统资源要求多、程序结构复杂 每一条TCP连接只能是点到点的 TCP首部开销20字节 UDP（User Data Protocol）用户数据报协议：类似发短信 面向非连接、传输不可靠、无序、传输少量数据、速度快、对系统资源要求少、程序结构简单 UDP支持一对一，一对多，多对一和多对多的交互通信 UDP首部开销小，只有8个字节]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Communication Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识汇总]]></title>
    <url>%2F2018%2F01%2F14%2FFirstInterviewForJava%2F</url>
    <content type="text"><![CDATA[定义部分Q1: 什么是面向对象编程思想？ 面向对象是相对于面向过程的。面向对象不用关心处理问题的细节，只需要关心结果。 面向对象有三大特性：封装、继承和多态。封装的目的是复用；继承目的是共用；多态目的是多种实现。 Q2: Servlet的概念及功能？ Servlet是JavaEE规范中的Web开发组件 Servlet运行在服务器端，需要Servlet容器的支持，例如Tomcat 可以通过浏览器访问Servlet，Servlet可以生成动态页面返回给浏览器 Servlet也是一段代码，是一个Java类，这个Java类需要遵守一定的编写规范 Q3: JSP(Java Server Pages)概念？ JSP是JavaEE规范中的Web组件，用来编写动态页面 JSP运行在服务器端，本质是Servlet JSP文件以.jsp为后缀，在Eclipse的工程目录中存在WebContent目录下 JSP文件可以直接在浏览器中访问 JSP文件中的内容就是 HTML+Java代码，静态部分使用HTML和文本即可，动态部分使用Java代码 Q4: Servlet与JSP的作用？ JSP往往用来生成动态页面，而Servlet虽然可以生成动态页面却过于麻烦，往往用来接收JSP的请求，处理请求，然后跳转到不同JSP页面进行结果显示； Servlet和JSP之间的跳转有两种方式，分别是响应重定向和请求转发； 响应重定向相当于客户端重新发出请求，之前的请求不再保存；请求转发是把当前请求转发到下一个资源；比较常用的是请求转发； 请求参数是用户提交请求时，自动封装到请求对象中的一些输入信息，都是String类型； 请求属性可以是任意类型的对象，可以用setAttribute方法将对象作为属性存储到请求对象中； Q5: JDBC的概念？ JDBC是指Java数据库连接，是一种标准Java应用编程接口，用来连接Java编程语言和广泛的数据库 JDBC的本质是一种规范，它提供了一套完整的借口，允许便捷式访问到底层数据库，因此Java编写不同类型的可执行文件都可以使用JDBC驱动程序来访问数据库。 Q6: SSM框架的基本概念 SSM框架，是Spring + SpringMVC + MyBatis的缩写，是目前主流的Java EE框架，适用于搭建各种大型企业级应用系统。 SSM框架将系统划分为表现层，controller层，service层，DAO层 Spring实现业务对象管理，Mybatis座位数据对象的持久化引擎，Spring MVC负责请求的转发和视图管理 Q7: Spring的功能： Spring 容器提供了IOC机制，可以创建对象以及管理对象之间的调用关系，避免了硬编码造成的程序耦合 提供了AOP（面向切面编程方式）功能，可以实现很多特定功能 声明式事务控制处理 对JDBC进行了轻量级的封装，可以更加灵活的去操作数据库 提供了MVC设计模式的解决方案 提供了文件上传、定时器等常用工具类 对于其他优秀框架的支持（如：Struts、Hibernate、MyBatis、Quartz等） Spring的IoC容器是Spring的核心，Spring AOP是Spring框架的重要组成部分。 Q8: IoC (Inversion of Control) 控制反转？ 在传统的程序设计中，当调用者需要被调用者的协助时，通常由调用者来创建被调用者的实例。但在spring里创建被调用者的工作不再由调用者来完成，因此控制反转（IoC）；创建被调用者实例的工作通常由spring容器来完成，然后注入调用者，因此也被称为依赖注入（DI），依赖注入和控制反转是同一个概念。 IoC是解耦,提供一种构造对象的方式，使得一种功能能有多种实现，且不构成依赖。spring 的IOC的缺点：占用内存多、构造对象慢、启动慢。 控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。所以IoC也叫依赖注入（Dependency Injection）。实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。 Q9: AOP和OOP的联系和区别？ OOP的封装要求将功能分散到不同的对象中去，在软件设计中称为指责分配。让不同的类实现不同的方法，这样代码就分散到一个个类中去了，降低了代码的复杂程度，使类可重用。面向对象设计让类与类之间无法联系，而不能将这些重复的代码统一起来。因此分散代码的同时，也增加了代码的重复性。也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。从技术上来说，AOP基本上是通过代理机制实现的。AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。 OOP (Object Oriented Programming) 侧重于静态，名词，状态，组织，数据，载体是空间 AOP (Aspect Oriented Programming) 侧重于动态，动词，行为，调用，算法，载体是时间 Q10: MVC (Model-View-Controller) 框架？ MVC是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 MVC虽然分为三部分，但是MVC跟经典三层没有任何关系，它只存在于Web层，将Web层的数据、业务处理和显示分隔开。 model是应用程序中用于处理数据逻辑的部分。通常模型对象负责在数据库中存取数据。 view是应用程序中处理数据显示的部分。通常视图是依据数据模型创建的。 controller是应用程序中处理数据交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送。 对于开发存在大量用户界面，并且业务逻辑复杂的大型应用程序，MVC将会使你的软件在健壮性、代码重用和结构方面上一个新的台阶。尽管在最初构建MVC框架时会花费一定的工作量，但从长远角度看，它会大大提高后期软件开发的效率。 MVC是用来分割页面和数据库访问的框架，降低两者的耦合度，同时通过Controller的控制，使系统更加的灵活，代码更加健壮，复用性更强。 Q11: 为什么使用MyBatis？ 在我们传统的 JDBC 中，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的繁琐又枯燥。而我们在使用了 MyBatis 之后，只需要提供 SQL 语句就好了，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 Java相关小知识点01 run是线程执行的方法 start是启动线程对象，使之从新建状态进入就绪状态 sleep让线程睡眠，在此期间线程不消耗CPU资源 suspend使线程挂起，暂停执行，如果想要恢复线程，必须由其它线程调用resume方法]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库整理]]></title>
    <url>%2F2018%2F01%2F02%2FSQLfirstview%2F</url>
    <content type="text"><![CDATA[关于主键和外键： 简而言之，SQL的主键和外键就是起约束作用。 关系型数据库中一条记录中有若干个属性，若其中某一个属性组（注意是组）能唯一标识一条记录，该属性就可以成为一个主键。 成绩表中单一一个属性无法唯一标识一条记录，学号和课程编号的组合才可以唯一标识一条记录，所以学号和课程编号的属性组是一个主键。 成绩表中的学号不是成绩表中的主键，但它和学生表中的学号相对应，并且学生表中的学号是学生表的主键，则称成绩表中的学号是学生表的外键；同理，成绩表中的课程号是课程表的外键。 定义： 123主键：唯一标识一条记录，不能有重复，不允许为空。外键：表的外键是另一表的主键，外键是可以有重复的，可以是空值。索引：该字段没有重复值，但可以有一个空值。 作用： 123主键：用来保证数据完整性外键：用来和其他表建立联系用索引：用来提高查询排序的速度 个数： 123主键：主键只能有一个。外键：一个表可以有多个外键。索引：一个表可以有多个唯一索引。 常用数据库查询操作数据库查询 数据库操作的原理就是将需求翻译成数据库语言 简单的单表查询操作查询“数据库原理”课程的学分； 12SELECT cname，credit FROM course WHERE cname = ‘数据库原理’从course表中取出cname和credit数据，条件是cname为数据库原理 查询选修了课程编号为“C01”的学生的学号和成绩，并将成绩按降序输出； 12SELECT sno，grade FROM sc WHERE cno = ‘C01’ ORDER BY grade DESC；从sc表中选出sno和grade数据，条件是cno是C01，按grade降序输出 查询学号为“31401”的学生选修的课程编号和成绩； 12SELECT cno，grade FROM sc WHERE sno = ‘31401’从sc表中选出cno和grade两个数据，条件是sno为31401 查询选修了课程编号为“C01”且成绩高于85分的学生的学号和成绩； 12SELECT sno, grade FROM sc WHERE cno = &apos;C01&apos; AND grade &gt; 85;从sc表中查询sno和grade，条件是cno为C01以及grade大于85分 简单的多表的连接查询 由于学号和成绩分别在student和sc表中，所以这是多表查询，多表查询注意隐含条件的表达 查询选修了课程编号为“C01”且成绩高于85分的学生的学号、姓名和成绩； 12SELECT sc.sno, sname, grade FROM student, sc WHERE student.sno = sc.sno AND cno = &apos;C01&apos; AND grade &gt;85;从student和sc表中选取学号、姓名和成绩，条件是课程编号C01、成绩&gt;85、并且【学生编号相同】 查询所有学生的学号、姓名、选修的课程名称和成绩； 12SELECT sc.sno, sname, cname, grade FROM student, sc, course WHERE sc.sno = student.sno AND sc.cno = course.cno;从student、course和sc表中查询学号、姓名、课程名和成绩，条件是三个表中的学号均相同 复杂的查询操作 GROUP BY用于合计函数，根据一个或多个列对结果集进行分组，比如这题想要得到的是 学生 的 课程总和 ，所以GROUP BY学生，合计课程号cno 查询至少选了三门课程的学生的学号和姓名； 12345SELECT sc.sno, sname FROM sc, student WHERE sc.sno = student.sno GROUP BY sc.sno HAVING COUNT(sc.cno)&gt;=3从sc和student表中查询，条件是学号相同，并且统计选课&gt;=3 GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组 查询所有学生的学号和他选修课程的最高成绩，要求他的选修课程中没有成绩为空的； 12SELECT sno, max(grade) FROM sc GROUP BY sno HAVING MIN(grade) &gt; 0;这里调用一个max，并且选课成绩不为空仍然用group by和having min 带有IN、比较符的嵌套查询查询修了数据库原理的学生的学号和姓名; 123456SELECT sc.sno, sname FROM student, scWHERE sc.sno = student.sno AND sc.cno IN (SELECT cno FROM course WHERE cname = &apos;数据库原理&apos;)；从student和sc中查询学号和姓名，条件是学号相同，这里IN相当于等号【在course表中数据库对应的cno】 inner join表示输出前后两个表的共同部分on【共同的志向条件】 查询没有选修数据库原理的学生的学号和姓名； 12345678SELECT sno, sname FROM studentWHERE sno NOT IN (SELECT sc.sno FROM sc INNER JOIN course ON sc.cno = course.cno WHERE (course.cname = &apos;数据库原理&apos;))从student表中查询学号姓名，条件是sno不等于（从【sc和course表中cno相同】中选出sno，条件是cname为数据库原理） 查询至少选修了【学号为“31401”的学生所选修的所有课程】的学生的学号和姓名； EXCEPT 仅返回那些不存在于第二个 SELECT 语句结果的记录（差集） DISTINCT 关键字同 SELECT 语句一起使用，可以去除所有重复记录，只返回唯一项 EXISTS 和 NOT EXISTS 表示是否存在，只返回True/False 123456select distinct sno, snamefrom student where not exists ((select cno from sc where sno=’31401’) except (select cno from sc where sc.sno=student.sno));（31401选的课程号减去别的同学所选的课程号）【判断是否存在】，不存在返回真，选出不重复的学生 但是MYSQL没有except关键字，只能用建立视图解决问题： 视图的优点：简单、安全、数据独立 左连接where只影向右表，右连接where只影响左表 「select * from tbl1 Left Join tbl2 where tbl1.ID = tbl2.ID」 左连接后的检索结果是显示tbl1的所有数据和tbl2中满足where 条件的数据 12345678910111213create view temp as select distinct cno from sc where sno=’31401’;第一步，选出学号为31401所选的所有课程，创建视图create view ttemp as select temp.cno, sno from temp left join sc on temp.cno=sc.cno ; 第二步，选出cno和sno，从temp表以及sc表中cno相同的数据，「对照temp.cno把学号输入一遍」，创建视图另一种写法：【create view ttemp as select temp.cno, sno from temp, sc where temp.cno=sc.cno(+)】select sno,sname from student where sno in (select sno from ttemp group by sno having count(distinct cno)=3);第三步，查找从学生表中查询学号姓名，条件是sno等于【从ttemp中选出sno，不重复的cno个数大于等于3的sno】 由浅入深多表查询多表连接分为三类 内连接：（joind，inner join） 外连接：（left join，left outer join，right join，right outer join，union） 交叉连接：（cross join） 一、内连接语法： 对内连接 123SELECT table1.column, table2.columnFROM table1, table2WHERE table1.column1 = table2.column2; 例：查询每个员工的工号，姓名，工资，部门名和工作地点 123SELECT empno, ename, sal, dname, loc FROM emp, deptWHERE emp.deptno=dept.deptno; 内连接的另一种写法： 123SELECT empno,ename,job,sal,dept.deptno,dname,locFROM emp JOIN dept ON (emp.deptno=dept.deptno); 二、外链接语法 对外连接 123SELECT table1.column, table2.column --右外连接FROM table1, table2WHERE table1.column(+) = table2.column; 123SELECT table1.column, table2.column --左外连接FROM table1, table2WHERE table1.column = table2.column(+); 左外连接就是把左边的表内容全列出来，右边的只显示相同的部分，不存在的写NULL。右外连接就是把右边表内容全列出来，左边只显示相同的部分，不存在的写NULL。全连接就是完整返回左右表所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 例：查询每个员工的工号，姓名，工资，部门名和工作地点 123SELECT empno,ename,job,sal,dept.deptno,dname,loc --右外连接FROM emp,deptWHERE emp.deptno(+)=dept.deptno; 另一种写法： 12SELECT empno,ename,job,sal,dept.deptno,dname,loc --右外连接FROM emp right join dept on (emp.deptno=dept.deptno); 左外链接： 12SELECT empno,ename,job,sal,dept.deptno,dname,loc --左外连接FROM emp left join dept on (emp.deptno=dept.deptno); 全连接： 12SELECT empno,ename,job,sal,d.deptno,dname,locFROM emp e full join dept d on (e.deptno=d.deptno); 三、交叉连接（笛卡尔积） 实际应用中还有这样一种情形，想得到A，B记录的排列组合，即笛卡儿积，这个就不好用集合和元素来表示了。需要用到cross join 12SELECT empno,ename,dnameFROM emp cross join dept; 数据库ODBC接口 利用C语言编程实现简单的数据库应用程序，掌握基于ODBC的数据库访问的基本原理和方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include"windows.h"#include"sql.h"#include"sqlext.h"#include"sqltypes.h" #include"odbcinst.h"struct course_cell&#123; char cno[5]; char cname[20]; int lhour; int credit; char semester[5];&#125;;unsigned char sql_select[]="select * from db.course"; //SQL查询语句 unsigned char sql_dolist[3][100]=&#123;"insert into db.course values('C27','internet',48,2,'')", "update db.course set semester='τ' where cno='C27'", "delete from db.course where cno='C27'"&#125;; //插入、修改、删除语句 unsigned char do_name[3][10]=&#123;"insert","update","delete"&#125;;void show_course(HDBC hdbc) //显示course的内容&#123; HSTMT hstmt; RETCODE retcode; long lenOut1,lenOut2,lenOut3,lenOut4,lenOut5; struct course_cell* ccell; ccell = (struct course_cell*)malloc(sizeof(struct course_cell)); retcode=SQLAllocStmt(hdbc,&amp;hstmt); if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123;//SQLBindCol将应用程序的数据缓冲绑定到结果集的各列 retcode=SQLBindCol(hstmt,1,SQL_C_CHAR,ccell-&gt;cno,5,&amp;lenOut1); retcode=SQLBindCol(hstmt,2,SQL_C_CHAR,ccell-&gt;cname,20,&amp;lenOut2); retcode=SQLBindCol(hstmt,3,SQL_C_SLONG,&amp;ccell-&gt;lhour,sizeof(int),&amp;lenOut3); retcode=SQLBindCol(hstmt,4,SQL_C_SLONG,&amp;ccell-&gt;credit,sizeof(int),&amp;lenOut4); retcode=SQLBindCol(hstmt,5,SQL_C_CHAR,ccell-&gt;semester,5,&amp;lenOut5); retcode=SQLExecDirect(hstmt,sql_select,SQL_NTS); //把SQL语句送到数据库服务器，请求执行由SQL语句定义的数据库访问 if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; printf("db.course is as following:\n"); printf("----------------------------------------------------------------\n"); printf("cno cname lhour credit semester\n"); retcode=SQLFetch(hstmt); /*SQLFetch fetches the next rowset of data from the result set and returns data for all bound columns.相当与SQLFetchAdvances和SQLGetData两个函数*/ while(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; printf("%-10s%-20s%-15d%-16d%-5s\n", ccell-&gt;cno,ccell-&gt;cname,ccell-&gt;lhour,ccell-&gt;credit,ccell-&gt;semester); retcode=SQLFetch(hstmt); &#125; printf("----------------------------------------------------------------\n\n"); &#125; &#125; SQLFreeStmt(hstmt,SQL_DROP);//释放语句句柄&#125; int main()&#123; HENV env; //定义环境句柄 HDBC hdbc; //定义链接句柄 HSTMT hstmt; //定义语句句柄 RETCODE retcode; retcode=SQLAllocEnv(&amp;env); //初始化ODBC环境，返回环境句柄 if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; retcode=SQLAllocConnect(env,&amp;hdbc); //为连接句柄分配内存并返回链接句柄 if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; retcode=SQLConnect(hdbc,(SQLCHAR*)"test",SQL_NTS,(SQLCHAR*)"root",SQL_NTS,(SQLCHAR*)"",SQL_NTS); //连接一个SQL数据资料 if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; show_course(hdbc); //显示初始的course内容 for(int i=0; i&lt;3; i++) //依次执行插入、修改、删除操作 &#123; retcode=SQLAllocStmt(hdbc,&amp;hstmt);//为语句句柄分配内存，并返回语句句柄 retcode=SQLExecDirect(hstmt,sql_dolist[i],SQL_NTS); //把SQL语句送到数据库服务器，请求执行由SQL语句定义的数据库访问 printf("%s ", do_name[i]); if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) printf("success!\n\n"); else printf("fail!\n\n"); SQLFreeStmt(hstmt,SQL_DROP); //释放与语句句柄相关的资源 show_course(hdbc);//显示操作后的新course内容 &#125; SQLDisconnect(hdbc); //切断连接 &#125; SQLFreeConnect(hdbc); //释放与连接句柄相关的资源 &#125; SQLFreeEnv(env); //释放与环境句柄相关的资源&#125; return 0;&#125; 数据库完整性与安全性定义各基表的主键12345678910111213141516171819202122232425CREATE TABLE sc( sno varchar(6) NOT NULL, cno varchar(3) NOT NULL, grade int(11) DEFAULT NULL, PRIMARY KEY (sno,cno))DEFAULT CHARSET = gbk;Create Table student ( sno varchar(6) NOT NULL, sname varchar(6) DEFAULT NULL, sex varchar(2) DEFAULT NULL, bdate datetime DEFAULT NULL, dept varchar(8) DEFAULT NULL, classno varchar(3) DEFAULT NULL, PRIMARY KEY (sno)) DEFAULT CHARSET=gbk；Create Table course ( cno varchar(3) NOT NULL, cname varchar(12) DEFAULT NULL, lhour int(11) DEFAULT NULL, credit int(11) DEFAULT NULL, semester varchar(2) DEFAULT NULL, PRIMARY KEY (cno)) DEFAULT CHARSET=gbk； 删除和添加主键外键12345678alter table course drop primary key;alter table course add primary key(cno);alter table sc add constraint foreign key&lt;sno&gt; references student&lt;sno&gt;;alter table sc add constraint foreign key&lt;cno&gt; references course&lt;cno&gt;;show create table course;查看各表信息 验证完整型约束： 分别向学生表、课程表插入具有相同学号和相同课程编号的学生数据和课程数据，验证其实体完整型约束。可以看出对student和course插入具有相同学号和课程编号的学生数据，都失败了，验证其实体完整型约束。 向学生课表插入一条课表编号课程表中没有的，验证参照完整型约束。插入失败。 定义存储过程 存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。 存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。 存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。 首先定义存储过程的结束符 12DELIMITER //用delimiter修改结束符为// 声明存储过程 1create procedure demo_in_parameter(IN p_in int) 存储过程开始和结束符号: 1BEGIN .... END 变量赋值: 1SET @p_in=1 变量定义: 1DECLARE l_int int unsigned default 4000000; 创建mysql存储过程、存储函数: 1create procedure 存储过程名(参数) 存储过程体: 1create function 存储函数名(参数) 示例：创建数据库备份数据用于示例： 1234create database db1;use db1;create table PLAYERS as select * from TENNIS.PLAYERS;create table MATCHES as select * from TENNIS.MATCHES; 存储过程示例：「删除给定球员参加的所有比赛」 12345678delimiter // #将语句的结束符号从分毫；临时改为两个//# 使用 DELIMITER $$ 命令将语句的结束符号从分号 ; 临时改为两个 $$，使得过程体中使用的分号被直接传递到服务器，而不会被客户端（如mysql）解释。create procedure delete_matches(IN p_playerno INTEGER)BEGIN delete from MATCHES where playerno = p_playerno;END//delimiter; #将语句的结束符号恢复为分号 调用存储过程： 1call sp_name[(传参)]； 触发器 MySQL包含对触发器的支持。触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。 创建触发器语法： 123456CREATE TRIGGER trigger_name #nametrigger_time #触发时机，before/aftertrigger_event ON tbl_name #触发事件：insert/update/delete 建立触发器表名，在哪张表建立触发器。FOR EACH ROWtrigger_stmt #触发器程序体，可以是SQL语句也可以是BEGIN和END包含的多条语句（delimiter）# 由此可见，可以创建（2x3）六种触发器 示例： 假设系统中有两个表：班级表 class(班级号 classID, 班内学生数 stuCount)学生表 student(学号 stuID, 所属班级号 classID)要创建触发器来使班级表中的班内学生数随着学生的添加自动更新，代码如下： 12345678910DELIMITER $create trigger tri_stuInsertAFTER INSERTON student FOR EACH ROWBEGINdeclare c int; #变量定义set c = (select stuCount from class where classID=new.classID); #变量赋值update class set stuCount = c + 1 where classID = new.classID; #变量操作END$DELIMITER ; 数据库查询分析深入理解分组查询例题：把统计时间（statistic）相同的，服务域（service_domain_moid）a中的hd100的数量和hd100s的数量的和计算出来： 首先，我们把service_domain_moid为a的筛选出来，如下： 12SELECT hd100, hd100s FROM statisticWHERE service_domain_moid=&quot;a&quot;; 其次： 我们把统计时间（statistic_time）相同的分组，求和 123SELECT sum(hd100),sum(hd100s)FROM statistic WHERE service_domain_moid=&quot;a&quot;GROUP BY statistic_time; 最后，统计结果按降序排序： 1234SELECT sum(hd100),sum(hd100s)FROM statistic WHERE service_domain_moid=&quot;a&quot;GROUP BY statistic_timeORDER BY statistic_time desc; GROUP BY关键字可以将查询的结果按某个字段或多个字段进行分组，字段中值相等的为一组。其语法规则如下： 1GROUP BY 属性名 [HAVING 条件表达式] [WITH ROLLUP] ORDER BY关键字可以对记录进行排序，其语法规则如下： 1ORDER BY 属性名 [ASC|DESC] 数据库练习题：01 按部门名称查询出员工的人数大于等于100的语句.(员工:emp_employee, 部门名称: department,员工姓名chnalias.) 12SELECT department FROM emp_employeeGROUP BY department HAVING COUNT(*) &gt;= 100; 02 把员工的姓名、性别和年龄显示出来。（员工表emp_employee，员工姓名：chnalias，年龄age，性别：gender。性别表：pub_gendar_info，性别名称：smpalias,与员工表的性别无关） 12SELECT e.chnalias, e.smpalias, e.age FROM emp_employee e INNER JOIN pub_gender g ON(e.gender = g.smpalias) 04 删除员工表中的姓名重复的数据，只保留重复数据中的一条数据。（员工表emp_employee,员工姓名：chnalias） 1234DELETE FROM emp_employeeWHERE id NOT IN( SELECT MAX(id) AS id FROM emp_employee GROUP BY chnalias) AS关键字为查询的字段起一个别名，例如上面的语句里，给MAX(id)起个别名id【AS关键字可省略】 05 查询出差表中的每个员工最近的出差时间和员工姓名(出差表emp_travel,员工姓名chnalias,出差时间godate) 1SELECT chnalias, godate FROM emp_travel ORDER BY godate DESC 数据库查询练习01 没有选修课程编号为C1的学生姓名【多表查询】 首先找出C1对应的chosen_class表中的c_id 12SELECT chose_class.c_id FROM class, chosen_class WHERE class.c_id = chose_class.c_id AND c_name = &quot;C1&quot;; 然后找出没有选修C1的学生 12345SELECT s_name FROM student, chose_classWHERE student.s_id = chose_class.s_id AND c_id NOT IN ( SELECT chose_class.c_id FROM class,chose_class WHERE class.c_id = chose_class.c_id AND c_name = &quot;C1&quot;); 02 列出每门课程名称和平均成绩，并按照程序排序 先分组查找计算每门课对应的平均成绩： 12SELECT c_id, avg(grade) avggrade FROM chosen_classGROUP BY c_id 然后多表查询（名称+成绩）并按照程序排序： 12345SELECT c.c_name, avggrade FROM( SELECT c_id, avg(garde) avggrade FROM chosen_class GROUP BY c_id) b JOIN class c ON c.c_id = b.c_id ORDER BY b.avggrade DESC; 03 选了2门课以上的学生姓名 统计学生id对应的选课数 12SELECT s_id, count(*) countclass FROM chosen_classGROUP BY s_id 1234SELECT s.s_name, b.countclass FROM( SELECT s_id, count(*) countclass FROM chosen_class GROUP BY s_id) b JOIN student s ON (s.s_id = b.s_id)]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[裂纹识别初探]]></title>
    <url>%2F2017%2F10%2F23%2FCrackIdentify%2F</url>
    <content type="text"><![CDATA[裂纹识别的基本步骤 基于概率模型的裂纹识别算法总结 思路：仍然基于传统的模式识别方法，通过计算已知模板与图像的相关性，但是裂纹的形状与走向具有很大的随机性，引入概率论可以更好地建立模板。将概率论引入到理想裂纹模型的建立中，并将所建立的概率模型映射为理想模板。通过计算理想模板与图像像素点对应区域的Bhattacharyya系数来评定像素为裂纹的可能性。进而从X光图像中自动地提取裂纹轮廓。 关于Bhattacharyya系数（相似系数）：可以衡量两个向量间的相似程度。 裂纹中心点概率模型：通过观察裂纹图像发现裂纹中心点灰度低，两侧稍高，裂纹整体灰度地域背景灰度。根据裂纹图像的特点，将裂纹的中心曲线看作是裂纹中心点沿着曲线运动的轨迹。假设理想裂纹的中心点分布概率服从高斯分布，则任意剖面都满足高斯分布。模型窗口中心点是裂纹中心点的概率最大。 理想裂纹模板：基于裂纹灰度分布特点，将理想模型映射成理想模板。 裂纹识别算法： 图像预处理：（处理背景噪声） 斯通滤波：图像中的噪声绝大部分都位于图像频谱中的高频部分，通过高斯低通滤波器，滤除原始图像中的高频部分，避免理想模板与噪声发生误匹配。 阈值分割：采用改进的OSTU方法对图像进行灰度阈值分割，计算出合适的灰度阈值T 灰度拉伸：根据灰度阈值T，将灰度值高于T的像素灰度置为255.确定合适的门限值M，讲地域该门限的像素灰度置为0，根据先验经验，裂纹中心灰度的范围浮动低于10个灰度级左右。（二值化） 灰度拉伸的作用：增强原始图像的对比度，增加裂纹与模板的相似程度，从而增加了识别的准确性 算法流程： 根据式(2)将理想概率模型映射为理想模板矩阵 B。 统计模板矩阵 B 中元素对应的灰度概率分布，建立模 板的概率矩阵 B1，B1 中的元素为 B 中该元素灰度值在模板 中出现的概率。 对预处理后的原始图像进行逐像素循环，计算以当前 点为中心，模板矩阵区域大小内像素灰度分布概率为 i p ，再 根据 i p 与 B1 计算该区域对应的 Bhattacharyya 系数，并将其 作为当前点的替代值，遍历原始图像后生成相似系数矩阵。 将相似系数矩阵映射为灰度图像矩阵，并将其二值化。 对二值图像进行形态学操作，从而在二值图像中得到 裂纹的完整轮廓。将裂纹的轮廓和所在区域在原始图像中标 记出来，从而达到识别裂纹的目的。 形态学操作——消除二值化后的的噪声点 形态学操作流程：图像取反—关运算—膨胀—填充—腐蚀 形态学操作中膨胀和腐蚀的尺度必须一致，否则得到的轮廓尺寸便被人为地引入了方法误差。 经过形态学操作后得到了完整的裂纹轮廓，通过边缘检测算法，将该二值图像中的裂纹轮廓重绘于其对应的原始图像上，并在原始图像上标定出裂纹区域信息，从而完成了对裂纹的识别。 基于图像处理的微波处理材裂纹总结 思路：利用matlab软件中的图像处理模块，通过编程对微波处理木材表面裂纹的彩色扫描图像类型转换、图像增强、图像分割及图像形态学处理，提取图像中存在的裂纹，并最终对裂纹信息进行统计。 图像类型转换： Matlab图像处理模块提供了许多图像类型转换函数，通过这些函数可以实现RGB图像、灰度图像、索引图像及二值图像之间的相互变换。 由于图像后期处理都是在灰度图像基础上进行的，所以需要先将彩色扫描图像转换为灰度图像。在Matlab软件中，可通过调用rgb2gray函数实现彩色图像至灰度图像的转换。 图像增强： 在获取图像的过程中，各种干扰因素的存在会导致源图像中存在噪声，从而影响图像的质量。因此必须先对图像进行增强处理，图像增强可以将图像中感兴趣的特征有选择地突出，并衰减不需要的特征，以便后期对图像特征进行识别分析。 增强对比度：使源图像中各部分的反差增强。本文进行对比度增强处理的目的是使源图像中裂纹区域与其他部分的区别更为明显，主要通过imadjust函数实现。 锐化处理：经过以上的平滑滤波器对图像进行处理后，图像会有一定程度的模糊，进行锐化处理以突出图像的边缘信息，加强图像的轮廓特征，以便于人眼观察和机器识别。 二值图降噪处理：通过调用bwareaopen函数去除尺寸较小的噪声，经过降噪处理后，图像中有部分尺寸较大的噪声仍未去除，如果加大去噪过程中去除对象的尺度，会同时将部分较小的裂纹去除，因此不能采用该方法。而通过roifill函数，采用区域填充的方法可以达到去除大尺寸噪声的目的。 断裂纹闭合：采用形态学处理中的闭运算操作，通过创建一个平面的线性结构元素使裂纹的断裂区域闭合。 裂纹信息统计：采用matlab软件中形态学处理的操作，获得裂纹数量、裂纹长度、宽度及面积等信息，并由此计算机出图像中裂纹区域所占图像面积的比例。首先调用bwlabel函数对裂纹进行编号，可以统计图像中的裂纹数量。其次，利用regionprops函数可以计算出每条裂纹对应的长度、宽度和面积。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令对应的单词]]></title>
    <url>%2F2017%2F01%2F21%2FLinuxAbbreviation%2F</url>
    <content type="text"><![CDATA[特殊命名MySQL = My是最初作者女儿的名字，SQL = Structured Query LanguagePython 得名于电视剧Monty Python&rsquo;s Flying Circusawk = “Aho Weiberger and Kernighan” 三个作者的姓的第一个字母biff = 作者Heidi Stettner在U.C.Berkely养的一条狗,喜欢对邮递员汪汪叫。 目录名：/etc：ETCetera/bin：BINaries/dev：DEVices/lib：LIBraries/mnt：MouNT/proc：PROCesses/tmp：TeMPorary/var：VARiable/srv：SeRVices/opt：OPTion/sbin：Super BINaries（又作Superuser BINaries）/sys：SYStem/usr：Unix Shared Resources 文件管理（包括文件输出管理）：ls – LiStcd – Change Directorypwd – Print Working Directorycp – CoPymv – MoVerm – ReMovepushd – PUSH to Directorypopd – POP from Directorymkdir – MaKe DIRectoryrmdir – ReMove DIRectorycat – CATenatesed – Stream EDitordiff – DIFFerencewc – Word Countchmod – CHange MODechown – CHange OWNerchgrp – CHange GRouPawk – Aho Weinberger and Kernighangawk – Gnu Aho Weinberger and Kernighangrep – General Regular Expression Println – LiNktar – TARball 硬件管理：df – Disk Freedu – Disk Usagedd – Data Descriptionparted – PARTition EDitorlspci – LiSt Peripheral Component Interconnectlscpu – LiSt Central Process Unitlsusb – LiSt Universal Serial Bus 软件及软件包管理：man – MANualapt – Advanced Packaging Tooldpkg – Debian PacKaGeyum – Yellow dog Updater, Modifiedrpm – RPM Package Manager 系统管理：depmod – DEPend MODulelsmod – LiSt MODulemodprobe – MODule PROBEmodinfo – MODule INFOrmationinsmod – INSert MODulermmod – ReMove MODuleps – Processes Statussu – Substitute Userbash – Bourne Again SHellinit – INITializationssh – Secure SHellwine – Wine Is Not an Emulatorexec – EXECutefstab – FileSystem TABlepasswd – PASSWorDtty – TeleTYpesudo – SuperUser DOgrub – GRand Unified Bootloadertzselect – Time Zone SELECTsync – SYNChronize 编辑器：ed – EDitornano – Nano’s ANOther editoremacs – Editor MACroSvi – VIsualvim – Vi Improved 写程序时会用到的：cc – C Compilergcc – Gnu Compiler Collectiongcc – Gnu C Compilerg++ – Gnu c++ compilergcj – Gnu Compiler for Javayacc – Yet Another Compiler Compilerguile – Gnu Ubiquitous Intelligent Language for Extensionsgas – Gnu Assemblerphp – PHP：Hypertext Preprocessorld – Link eDitorgdb – Gnu DeBugtcl – Tool Command Line 图形界面：gnome – GNu Object Model Environmentgdm – Gnome Display Managergtk – Graphic user interface ToolKitqt – Toolkitkde – K Desktop Environmentlxde – Lightweight X11 Desktop Environmentxfce – XForms Common Environment 各种参数-a | –all ; –archive ; –append-b | –blocksize ; –batch-c | –commands ; –create-d | –debuge ; –delete ; –directory-e | –execute ; –edit ; –exclude-f | –force ; –file ; –configuration file-h | –help ; –human readable ; –headers-i | –interactive ; –include-k | –keep ; –kill-l | –long listing format ; –list ; –load-m | –message ; –manual ; –create home-n | –number ; –no-o | –output ; –options-p | –port ; –protocol ; –passwd-q | –quiet-r | –reverse ; –recursive-s | –silent ; –size ; –subject-t | –tag ; –type-u | –user-v | –verbose ; –version-w | –width ; –warning-x | –exclude-y | –yes-z | –zip 许可证：gnu gpl : Gnu General Public Licensegnu lgpl : Gnu General Lesser Public Licensegfdl : Gnu Free Documentation Licenseagpl : Affero General Public Licenseapsl : Apple Public Source Licensebsd : Berkeley Software Distribution license]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《鸟哥的私房菜》思维导图]]></title>
    <url>%2F2017%2F01%2F17%2FLinuxXmind%2F</url>
    <content type="text"><![CDATA[Linux学习计划 Linux文件、目录与磁盘格式 Shell与Shell Script]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb总结]]></title>
    <url>%2F2017%2F01%2F02%2FJavaWeb-bili%2F</url>
    <content type="text"><![CDATA[01 JSP环境搭建JSP动态网页 静态、动态：是否随着 时间、地点、用户操作 的改变而改变 动态网页：需要使用到服务器脚本语言（JSP） 架构C/S、B/S架构 C/S架构的不足：（QQ） 如果软件升级、所有软件都需要升级 维护麻烦，需要维护每一台客户端软件 每一个客户都需要安装客户端软件 B/S架构：（京东网页） 客户端可以通过浏览器直接访问服务端 Tomcat解压后的目录bin：可执行文件（startup.bat、shutdown.bat） conf：配置文件（server.xml） lib：Tomcat依赖的jar文件 log：日志文件（记录出错信息） temp：临时文件 webapps：可执行的项目（将我们开发的项目放入该目录） work：存放由jsp翻译成的Java，以及编辑成class文件（tsp -&gt; java -&gt; class） 配置Tomcat 配置jdk（必须配置Java_HOME）java_home、classPath、path 配置catalina_home 双击 bin/startup.bat 启动tomcat 常见错误：可能与其他服务器端口号冲突。（默认端口8080） 修改端口号：conf/server.xml（70行左右） 访问Tomcathttp://localhost:8888/ 常见状态码： 200: 一切正常 300/301: 页面重定向 404: 资源不存在 403:权限不足（如果访问a目录，但是a目录设置 不可见） 500: 服务器内部错误（代码有误） Apache项目文件结构 如果有index.jsp和index2.jsp文件，通过 welcome 设置默认的初始页面。 JSP：在HTML中嵌套的Java代码 虚拟路径将web项目配置到webapps以外的目录——【配置虚拟路径】 server.xml 文件 Host 代码块内写一个 Context 代码： docBase：实际路径 path：虚拟路径（绝对路径、相对路径「相对于webapps」） 方法二： 在 conf/Catalina/localhost 新建文件 「项目名」.xml 中新增一行 虚拟主机通过 www.test.com 访问本机配置 server.xml 中的 Host 代码块 12345添加Host代码块&lt;Host appBase="D:\study\JspProject" name="www.test.com" &gt; &lt;Context docBase="D:\study\JspProject" path="/"&gt;&lt;/Context&gt;&lt;/Host&gt;并修改默认引擎中的 defaultHost=“www.test.com" 配置电脑的 hosts 文件，添加映射 127.0.0.1 到 www.test.com 访问： www.test.com:8888 网站默认端口是 80 ，只要端口改成 80 ，就可以省略端口号 流程：www.test.com -&gt; host找映射关系 -&gt; server.xml 找 Engine 的 defaultHost -&gt; 通过 “/” 映射到 D:\study\JspProject 为了后续学习，将以上恢复改端口、改Engine、删Hosts JSP执行流程第一次访问服务端将jsp翻译成java（Servlet文件），再将Java编译成class文件 最终存放在 D:\study\apache-tomcat-8.5.30\work\Catalina\localhost\JspProject\org\apache\jsp 第二次访问直接访问class（如果服务端修改了代码，将会在访问中重新翻译和编译） Jsp和Servlet可以相互转换]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
</search>
