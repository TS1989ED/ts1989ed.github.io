<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[元器件电磁兼容设计]]></title>
    <url>%2F2021%2F06%2F19%2FEMC%2F</url>
    <content type="text"><![CDATA[内容框架 基本定义与分类 理论模型 常规特性 高频特性（EMC、寄生参数） 应用关键点 课程目的 清晰器件工作机理 全面了解器件电气特性 深析器件高频特性 掌握器件应用的关键点 元器件的选型与产品设计元器件引起的故障 压敏电阻炸坏 热机EMI超标 批量EMI超标 电解电容失效 瓷片电容炸裂 接插件接触不良 高温故障 电源产品 保险丝：通常考虑浪涌、最大输出功率来选型。 电容：X电容、Y电容、薄膜电容、电解电容 电感：共模电感、PFC电感 270W医疗电源 EMC法规 元器件选型及应用 一、导线 基本定义与分类 理论模型 常规特性 高频特性 应用关键点 分类： 普通导线 电力线n 屏蔽线 组合线 理论模型1）直流伏安特性 2）动态伏安特性 电阻和电容接入的特性 常规特性 高频特性 低频段呈现低电阻特性 高频段呈现电感特性 寄生电感特性 自感、长度、趋肤深度、射频电阻 导线自感LL=0.002·l[2.3log(\frac{4·l}{d}-0.75)]uH其中：l为导线长度（cm）；d为导线直径（cm）。 工程应用中AWG与自感的换算 长度与波长 C=f·\lambda当 $d&lt;\frac{\lambda}{20}$ 导线不会往外辐射电磁波，PCB布线要注意二十分之一波长。 长度与绞线 双绞线：右向绞线和左向绞线 绞线密度：xx/米，一绞的宽度要小于 $\frac{\lambda}{20}$ ，绞线密度需要和供应商要求。如果绞线密度过高，会破坏绝缘强度。 多层绞线：相邻绞线相反 趋肤深度 趋肤深度与频率 射频电阻根据趋肤深度计算得到射频电阻。 导线——小结 导线自感——长度和直径 导线长度——$\frac{\lambda}{20}$ 趋肤深度——频率和电导率 射频电阻——导体形状 寄生电容 二、PCB 基本定义与分类 加工工艺 布线流程 常规特性 高频特性 应用关键点 印制电路板印制板英文：Printed Circuit Board 主要功能：支撑和互连。 发展简史印制电路板概念于1936年由奥地利人Paul Eisler提出，并且首创铜箔腐蚀法工艺；二战中美国利用该工艺技术制造印制板用于军事收音机中，获得成功。 1953年出现了双面板，并采用电镀工艺使两面导线互连。 1960面出现多层板。 1990出现积层多层板。 基材有机材质： 常用：FR-1、FR-4、CRM-1 强度、防火、软硬不同分类 熔点 $T_g$ （玻璃转化温度）：保持刚性最高温度，在此温度下不能燃烧。 阻燃性 PCB加工工艺 布线流程标准化 常规特性 PCB高频特性 过孔 PCB内传输线 隐藏电容 3W原则 20H原则 叠层设计 镜像面 回路面积 接地 地弹 过孔 寄生电容 寄生电感 寄生电容 过孔的寄生电容的充放电会产生电压突降和电压尖峰，从而延长信号的上升时间，降低电路速度。因此，过孔及电容在制造工艺和允许范围内应尽量小，在高频中需要特别重视。 寄生电感 过孔注意点： 选择合理的过孔大小 薄PCB有利于减小寄生参数 PCB走线尽量不要换层，即尽量少用不必要的过孔。因为每个过孔都是一个阻抗不连续点。 电源和地的引脚就近打过孔。 PCB传输线 当电路的频率超过50MHz时，电磁能量沿PCB走线，电缆和同轴电缆等此类线沿传输线传播 PCB走线传输高频信号与传输直流或低频信号有很大不同，多层PCB中毗邻的互联关系必须以传输线考虑 无损传输线等效电路为并联电容和串联电感结构 有损传输线等效电路为串联电阻和电感，和并联电容结构 PCB传输线的天线效应 隐藏电容多层板必须要考虑的参数，用好隐藏电容可以大幅度减小PCB板辐射。 电源层和接地层邻近安装，相当于一个大的退耦电容。而且该寄生电容具有非常小的等效引线电感，没有等效串联电阻ESR 电容的容量与板芯的厚度、填充介质和叠层中的位置和大小有关 【Tip】当电源层和接地层之间的自谐振频率与安装在PCB板上的集中退耦电容的自谐振频率相同或接近时，将会产生尖锐的共振，不会用宽的退耦频段分布，影响退耦效果。此时可以用不同自谐振频率的退耦电容，避免发生与PCB板电源层和接地层的共振。 3W原则——70%三倍宽度原则： 时钟线附近往往会有别的临近的导线，如何保证互相之间不干扰呢？ 答：时钟产生的场强（磁场、电场）衰减需要达到70%，一般间隔要大于两倍的宽度。 20H原则二十倍厚度原则 Mr.W.Michael.King 提出所有具有一定电压的PCB板都会向空间辐射能量，为了能减少辐射效应，PCB板的物理尺寸应小于靠近的接地板的物理尺寸20H，使得辐射强度下降70%，其中H为两层印制板之间的距离。 电源层与底层的距离包括芯层距离、填充介质及PCB制造中的绝缘隔离距离 如果两层间距离为0.006in，20H则为0.12in 镜像面 高速器件（快速边沿速率）为实现最佳性能，必须提供低阻抗（低电感）的RF返回线路，实现闭环网络。 很多设计中经常只考虑信号电流的流经路线，忽略电流的回流路线，而电流的回流到地的路径和方式正好是混合信号电路设计的关键。 由低阻抗（低电感）的RF返回线路所形成的闭环网络在时域和频域上的要求 RF电流必须返回它的源以形成闭环电路，因此任何可能的路径都有机会被使用。 如果没有提供合适的传导路径，自由空间就成为返回路径，从而产生电磁干扰。 控制芯片的旁路电容（0.1uF），就是给60～100MHz频率的噪声提供了低阻抗的回路。如果没有这个环路电容，这个频段的噪声就会散发到自由空间中去。如果有这个电容可以对这个频段达到一个90%（抑制20dB）的衰减。 单面板无RF返回路径，如果增加一个接地层，即使用双层板、四层板甚至更多层的PCB板，均会提高PCB板的信号完整性以及电磁兼容性能。 如果在双层板增加2个或多个电源层和接地层，同城可以获得10-20dB的辐射性能改进。 为避免PCB成本的增加，多通过金属保护层或金属化的塑壳保护层来提高电磁兼容能力。 镜像面可以提供最有RF返回路径，减少串扰和电磁干扰。 通常镜像层可以是电源层、接地层、铜箔板和隔离层4种。镜像面已成为PCB设计中的标准技术。 由于镜像面的紧密耦合，RF电流不需要通过其它回路回到源处，因而镜像面技术不仅能降低地噪声，还能防止产生接地环路耦合干扰。 要减小通过导体的电压降，必须提高两个并联导体之间的互感 增加互感的方法就是使RF回路与信号线尽量靠近，使他们之间的距离达到可能的最小值。 互感存在于两条并行的导线之间 为了得到最佳互感，两条导线必须大小相等、方向相反。这是镜像面起作用的关键点 两条并行导线之间距离越小、长度越长，互感越大。 多层PCB中的电源层或接地层可以作为邻近电路或信号层的镜像面，可以提供啊电路板电磁兼容性 多层板带来成本的增加，可以考虑使用网络接地系统。 镜像面理论基础信号V1和V2通过导线到另一端，每一根导线都有一个自感，两个靠近会产生互感。 提高增加并联导体的互感，以减小导体上电压降。 互感与导体的距离和长度直接相关。 网络接地层结构波长 $\frac{\lambda}{20}$]]></content>
      <categories>
        <category>EMBEDDED</category>
      </categories>
      <tags>
        <tag>HARDWARE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运放基础]]></title>
    <url>%2F2021%2F06%2F13%2FOPA2%2F</url>
    <content type="text"><![CDATA[模电如何入门多学科：电子学、控制理论、信号系统、微积分、统计学 很多物理学家本身都是很优秀的数学家，学好物理需要很扎实的数学功底。 物理电路经过抽象建模之后可以得到一个数学模型，物理学和数学相辅相成，物理学推动数学在实际中的应用。通过物理电路的实践操作，感受真实的物理世界。通过数学建模，把物理电路理论化，从更底层的数学基础上去理解物理电路的工作过程。 要学好模拟电路，首先要相信逻辑思维、相信基本定律。模拟电路在我们遇到问题的时候表现得像一门玄学，对于初入门的人来说多了许多神秘感。但是我们要相信自己的思维判断，要相信最基本的逻辑思维和基本定律。包括欧姆定律、能量守恒定律等等。 多看书、多动手计算、勤于思考发散思维、多实操电路。 由浅入深，从最基本的电路慢慢深入到复杂电路，最后再把复杂电路简单化。 此文不需要过多的数学和物理知识以及部分的微积分基础就可以迅速建立起一套知识框架，但是我们需要对于这部分的理论进行一定深度的探索，需要对基础理论进行熟练详细的推导。 电路分析基础 一阶RC系统 运放电路分析 运放参数概念【核心】 运放参数产生的误差【核心】 频域——时域变换 反馈控制基础 运放是一门数学为基础的学科。 运算放大器基础为什么需要运放？Harold Black发明了负反馈放大电路，不仅促进了电子学的发展，也促进了控制理论的发展。 A选取足够大，放大倍数与前向增益A无关，只与 $\beta$ 有关。（$\beta$ 是反馈端电阻配比） R1和R2实现了一个反馈控制网络。人们先发明了反馈控制环路，所以他们需要一个求差的一个器件，而放大器刚好可以满足这样的要求。求差、乘以前向增益、得到的Vout乘以反馈系数…….如此循环。 运算放大器增益越大越好，单个放大器中放大倍数一般是10倍或20倍，而不会是100倍，就是因为实际情况增益A并不是无穷大。因为放大倍数越大，要达到理想状态对运放的增益A要求也就越大。 $\beta = \frac{R_1}{R_1+R_2}$ 的前提是放大器的负输入端无电流（虚断），因为如果有电流，那么在这一端就会有压降。 在运放的两条等式中，我们都是在虚短和虚断的条件下来列等式的。 运放需要满足的三个理想化条件：增益无穷大、虚短、虚断（输入阻抗无穷大） 非理想因素 $A\beta &gt;&gt; 0$ 电路分析基础能量守恒定律孤立系统的总能量保持不变。 能量既不会凭空产生也不会凭空消失，只会从一个物体转化到另一个物体，或者从一种形式转化为另一种形式，而在转化或者转移的过程中，能量总量保持不变。 电荷守恒定律对一个孤立系统，不论发生什么变化，其中所有电荷的代数和永远保持不变。 如果某一区域中的电荷增加或减少了，那么必定有等量的电荷进入或离开该区域；如果一个物流过程中产生或消失了某种符号的电荷，那么必定有等量的异号电荷产生或消失。 欧姆定律在同一电路中，通过某一导体的电流跟这段导体两端的电压成正比，跟这段导体的电阻成反比。 KCL定律（基尔霍夫电流定律）流入任何节点的电流代数和等于零。 KVL定律（基尔霍夫电压定律）沿任何闭合回路电压的代数和等于零。 时域下电容的IV方程电压源下电容 电流源下电感（电容和电感存在一种对偶的特性）]]></content>
      <categories>
        <category>EMBEDDED</category>
      </categories>
      <tags>
        <tag>HARDWARE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由NFC设计引出的关于天线及其PCB设计]]></title>
    <url>%2F2021%2F06%2F09%2FNFC%2F</url>
    <content type="text"><![CDATA[天线工作原理① 电信号 -&gt; 电磁波 利用封闭导体电磁感应（源附近的波动场） ​ 而NFC属于近场通信，理论上并不产生远距离传输的电磁波。 ② 电磁波必须与源分离并向外传播，其本质是带电粒子的运动 波长 = 正负电荷最大分隔距离的2倍 要实现最佳传输，天线长度 = 波长一半，同时天线的电磁效应是可逆的，可以作为接收器。 天线频率就是天线上电压变化的频率。 蝶形电视天线：抛物面反射器 —反射聚集—&gt; 低噪声下变频器 —同轴线缆—&gt; 馈源喇叭、一段波导、PCB、探针 贴片天线：贴片长度 = 工作波长一半 L = \frac\lambda2$\lambda = \frac{300}f \qquad(\lambda:m;f:MHz)想要L变小，即天线做得更短更小，f就需要变大，手机天线频率只能是高频。 几种天线① 半波振子天线：1/2波长天线，其余为1/4波长天线 ② 单极子：半波振子天线的一半 ③ 倒L型天线：单极子天线弯折一段，减少天线高度。 ④ 蛇形倒F天线（MIFA）：占用PCB空间小 根据不同的PCB厚度，需要调整MIFA的长度，这样才能调整天线辐射和频率的选择，MIFA根据不同电路板厚度的天线长度如下表： ⑤ 倒F型天线（IFA）：倒L型天线上半与地平行，增加了容抗。所以在拐角处接地，增加感性，以保持谐振特性。 相比MIFA，IFA是一种辐射更好的天线。给定空间可用性IFA天线比MIFA更好，有更好的效率，但需要更大的面积。 IFA的迹线宽度也取决于产品的PCB堆叠，不同厚度的PCB有不同的W值。 [Tip]：天线放置在靠近塑料的位置，谐振频率会降低。变化范围100MHz-200MHz，需要重新调谐获得所需频带。 天线效应在四分之一波长处测量，即可被视为短路，也可被视为开路。 天线的长度为 1/4 或者 1/2 波长，因此在EMC规范中，不允许导线在 $\frac\lambda{20}$ 以下工作，这会使它变成一根天线，电感电容会造成谐振。 150MHz时，$\lambda=2m$，$\frac\lambda{20} = 10cm$ ，在 $f &gt; 150MHz$ 时，$\frac\lambda{4}$ 接近10cm，逐渐形成完美天线。 阻抗匹配谐振 含 L 和 C 的电路，在特定 f 的外加电源的作用下，对外呈电阻性质的现象。这一特定的 f 即为谐振频率。以谐振频率为主工作状态的电路即为谐振电路。 有的时候需要谐振：天线 振荡电路具有固有频率，电路输入接近固有频率的交流电，振荡电路会以大振幅体现，造成危害。 有的时候需要避免谐振：电网谐波 发生谐振，只剩电阻，一个小的谐波电流源产生很大的谐波电压造成损坏。 导体波长与信号波长呈特定比例也称作谐振，因为这样可以将电能发射到空间中。 特性阻抗 导线对在其上传输的 射频能量 阻碍力的大小，也可以理解为对高频交流成分阻碍力的大小。区别于一般直流电路的电阻大小。 $特性阻抗 = 射频电压/射频电流$ 天线越宽，特性阻抗越小。传输的电能在天线末端连接空气，能量无法释放，就会沿着导线反射回来。是由于末端的阻抗突变导致的。 假设末端接入电阻R吸收射频能量： ① 当 $R = R_0$ 时，传输能量被吸收完，无能量返回，导线被视作无限长。 ② 当 $R = \infty$ 时，能量全部反射，末端形成2倍于发射电源的电压。 ③ 当 $R = 0$ 时，末端产生 -1 倍于电源的电压反射回去。 相关：特性阻抗末端电阻实验 阻抗匹配 负载阻抗与激励源内部阻抗互相适配，得到最大功率输出。 阻抗匹配能量是对于射频而言的，对功率电路而言会造成破坏。 阻抗匹配应用：功放音响、PCB走线、天线设计、终端匹配电阻。 改变组抗力的方法： 改变阻抗力：RLC串并联调整负载阻抗值 调整传输线：加长源和负载距离，配合LC阻抗力调为0 天线中传输考虑50Ω的阻抗是由传输线中高频交流的趋肤效应决定的。 特征阻抗 $Z_0$ ：无损传输线传播的波的电压和电流振幅比。 Z_0 = \sqrt\frac{L}{C}$$Z_0$ 取决于，PCB材料、基底厚度、迹线宽度、迹线厚度、迹线RF、接地填充物间隙 等。 天线馈线和空气的阻抗匹配：50Ω传输线是天线馈线系统中的特性阻抗，而天线是在馈线和自由空间中的一个分界面。自由空间（真空）中的特性阻抗为377Ω，天线起了特性阻抗变换的作用，将电磁波能最大部分发射出去。如果不匹配，电磁波会在天线末端反射回信号源。 天线是馈线和自由空间的阻抗变换器，是连接发射端和空气的介质，以便将能量从电路辐射到空间中去。 天线系统中 高频振荡电流：满足基尔霍夫定律 电磁波到无界空间：波动方程和麦克斯韦方程 名词解释驻波 相反方向传播的振幅、频率都相同的波。（实验中一般利用反射） 回波损耗 表示天线如何与特性阻抗50ohm的传输线皮诶。一个理想天线会发射所有功率，不产生任何反射。 回波损耗大于10dB就足够大，90%的功率可被辐射。 Return Loss(dB) = 10 * log(\frac{Incident Power}{Reflect Power}) 上图显示的是MIFA在2.44GHz频率时完整的3D辐射增益图，再给自定义应用设置MIFA天线时，该信息非常有用，有助于在需要的方向上得到最大的辐射。 带宽无线频率响应。表示在采用的整个频带上。（在该频率时回波损耗最小）。 辐射效率非反射功耗中消耗在天线中的热量。 增益与一个理想无方向天线对比辐射的场强。 调制将原始信号变成适合信道传输的高频信号。 射频PCB指南 置于角落PCB，保持间距 切勿在所有层的天线禁区放置任何组件、迹线、平面 塑料介电常数 &gt; 空气，无形中降低谐振频率 无线近场不允许金属 方向的一致性 天线匹配网络提供配置，天线参数变化改变阻抗，可能重新调谐，π、T网络提供配置，串联元件填充0Ω 场景验证 天线下方不能有任何接地 遵循制造商推荐的接地方式 Wifi区域记得去除上下层的绿油 最短RF 避免RF弯曲 避免短路和分支 不要任何走线平行于RF 不要测试点 元件放置在RF路径上 将一层完全用于接地 另外：阻抗匹配、天线调试、RF传输线、PCB堆叠 等 死铜移除：孤岛形成天线效应，会增加周围辐射强度，并且有天线接收效应，引入电磁干扰，造成EMI问题。 多层板四层板：射频 + GND + PWR +非射频 二层板：PWR、信号、天线、RF + GND（完整） GND 一层完全接地better 过孔间距 &lt; 波长 1/20，与多层板地平面良好接地，避免天线效应。 不要分流接地 RF走线下地平面宽敞 迹线两边GND通孔保护，EMC、EMI性能提升 电源层周围GND瞳孔包围，EMI性能提升 电源解耦 滤除不同频率的噪声 满足浪涌电流的大电容设计 组件靠近电源引脚 小电容靠近 去耦电容相同层 避免电源通孔 四层板设计，每个电源引脚独立的过孔和电源层，不共享过孔 过孔 间距 &lt; $\lambda/20$ 多过孔减小寄生电感 不共用过孔，分别设置 QFN大量过孔 RF拒绝过孔 射频周围GND过孔形成栅栏，隔离电路其余部分 NFC电路设计——以ST25R3911B为例PCB板卡工艺： 4层板设计，EMI friendly PCB左侧数字走线，右侧模拟线 差分驱动，空间小，完全对称 通孔缝合——低阻抗通孔屏蔽——通孔壁创建垂直铜屏障，防止串扰和电磁干扰问题 RFI记录道和AAT车道靠近 中间层GND低欧姆直流路径 中间层配电，5V+3V3 重要模拟轨迹用GND包围 芯片相关： AAT自动调谐 差分低阻抗天线驱动器 低功耗（电容+幅度和相位测量） 参考：Antenna Design and RF Layout Guidelines]]></content>
      <categories>
        <category>EMBEDDED</category>
      </categories>
      <tags>
        <tag>HARDWARE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正交编码]]></title>
    <url>%2F2021%2F06%2F04%2FQEP%2F</url>
    <content type="text"><![CDATA[正交编码器 正交编码器（又名双通道增量式编码器），用于将线性移位转换为脉冲信号。通过监控脉冲的数目和两个信号的相对相位，用户可以跟踪旋转位置、旋转方向和速度。另外，第三个通道称为索引信号，可用于对位置计数器进行复位，从而确定绝对位置。 两个信号相位相差90度，这两个信号就称为正交。 工作原理增量型编码器通过内部光敏接收管将编码器的转向转化为A相和B相脉冲的时序和相位关系。编码器每转还输出一个Z相脉冲以代表零位参考位。 通过A、B输出波形可知每个运动周期的时序为 编码器的中断编码器的中断实际上就是定时器的中断。也就是说定时器是每隔一定时间加一个数（或减一个数 ），当数到达预设值时就产生中断，而编码器是每一个有效脉冲就加一个数（或减一个数 ），当数到达预设值时就产生中断。若预设值为1000则编码器与定时器中断不同的是，当编码器反转时值到达999产生一次中断，而当编码器正转到达0时同 样产生一次中断。在硬件上这两个中断是没法区分的，这也就造成了有种情况的误判。 想象一下，如果编码器的预设值为1000，当某次我们使得编码器正转产生中断后，立即反转则又该怎么办呢？根据上面的说法，这时候会产生两次一样的中断。 如果在算法上没有处理的话，极有可能认为是行走了两次正向。但实际上并没有。所以这个时候必须结合方向来判断行走的情况（判断方向使用的是DIR寄存器 位）或者在产生中断后读一次count寄存器位（看看是999还是0，以此来判断当前的方向）。只有上一次为正且这一次同样为正，距离才是相加的。 读取编码器的数据一般有三种方式： ① 专用硬件模块 ② I/O中断处理 ③ 普通I/O读取并处理 从①至③，占用的计算资源依次增大，但通用性也依次增大，本文将讲解第三种读取方式的原理和实现方式。 代码实现 两相数据都发生变化时，无法判定是顺时针或逆时针旋转，于是都假定变化后数据是在 A相跳变时采集的数据。当采样频率足够高时，两相数据同时发生变化的概率很小，这样的计算方式是足够精确的。 用C语言来表示以上表格的含义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950uint8_t state = 0;void Update(void)&#123; // Read new state bits if (digitalRead(A)) &#123; state |= 0x02; &#125; if (dagitalRead(B)) &#123; state |= 0x01; &#125; switch (state) &#123; case 0x01: case 0x07: case 0x08: case 0x0E: position -= 1; break; case 0x02: case 0x04: case 0x0B: case 0x0D: position += 1; break; case 0x03: case 0x0C: position -= 2; break; case 0x06: case 0x09: position += 2; break; default: //case 0x00: //case 0x05: //case 0x0A: //case 0x0F: //position += 0; break; &#125; // Update the old state state &lt;&lt;= 2; // Keep the old state bits and clear other bits state &amp;= 0x0C;&#125; 循环调用以上的函数，就可以得到编码器旋转的栅格数，从而计算出旋转速度和距离。 STM32的编码器模式在STM32中，编码器使用的是定时器接口，通过数据手册可知，定时器1，2，3，4，5和8有编码器的功能，而其他没有。编码器输入信号TI1,TI2经过输入滤波，边沿检测产生TI1FP1，TI2FP2接到编码器模块，通过配置编码器的工作模式，即可以对编码器进行正向/反向计数。 其它 编码器有个转速上限,超过这个上限是不能正常工作的,这个是硬件的限制,原则上线数越多转速就越低,这点在选型时要注意,编码器的输出一般是开漏的,所以单片机的IO一定要上拉输入状态 定时器初始化好以后,任何时候CNT寄存器的值就是编码器的位置信息,正转他会加反转他会减这部分是不需要软件干预的,初始化时给的TIM_Period 值应该是码盘整圈的刻度值,在减溢出会自动修正为这个数.加超过此数值就回0 如果要扩展成多圈计数需要溢出中断,程序上圈计数加减方向位就行了 每个定时器的输入脚可以通过软件设定滤波 应用中如果没有绝对位置信号或者初始化完成后还没有收到绝对位置信号前的计数只能是相对计数.收到绝对位置信号后重新修改一次CNT的值就行了.码盘一般都有零位置信号,结合到定时器捕获输入就行.上电以后要往返运动一下找到这个位置 即便有滤波计数值偶尔也会有出错误的情况,一圈多计一个或少计一个数都是很正常的特别是转速比较高的时候尤其明显,有个绝对位置信号做修正是很有必要的.绝对位置信号不需要一定在零位置点,收到这个信号就将CNT修正为一个固定的数值即可 开启定时器的输入中断可以达到每个步计数都作处理的效果,但是高速运转的时候你可能处理不过来 参考：STM32——编码器测速原理及STM32编码器模式]]></content>
      <categories>
        <category>EMBEDDED</category>
      </categories>
      <tags>
        <tag>HARDWARE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于线性稳压器(LDO)的选型]]></title>
    <url>%2F2021%2F05%2F30%2FLDO%2F</url>
    <content type="text"><![CDATA[关于该充电板遇到的问题IP5306首先是在充电芯片上遇到的问题，我选用的是英集芯的一款 IP5306 做锂电池的充放电管理。作为一款在充电宝中广泛运用的芯片，也踩了一些坑。由于早些时候就用IP5306做过设计，所以这次电路基本是照搬的原先的设计，但是在因为没有用到pin 8，就默认将其悬空了。 IP6306，BAT脚降压给电池充电，Vout脚升压5V输出。电路基本按照手册设计，但是每次充电管理芯片每次上电不到三分钟，电池端直接短路保护。因为这个电路用过好多次了，一度以为是后续电路造成的问题。 事实证明很多时候遇到问题不要盲目尝试，而要多思考推断，得出基本结论后再进行修改。测试的时候也要分步进行，确认电路出问题的部分。 思考后认为是8脚悬空造成的问题，由于升压电感输出如果没有后续电容去存储能量，维持恒定电压，电感充放电电压在pin 8内部直接击穿了芯片。于是我在pin8脚加了两个22uF的电容，问题就解决了。 由于手头的芯片比较紧张，还没有用示波器实测浮空8脚的电压情况。 MP2451本来需求给我的只是要求输出两种不同的电压，并没有对电源纹波有任何要求，于是实际实验中使用该电源板供电，输出波形经过几重算法滤波后还是有很明显的噪声干扰。 简单研究了一下电路发现，其中的3V端接到某几个模拟信号的输出端，工作电压输入后在3V端出现波动剧烈波形，而在原先接3V干电池的情况下电压可以被稳定。 于是我需要把原先的开关电源换成一个参数良好的LDO，于是需要对LDO的重要参数有一定的了解。 以下正文 关于线性稳压器(LDO)的选型LDO的基本原理 LDO是个负反馈系统，Vout增大，运放输出电压增大，PMOS的VGS减小，输出电流减小，输出电压随之减小。 LDO具有很好的噪声隔离作用，具体指标是PSRR，在一些噪声敏感电路中，AD/DA等必须选择高PSRR的LDO。 关于线性稳压器的启动电流软启动第一种方法是电流软启动。大多数稳压器具有电流限值；电流软启动是缓升或步进到该电流限值。由于输出电容充电量远远小于最大负载电流，软启动使得输出电压缓慢上升。电流软启动的优点是稳压器输入电流稳定上升，不会将负载启动的瞬态电流传递到输入。 使能负载时，大家可能会注意到输出电压斜率突然改变方向的一个点。这是因为负载电路打开并尝试在稳压器处于限流的条件下启动工作。如果负载电流超过软启动电流，负载本身将进入欠压状态，造成复位。随着负载电流的打开和关闭，这种循环会不断持续。最后软启动电流达到足够高的水平，能够支持负载供电，释放复位，负载电路正常唤醒。 电压软启动第二种软启动是缓升输出电压。缓升输出电压会在输出电压上产生单调变化，当下游电路开启时不产生任何电压瞬变。这样也能防止负载多次进入复位状态，因为输出电压仅穿越负载欠压门限一次。 电压软启动期间的浪涌电流取决于输出电压和输出电压的变化斜率，在加上负载吸收的电流。典型情况下，按照浪涌电流大约为最大额定输出电流的1%至10% (使用推荐的最小输出电容)来设置输出电压斜率。将浪涌电流设置为小于最大负载电流的10%，为负载及任何额外输出电容需要的电流提供了裕量。其缺点是输入电流与负载变化有关，不能直接控制；优点是能够避免系统多次复位。 静态电流与压差的关系输入与输出之间的压差达到很小的状态。此时的线性稳压器，即使负载电流非常小，也会强制FET导通，最大程度地减小输入与输出之间的压降。工作在最低压差时的潜在问题是，驱动稳压器输出FET的栅极驱动电路将消耗较大电流。使得“待机模式”变为“电池快速放电模式”。 即使很好的IC设计，静态电流在最低压差条件下增大的现象也并不罕见。小压差下的电源电流提高2倍很常见，有些设计甚至增大10倍或更多。有些器件在EC表或静态电流与输入电压关系的典型工作特性曲线中给出压差与电源电流的对应关系。但更多情况下，数据手册给出的是叫高压差下的电源电流。 对于具体应用，如果低压差条件下的静态电流非常重要，应选择提供该信息的LDO，或者进行实际测量，确定性能满足要求。 负载瞬态响应负载快速变化期间，多数稳压器都具备一定的能力使输出保持在稳压范围内。负载变化时，输出FET栅极驱动需要随之变化。而栅极驱动达到新水平所需的时间决定了输出电压的瞬态下冲或过冲。 满载时的快速瞬变会造成最差情况下的瞬态下冲。选择稳压器之前，须务必检查瞬态响应。与从1%满载作为初始条件相比，从10%满载开始通常会给出更好的结果；因为10%负载预偏置与1%负载预偏置相比，输出FET栅极电压更接近其最终值。负载从空载变为满载，要想获得较好的负载瞬态响应比较困难。 保证稳压器输出负载最小在一定程度上可以规避大的负载瞬变，但这不是有效的解决方案。当稳压器从满载跃变到轻载时，往往会发生输出过冲。而稳压器从过冲状态恢复的过程中，器件处于比较敏感状态 —— 此时的输出FET完全没有偏置。这种状态下，如果出现另一次负载阶跃，输出则出现下冲，比第一次更为严重。 如果存在任何快速开启、关断负载的情况，最好在类似条件下检查每个稳压器的负载瞬态响应。(图3)所示为双脉冲负载瞬变期间的性能。 功能需求使能输入：LDO使能电平高低用于启动或关断LDO。使能输入允许外部控制LDO的关闭和启动，这是多电压轨系统中调整电源上电顺序的一个重要特性。 软启动：可编程软启动有助于减小启动时的浪涌电流和提供上电顺序。对于启动时要求浪涌电流受控的应用，有些LDO提供了可编程的软启动（SS）功能。为了实现软启动，在SS和地引脚之间需要连接一个小的陶瓷电容。 选型细节输出可调型号LDO，FB电阻需靠近芯片且在电容之后，还需确认规格书对阻值的要求。一般电阻越小抗干扰性越强，但是取样电阻上的损耗会增大，加大电阻可能导致输出电压不稳定。 LDO输出稳定性：LDO是负反馈系统，Vin和Vout 上的电容值及电容的ESR都会影响系统的稳定性，最主要是ESR。LDO规格书都会列出对输入电容Cin和输出电容Cout及其ESR的要求，一定要严格遵守。LDO的Cin和Cout都会在1uF以上，ESR越低越好，最好低于100mΩ。 LDO输出端接有其它电压源时需要考虑LDO内部MOS的体二极管，需要选防倒灌的型号。 自放电功能：LDO关闭后，负载电容上仍然有电量，在下次输出时会因为这个电量产生一个快速Voltage Spike。虽然幅度不高，但是对后级电路具有破坏性。带自放电功能的LDO在关闭输出后，泄放输出电容上的电量。 重要参数：PD（Power Disspation，耗散功率）：LDO通过PD可以计算出在常温环境中的最大电流输出能力。 比如某一LDO输入5V输出3.3V，在25°C环境下PD=0.43，该LDO在常温25°C环境下最大电流输出能力为$0.43/(5-3.3)=253mA$ Dropout Voltage（最小压降） Quiescent Current（静态电流）：休眠阶段电源消耗成为影响电池寿命的关键因素，想降低睡眠期间的功率消耗，需要选择具有极低静态电流的器件。IQ受温度和输入电压的影响较为明显。 PSRR（Power Supply Ripple Rejection，电源抑制比）：在射频设计中，对电源纹波极为敏感，需要考虑低噪声LDO，PSRR量化了对不同频率输入电源纹波抑制能力，反映了LDO不受噪声和电压波动，保持输出电压稳定的能力。 PSRR = 20log(\frac{V_{outNoize}}{V_{inNoize}})Load Transient Response（负载瞬态响应）：负载电流变化时，输出电压的变化率。与输出端电容值、电容的ESR、LDO控制环路的增益带宽以及负载电流变化的大小和速率有关。LDO是一个负反馈汇率，相位裕量越大，负载瞬态响应越好。 Line Transient Response（线路瞬态响应）：当Vin阶跃变化时，Vout的变化情况，输出电压偏差显示了环路带宽和PSRR特性。LTR随负载电流增加而变差，因为LDO的总环路增益不断降低。]]></content>
      <categories>
        <category>EMBEDDED</category>
      </categories>
      <tags>
        <tag>HARDWARE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[晶体管入门]]></title>
    <url>%2F2021%2F01%2F12%2FTransistor%2F</url>
    <content type="text"><![CDATA[PN结简介 在硅、锗、砷化镓等具有共价键的本征半导体材料中，使用特殊工艺（高温扩散、离子注入等）掺杂一定浓度的其它特定原子，在不破坏元半导体共价键的的情况下，使杂质在晶格的某些位置上替代原来材料的原子。因为原晶体共价键结构的存在，以及杂质原子与晶体原子的自有电子数目不相等，那么在形成共价键后，杂质原子就会多出自由电子或者被共价键牵引而缺少自由电子（空穴）。整个材料特性在外接呈电中性，但是因为自由电子以及空穴的存在，电子为多子的成为Negative型半导体，空穴为掺杂材料的称为Positive型半导体。 将P型半导体和N型半导体进行原子级结合就形成PN结，因P型半导体中的空穴、N型半导体中的电子互相“渗透”会形成接触电场，方向从N到P。所以PN结能够呈现出单向导电性，也由于接触电场的存在，会在结上形成一个固定压降。 上图为PN结伏安特性曲线，V1为反向击穿电压，在V1时导通电阻很小，击穿后电流不加以限制容易烧毁二极管，V1的电压他笑可以通过半导体加工工艺来改变。 反向击穿PN结反向击穿分为齐纳击穿和雪崩击穿。 齐纳击穿：在掺杂浓度较高的条件下，PN结宽度很小，较小的反向电压就可以形成很强的结内反向电场。若电场强度超过 $10^{+6}V/m$ 时，有些共价键上的电子会被电场力拉出，载流子迅速增加。其击穿与电流的关系不大，也就是说电压较稳。 雪崩击穿：在PN结宽度较宽时，较高的反向结电压还不能产生过强的结内电场，但是由于载流子穿过结的路程比较长，不断被电场加速，将其它价电子撞出了共价键，产生新的电子-空穴对，这些载流子又去撞击其它共价键不断产生链式反应，最后导致PN结反向电流剧烈增加。 一般对于反压小于4V的称为齐纳击穿，反压大于7V的称为雪崩击穿，两者之间两种模式可能同时存在。只要有外界电流限制，两种模式都不会损坏PN结。 双极性三极管（Bipolarity Junction Transistor）J-FET常用参数 双极性三极管是否可以互换发射极和集电极 看似对称设计的双极性三极管其实在制作工艺上是区分发射极和集电极的。 并且【为了优化性能】，BJT的CE掺杂浓度是不同的。CE互换的话beta值会下降很多，是否互换需要看BJT在电路中的作用。 何为优化性能？CE掺杂浓度为何不同？ 下图显示了存在于正偏架构的PNP型BJT的电流分量。 可以明显看出，从发射机注入的hole电流，将分成两个部分。 由于base为N掺杂，所以当hole流经base的时候，将会有电子空穴对复合产生，消耗空穴电流。 电流最终由发射极注入集电极的空穴电流 同时可以看到从base流向发射极的电子电流，这也是发射极电流的一个来源（总发射极电流 $I_e = 1 + 2 + 5$ ） 3电流是集电极和base之间PN junction的反偏漏电流，如果制程正常的话数值不会很大。 现在考虑发射极的情况。发射极电流的组成有两种，包括发射极空穴电流1+2以及发射极电子电流5。我们可以利用突变PN junction假设和junction law，得到以下的近似：Iep = 1+2 ∝ Ien = 5 ∝很显然，为了让“有用”的电流尽量大，也就是让 Iep&gt;&gt;Ien，一个通常的做法就是是的Nd&lt;&lt;Na，也就是说，发射极的掺杂浓度要远高于base才可以实现较高的放大系数。 实际的BJT掺杂如下所示： 可以看到在emitter-base的PN结确实是发射极的掺杂浓度将高于base。同时我们注意到，出于设计上的考量，量产化的BJT的集电极的掺杂浓度一般是比较低的。甚至将低过base。如果如题主所述，将E和C调换使用，其造成的结果就是最终可以利用到的电流量将会大大减少，甚至会使得整个管子失去了放大的特性。 三极管的贝塔值主要取决于基区复合率：NPN管正置时，发射结放”水”，集电结吸“水”，由于集电结面积大且电场强，故吸的快，并且水量巨大，来势汹涌（发射区重掺杂），电子在基区停留时间很短，复合率低，贝塔大。倒置时，集电结放水，发射结吸水，由于违背了设计初衷，一方面水流小且慢（集电区轻掺杂），像快干涸的小溪，另一方面发射结电场弱吸力不够，导致基区电子运动缓慢，复合率高，贝塔小。 场效应晶体管（Field Effection Transistor）晶体管（Transistor）英文里的原意应是跨阻器，是跨越、变阻器这两个词的缩写： Transistor. This is an abbreviated combination of the words “transconductance“ or “transfer”, and “varistor“. The device logically belongs in the varistor family, and has the transconductance or transfer impedance of a device having gain, so that this combination is descriptive. ​ — Bell Telephone Laboratories — Technical Memorandum (May 28, 1948) 场效应管根据结构的不同分为：结型场效应管（JFET）和绝缘栅型场效应管（JGFET）。在绝缘栅型场效应管中应用最广泛的是MOSFET（Metal Oxide Semiconductor FET，金属-氧化物-半导体场效应管）。此外还有PMOS、NMOS、VMOS功率场效应管，以及刚问世的πMOS场效应管、VMOS功率模块等。 MOSFET的构造 MOSFET的核心是位于中央的MOS电容，左右两侧是它的源极与漏极。源极与漏极的特性必须同为N或P。 图中NMOS的源极与漏极上标示的「N＋」代表着两方面涵义：（1）N代表掺杂（doped）在源极与漏极区域的杂质极性为N；（2）「＋」代表这个区域为高掺杂浓度区域（heavily doped region），也就是这个区域的电子浓度远高于其他区域。在源极与漏极之间被一个极性相反的区域隔开，也就是所谓的基极（or基体）区域。 对这个NMOS而言，真正用来作为沟道、让载流子通过的只有MOS电容正下方半导体的表面区域。当一个正电压施加在栅极上，带负电的电子就会被吸引至表面，形成沟道，让N型半导体的多数载流子—电子可以从源极流向漏极。如果这个电压被移除，或是放上一个负电压，那么沟道就无法形成，载流子也无法在源极与漏极之间流动，也就是可以透过栅极的电压控制沟道的开关。 假设工作的对象换成PMOS，那么源极与漏极为P型、基体则是N型。在PMOS的栅极上施加负电压，则半导体上的空穴会被吸引到表面形成沟道，半导体的多数载流子—空穴则可以从源极流向漏极。假设这个负电压被移除，或是加上正电压，那么沟道无法形成，一样无法让载流子在源极和漏极间流动。 体二极管 如图所示，P-Base与Source电极相连。反向电流可以从Source流入P-Base，通过PN结（P-Base/N-Dift）流入Drain。这个PN结就是MOSFET中的Body diode。其作用是导通电感负载传导来的反向电流（ H-bridge，half bridge or many other bridges）。值得注意的是，当P-Base与Source电极相连可以阻止parasitic NPN transistor的形成（N+／P-Base／N-Drift），使MOSFET工作在可控的状态。 MOSFET的主要参数 使用MOSFET应该考虑的问题 正确的参数选择和计算 防静电操作：MOSFET栅源之间距离很短，又绝缘，很少量的电荷就足以将绝缘栅击穿而使mos管损坏。在电路调试、焊接、安装过程中，一定要严格按照防静电程序操作。 散热：大功率MOSFET需要注意散热问题 电场干扰：高频应用场合的MOSFET，由于GS间阻抗极高，对电场干扰十分敏感，若使用高频MOSFET作为高频前端放大器，电路一定要设计良好的电场屏蔽结构。 BJT和FET的区别 参与导电过程 BJT有两种载流子参与导电过程，多子是电子，少子是空穴（以NPN为例）。少子容易受温度影响，热稳定性差。 FET只有一种载流子参与导电，也称为单极性管，受温度影响较低，热稳定性好 BJT输入输出回路都有电流参与，功耗较大。FET只有一个回路参与导电，功耗较低。 三极管属于电流控制器件，有输入电流才会有输出电流； 场效应管属于电压控制器件，没有输入电流也会有输出电流。 信号源小电流用场效应管，反之用BJT。 BJT输入阻抗小，FET输入阻抗大 FET频率特性不如三极管 FET噪声系数小，适用低噪声放大器的前置 FET最小可制作纳米级 扩展：手工制作锗晶体管]]></content>
      <categories>
        <category>EMBEDDED</category>
      </categories>
      <tags>
        <tag>HARDWARE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运放入门]]></title>
    <url>%2F2021%2F01%2F11%2FOPA1%2F</url>
    <content type="text"><![CDATA[第一节 基础知识什么是OPA？OPA，Operational Amplifier，运算放大器。主要有同相输入端、反向输入端和输出端构成。 理想OPA： 输入阻抗无穷大 输出阻抗为零 带宽无穷大 开环增益无穷大 没有DC/AC误差 OPA内部构成 运放常用封装有DFN、CSP等小封装和BT封装形式。 运放基本作用 小信号放大 阻抗匹配 信号隔离 滤波（低通滤波、高通滤波、带通滤波） 驱动 做小功率电源 OPA的供电 单电源供电系统使用LDO给OPA供电 双电源系统，负压。LDO可选型号较少，一般用电荷泵负压芯片产生，输出务必做好滤波处理。 如果使用DC-DC供电，系统噪声是很难处理的。 运放分类 超低功耗运放 低功耗运放 高速运放 高精度运放 低噪声运放 差分放大器 功率放大器 音频放大器 仪表放大器 其它专用放大器 轨对轨运放： 所谓轨对轨运放指的是放大器输入和输出电压摆幅非常接近或几乎等于电源电压值。 轨对轨意思是，可以最大限度的输出信号，接近于电源的电压。 不是所有的rail2rail运放输入和输出都接近电源，有的只是输入、有的只是输出。当然也有输入输出都是rail2rail的，该类运放的最大特点就是可以扩展信号的电压范围，但一般输出电流比较小，在大电流情况下并不能保证rail2rail。 在低电源电压和单电源电压下可以有宽的输入共模电压范围和输出摆幅。 轨对轨输入输出的运放，耗电相对来说一般比较小。 运放常用参数 输入失调电压（Input Offset Voltage）Vos 输入失调电压温漂（Offset Voltage Drift） 输入偏置电流（Input Bias Current）IB 输入失调电流（Input Offset Current）Ios 共模电压输入范围（Input Common-Mode Voltage Range）Vcm 输出特性（Output Characteristics） 输出电流限制（Short Circuit Limit） 工作电压范围 VDD 静态工作电流（Quiescent Current）Iq 增益带宽积（Gain Bandwidth Product）GBP 压摆率（Slew Rate）SR 开环增益（Open-Loop Voltage Gain）Aol 电压噪声密度（Voltage Noise Density）en 相位裕度（Phase Margin） 共模信号抑制比（Common Mode Rejection） 电源纹波抑制比（Supply Voltage Rejection） 虚短和虚断 虚短：负反馈环路下，同向输入端与反向输入端电压基本相当。就像短路一样 虚断：负反馈环路下，通向输入端和反向输入端流入运放内部的电流非常小。就像断路一样。 用万用表测量同向端和反向端电压是没有办法测量运放的，万用表是用电阻分压的方式来测量待测点的电压的，电表流入电阻网络的电流是远远大于pA级的。万用表会成为一个负载，会分掉相当一部分的电压，所以测到同向端和反向端电压是不同的。用万用表测量的时候也引入了相当一部分的干扰，输出信号就偏离更多。 测量的话可以用示波器，把示波器设置为衰减10倍。衰减10倍之后输入阻抗会比运放的输入阻抗不在一个级别上，这时候可以看到同向端和反向端电压是很近似的。 运放的选择直流信号 输入失调电压 温漂 输入失调电流 耗电要求 工作电压 输入输出特性 交流信号 交流信号频率 增益带宽 开环增益 电压噪声密度 耗电要求 工作电压 输入输出特性 直流首先分析信号的特性。 原信号输出，比如直流信号，那么就要考虑原信号的输出阻抗有多大、带载能力有多大。带载能力很小就说明输出阻抗越小，运放的输入阻抗要远高于原信号的输出阻抗。如果他们在同一个级别，那么运放的输入偏置电流对原信号影响会非常明显，那么采集的信号和实际采集信号就像差很远了 输入失调电压是叠加在输入信号上的，正负都可能，要考虑对原直流信号的影响。输入失调信号一定要在待处理信号的 1/10 以内。输入失调电压越小，运放价格越贵。 其它 纯电池系统考虑耗电要求 交流首先考虑信号特性 交流信号的频率、幅值、以及后续的采集电路所要识别的电压，比如计算放大倍数。1mV、1kHz、采集系统识别1V。意味着需要放大1000倍，那么增益带宽积已经在1MHz了。那么选增益带宽积在1MHz的运放差不多可以满足了。但是收到开环增益、压摆率等等的要求，实际上选择运放的时候还需要乘以一个系数。 信号频率 * 放大倍数 * N \le GBP，N=[5,10]，N最小不小于3 对电压噪声的有要求的电路，比如音频电路。（手机靠近音响的高频噪声，没有音响输入时音响的低频噪声），一定要考虑电压噪声密度。需要选电压噪声密度比较小的运放。 电源系统 电池系统电压不高，选运放首选轨对轨输入输出的，要保证输入幅值的动态范围。采用电荷泵的方式产生负压，成本较高。在考虑工作电压，需要考虑低压供电选择轨对轨输入输出的。如果不是轨对轨输入输出，动态范围比较小，比如LM1358，5V供电输入动态范围只到3.5，电压再高的话就会被钳位掉，交流信号的话会被削顶或者削底。 第二节 运放基本参数（以AD8551为例）AD8551.pdf Input Offset Voltage &amp; Drift输入失调电压Vos及其温漂 将运放两个输入端接地，理想运放输出为0，但是实际运放输出不为0。将输出增益除以增益得到的等效输入电压称为输入失调电压。 一般定义为：运放输出为零时，两个输入端之间所加的补偿电压。该值反映了运放哪部对称性，对称性越好，输出失调电压越小，运放精度越高，价格也越贵。 图中为一定数量的运放在一定温度和某一确定Vcm下芯片漂移个数，整体呈高斯分布，大部分在典型值附近。 在设计的时候参数以 全温度下的最大值 作为考量，因为我们不知道我们的产品工作在什么样的环境。我们用温漂（温度系数）来表示在温度下Vos的变化，作为输入失调低钠呀的补充，便于计算在给定的工作范围内，放大电路由于温度变化造成的输入失调电压漂移大小。 Input Bias Current &amp; Input Offset Current输入偏置电流和输入失调电流 定义为当运放输出的直流电压为零时，运放两输入端流进或流出直流电流的平均值。 影响：对原信号影响，原信号输出电流有一部分进入运放，如果 $I_b$比较大，对原信号影响比较大。$I_b$ 一般受制于工艺，CMOS、FET一般能做到pA级。输入偏置电流对进行高阻信号放大、积分电路等对输入阻抗有要求的地方有较大影响。输入偏置电流与制造工艺有一定关系。 Ib 和 Vos 等效示意图，Vos可能为正也可能为负，如果为正值，就是在原信号叠加的值，负值就是在原信号减去一个值。运放其实都是线性的，但是由于Vos存在，在时间轴上就会出现一个偏移。 Ib 受温度影响比较明显，是需要重点考虑的参数。 输入失调电流 Ios：是对Ib的补充，当运放的输出直流电压为0时，其两输入端偏置电流的差值。输入失调电流同样反应了运放内部的电路对称性，对称性越好输入失调电流越小。 Input Common-Mode Voltage Range共模电压输入范围Vcm 运放两输入端与地间能加的共模电压的范围。Vcm 包括正、负电源电压时为理想特性。所谓 “Rail to Rail Input” 就是指输入共模电压范围十分接近电源轨。一般可以低于负电源轨，而稍微低于正电源轨。 输出特性输出动态范围特性 即输出电压范围，所谓轨对轨输出，即输出Voh、Vol极为接近供电轨，但无法等于供电轨，会有十几mV压差，也与负载有关。 输出电流特性 即运放的带载能力，一般会给出Sink、Source电流大，也有运放只给出短路时的极限电流。 Condition：VS = 2.7 V, VCM = 1.35 V, VO = 1.35 V, TA = 25°C, unless otherwise noted. 输出高电平，在100k负载下，输出最小电压在2.685，压降很小很小，不同电压下输出高电平向下拉的电压是不一样的。 输出低电平，在100k负载下，输出最大值在全温度下有10mV的差异。 短路极限电流 10mA 输出带载能力在全温度下 5mA（源电流和灌电流），在设计的时候不能指望这个运放能驱动多大的负载或流进多大的电流。 Slew Rate压摆率（SR） 即转换速率，其定义为：运放接成闭环条件下，讲一个大信号（含阶跃信号）输入到运放的输入端，从运放输出端测量运放输出上升的速率。 由于在转换期间，运放输入级处于开关状态，所以运放反馈回路不起作用，也就是转换速率与闭环增益无关。 压摆率越大，对应运放的带宽就越高。压摆率与增益带积大的所谓的高速运放，对应的压摆率也要很快。上升下降沿的时间会牺牲掉相当大部分的频率时间。 Gain Bandwidth Product增益带宽积（GBP） 单位增益带宽定义为，运放的闭环增益为1倍条件下，将一个恒幅正弦小信号输入到运放的输入端，从运放输出端测得闭环电压增益下降3dB（相当于运放输入信号的0.707）所对应的信号频率。 GBP是在处理交流信号非常关注的一个参数，增益和输入信号频率是相关的，输入信号频率✖️增益受制于GBP这个参数，要远小于GBP。 上图的运放在一倍增益下，最大也就只能处理到1MHz了。 Open-Loop Voltage Gain开环增益（Aol） 定义为当运放工作在线性区时，运放输出电压与差模电压输入电压的比值。 由于差模开环直流电压增益很大，大多数运放差模开环直流电压增益一般在数万倍或更多，用数值直接表示不方便比较，所以一般采用分贝方式记录和比较。 理想运放开环增益为无穷大，实际运放一般在80dB～150dB。 开环增益曲线配和增益带宽积，就可以看出把运放增益设置在哪个范围内是安全的。上图给出的是开环增益、相移和频率的一个关系，当增益过大时，信号相位也会往后有一个偏移。一般设置在左上角三角形区域内比较安全。 Common Mode Rejection共模信号抑制比（CMRR） 共模抑制比定义为当运放工作于线性区时，运放的差模增益和共模增益的比值。即运放两输入端与地之间加相同信号时，输入、输出间的增益称为共模电压增益AVC，则 CMRR = AV/AVC （差模增益/共模增益）。 共模抑制比是一个极为重要的指标，它能够抑制共模输入的干扰信号。值越大，抑制共模干扰能力越强。高精度运放共模信号抑制比很高。 信号处理频率越高，CMRR越小。所以在高频处理中，需要选用CMRR越大的运放。 Power Supply Voltage Rejection电源纹波抑制比（PSRR） 定义为当运放工作于线性区时，运放输入失调电压随电源电压的变化比值。即正、负电源电压变化时，该变化量出现在运放的输出中，并将其转换为运放输入的值。 若电源变化 $\Delta Vs$ 时，等效换算电压为 $\Delta V{in}$ ，则 $PSRR=\frac{\Delta V{s}}{\Delta V{in}}$ 电源电压抑制比反映了电源变化对运放输出的影响。 但是运放的供电还是要求用LDO提供电源，因为LDO输出相对干净很多，但是运放自身也是有抑制能力的，但是不能指望运放自身的抑制能力去对抗电源的变化。 由上图可知，运放对抗高频噪声是比较难的。 Noise Density噪声密度 运放本身内部电路固有的噪声，分为电压噪声和电流噪声。参数越小，运放自身引入到系统的噪声也越小。 通常规格书中用 nV/rtHz 和 pA/rtHz 表示。 参数越小，运放自身引入到系统的噪声也越小。1/f噪声，白噪声，目前的机制尚不了解， 频率越低，噪声指标越高。在1kHz以上，变化就比较小了，而且相对平稳。 极限参数 Supply Voltage Input Voltage Differential Input Voltage（差模，有些运放厂家不会提供） Operating Temperature Range Input Current（输入电流很多厂家会不提供，通向反向端可承受电流的极限值，可能会对保护二极管造成损伤，改变运放的参数） ESD Susceptibility（静电） 第三节 基本运放电路同向输入放大电路 此电路要在双电源供电模式下工作，或者直流信号可单电源供电。在运放内部同向输入端和反向输入端都有一个保护的等效二极管，如果单电源工作模式输入交流信号，同向端输入的交流信号负半周就被削掉了。 共模电压输入范围参数，不是运放在任何供电下的电压范围，而是与供电电压相关的。比如共模电压输入范围[-5,5]，单电源供电模式，负电源轨就是0，可接受电压范围为[0,VCC]。 虚短：V+ = V- 虚断：反馈回路根据基尔霍夫定律列等式 V_-=V_+=V_iV_-=\frac{R_2}{R_1+R_2}V_o由此可得 V_o=(1+\frac{R_1}{R_2})V_i反向输入放大电路 反向输入放大电路就是输出和输入的相位发生180度的变化。 平衡电阻为同向端提供偏置电流回路，阻值要求不严格 运放为双电源工作模式或者单电源工作下输入信号为直流信号 V_- = V_+ = 0由此可得： V_o = V_i*(-\frac{R_2}{R_1})差分输入放大（减法器）电路输入信号通常来自低阻抗源，因为该电路的输 入阻抗由电阻网络决定。通常使用差分放大器来放大差分输入信号并抑制共模电压。共模电压是两个输入共 用的电压。差分放大器抑制共模信号功能的有效性称为共模抑制比 (CMRR)。差分放大器的 CMRR 取决于 电阻器的容差。 差分输入放大电路对运放的要求比较高，尤其是对共模输入抑制比比较高。因为外围电阻精度如果不匹配的话，那么会影响到CMRR。运用差分输入放大电路时，一定要选择高精度电阻。 运用音频系统、High-side电流检测电路、芯片信号检测、心率信号检测等 电流检测集成芯片内部电阻精度可以做到万分之一，而在外面设置的电阻通常是选择1%的。差分放大电路成本较高，在电流检测电路运用比较少，往往选择集成芯片。 跟随器/射随器 $R_f$ 对实际应用影响很小，k级电阻，电阻过大的话会引入电阻的热噪声。 输入端电阻不仅仅是平衡电阻，对运放输入也是一个保护，可以衰减电流，抗浪涌。限制输入电流，防止接入信号瞬间产生的浪涌电流偏大。 相比同向放大电路，反向端没有对地的电阻了。 I-V转换电路光敏二极管在光照会产生微弱的电流，计算这个电流有两种做法： 在二极管输出之后挂一个对地电阻，把电流转换成电压。但是劣势很明显，在电阻阻值的选择上，小电阻输出电流带不动，而电阻大的时候，引入的噪声也特别大。 所以一般在处理光敏二极管，用一个运放做I-V转换，靠反馈回路的 $R_F$ 电阻，把电流转换成电压输出。 这里对运放也是有要求的： $V_{OS}$ 会叠加在输出上，要小 $I_B$ 会叠加在输出上，要小 运放的输入偏置电流 $IB$ 和输入失调电压 $V{os}$ 对输出电压的影响分别为：$IB*R_F$ 和 $V{os}*(1+\frac{R_F}{R_S})$，$R_S$ 为光敏管内阻。 故需要选择偏置电流和失调电压均很低的运算放大器。 可以单电源供电，输出为正值。 电容起滤波和稳定运放（相位补偿）的作用。 同相加法电路（求和电路）应用：多路音源的叠加 做加法电路的时候很少会引入增益。 反相加法电路 一阶低通滤波电路 -3dB截止频率都是 $\frac{1}{2\Pi RC}$ 同相输入电路可以同时加入放大 反向输入电路有争议，大部分时候会把 $C_F$ 当作相位补偿电容，防止运放震荡。 运放的输入电容、分布电容都会导致相位的滞后，当相位滞后达到一定程度时，就会导致输出的是一个震荡的信号。所以加入一个反馈补偿电容的方式，来破环震荡条件。 很多高阶滤波电路的电阻选择都是非标值，比较复杂，不利于生产。 二阶低通滤波 压控电压源电路和无线增益多路反馈电路。建议用网络提供的工具来直接计算 一阶高通滤波电路把电容和电阻位置对掉一下。 低阶滤通转折很平缓，和理想的滤通还是有差距的。]]></content>
      <categories>
        <category>EMBEDDED</category>
      </categories>
      <tags>
        <tag>HARDWARE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux思维导图整理复习总结]]></title>
    <url>%2F2019%2F09%2F02%2FLinux_xmind%2F</url>
    <content type="text"><![CDATA[思维导图工具——MindNode 学习结构 Linux文件、目录、和磁盘格式 Shell与Shell Script]]></content>
      <tags>
        <tag>IT</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Daenerys Targaryen - The Queen]]></title>
    <url>%2F2019%2F08%2F29%2FDaenerys-Targaryen%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/Daenerys1.mp4","pic":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/2019-08-28%2F1566927552.png"},"danmaku":{"id":"Khaleesi","api":"https://dplayer.moerats.com/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>Share</tag>
        <tag>Inspirational</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析中的MySQL]]></title>
    <url>%2F2019%2F08%2F21%2FMySQL-dataanalysis%2F</url>
    <content type="text"><![CDATA[MySQL简单总结条件查找123456select * from dataAnalystwhere (city = &apos;上海&apos;and education = &apos;本科&apos;)or (city = &apos;北京&apos;and education = &apos;硕士&apos;) 1234567891011select * from dataAnalystwhere (city = &apos;上海&apos;and education = &apos;本科&apos;)or workYear = &apos;1-3年&apos;# 翻译：上海和本科同时满足，或者只满足workyearselect * from dataAnalystwhere city = &apos;上海&apos;and (education = &apos;本科&apos;or workYear = &apos;1-3年&apos;)# 翻译：上海的，学历或者工作经验满足 模糊查找1234567select * from dataAnalystwheresecondType like '%开发%'select * from dataAnalystwheresecondType like '后端%' Groupby12select city from dataAnalystgroup by city 123456select city,count(positionId) from dataAnalystgroup by city # count(positionId) = count(1) = count(*) # 对于包不包含控制计算有细微差异select city,count(1),count(*) from dataAnalystgroup by city 去重复——DISTINCT12select city,count(positionId),count(distinct companyId) from dataAnalystgroup by city 12select city,education,count(1) from dataAnalystgroup by city,education Having1234# having 就是对groupby进行过滤的select city,education,count(1) from dataAnalystgroup by city,educationhaving count(positionId) &gt;= 100 Like12345# 获取字段含有“电子商务”的用likeselect city,count(1) from dataAnalystwhere industryField like &apos;%电子商务%&apos;group by cityhaving count(positionId) &gt;= 50 count if1234# 这里只输出城市（嵌套查询）select city from dataAnalystgroup by cityhaving count(if(industryField like &apos;%电子商务%&apos;,1,null)) &gt;= 50 不同城市下面电商占这个城市的招聘人数的占比并过滤大于10 1234567select city,count(1),count(if(industryField like &apos;%电子商务%&apos;,industryField,null)),count(if(industryField like &apos;%电子商务%&apos;,industryField,null))/count(1)from dataAnalystGROUP BY cityhaving count(if(industryField like &apos;%电子商务%&apos;,industryField,null)) &gt;= 10ORDER BY count(if(industryField like &apos;%电子商务%&apos;,industryField,null)) 优雅的写法——As 1234567select city,count(1),count(if(industryField like &apos;%电子商务%&apos;,industryField,null)) as emarket,count(if(industryField like &apos;%电子商务%&apos;,industryField,null))/count(1)from dataAnalystGROUP BY city having emarket &gt;= 10ORDER BY emarket desc SQL函数left和locate和right1select left(salary,locate(&apos;k&apos;,salary)-1),salary from dataAnalyst 1234567select left(salary,locate(&apos;k&apos;,salary)-1),locate(&apos;-&apos;,salary),length(salary),left(RIGHT(salary,length(salary)-locate(&apos;-&apos;,salary)),length(salary)-locate(&apos;-&apos;,salary)-1),salarysalary from dataAnalyst substr substr(字符串，从哪里开始，截取长度) 1234select left(salary,locate(&apos;k&apos;,salary)-1),substr(salary,locate(&apos;-&apos;,salary)+1,length(salary)-locate(&apos;-&apos;,salary)-1),salary from dataAnalyst 子查询 基于查询结果的查询，嵌套查询 123456select (bottom + top)/2 from(select left(salary,locate(&apos;k&apos;,salary)-1) as bottom,substr(salary,locate(&apos;-&apos;,salary)+1,length(salary)-locate(&apos;-&apos;,salary)-1) as top,salary from dataAnalyst) as t 分组——case when 主要用来数据清洗 12345678910111213select case when (bottom+top)/2 &lt;= 10 then &apos;0-10&apos; when (bottom+top)/2 between 10 and 20 then &apos;10-20&apos; when (bottom+top)/2 &lt;= 30 then &apos;10-30&apos; else &apos;30+&apos; end, salary from( select left(salary,locate(&apos;k&apos;,salary)-1) as bottom, substr(salary,locate(&apos;-&apos;,salary)+1,length(salary)-locate(&apos;-&apos;,salary)-1) as top, salary from dataAnalyst) as t 过滤——where in1234select * from dataAnalystwhere city in(select city from dataAnalystgroup by city having count(positionId) &gt;= 100) 多表聚合查询——Join 某一个公司招聘职位，在另一个表中查找信息 12345select * from dataAnalystwhere companyId = (select companyId from companywhere companyShortName = &apos;唯医网&apos;) 连结两张表1234567select * from dataAnalyst ❌join company on companyId = companyId ❌# 没结果，因为companyId不唯一#正确写法select * from dataAnalyst as djoin company as c on d.companyId = c.companyId 左连接 保留左边，右边硬凑，没有就null 1234select * from dataAnalyst as dleft join(select * from companywhere companySize = &apos;150-500人&apos;) as ton t.companyId = d.companyId join就是取交集，left join就是A是全部B是部分 123456# 排除法统计select * from dataAnalyst as dleft join(select * from companywhere companySize = &apos;150-500人&apos;) as ton t.companyId = d.companyIdwhere t.companyId is null # 过滤重复的部分 150-500人的占比 1234select count(1),count(t.companyId),count(t.companyId)/count(1) from dataAnalyst as dleft join(select * from companywhere companySize = &apos;150-500人&apos;) as ton t.companyId = d.companyId LeetCode——训练刷题时间1select now() 1234select paidTime,date(paidTime),date_format(paidTime,&apos;%Y-%m-%d&apos;),date_format(date_add(paidTime,interval -1 day),&apos;%Y-%m-%d&apos;)from orderinfo 练习题 统计不同月份的下单人数统计用户三月份的回购率和复购率统计男女用户的消费频次是否有差异统计多次消费的用户，第一次和最后一次消费间隔是多少?统计不同年龄段，用户的消费金额是否有差异?统计消费的二八法则，消费的top20%用户，贡献了多少额度 统计不同月份的下单人数1234select month(paidTime),count(distinct userId)from orderinfowhere isPaid = &apos;已支付&apos;GROUP BY month(paidTime) 统计用户三月份的回购率和复购率123456# 统计用户三月份的复购率select count(ct),count(if(ct&gt;1,1,null)),count(if(ct&gt;1,1,null))/count(ct) from( select userId,count(userId) as ct from orderinfo where isPaid = &apos;已支付&apos; and month(paidTime) = 3 group by userId) as t 不是很好的方法： 1234567891011# 统计用户三月份的回购率SELECT count(DISTINCT userId) from orderinfowhere userId in ( select userId from orderinfo where isPaid = &apos;已支付&apos; and month(paidTime) = 3)and month(paidTime) = 4select count(DISTINCT userId) from orderinfowhere isPaid = &apos;已支付&apos;and month(paidTime) = 3 首先查找出userId在每个月份的支付情况 123select userId,date_format(paidTime,&apos;%Y-%m&apos;) as m from orderinfowhere isPaid = &apos;已支付&apos;GROUP BY userId,date_format(paidTime,&apos;%Y-%m&apos;) 然后左连接两张相同的表： 123456789select * from( select userId,date_format(paidTime,&apos;%Y-%m&apos;) as m from orderinfo where isPaid = &apos;已支付&apos; GROUP BY userId,date_format(paidTime,&apos;%Y-%m&apos;)) t1left join( select userId,date_format(paidTime,&apos;%Y-%m&apos;) as m from orderinfo where isPaid = &apos;已支付&apos; GROUP BY userId,date_format(paidTime,&apos;%Y-%m&apos;)) t2on t1.userId = t2.userId 此时得到的是两张表的笛卡尔积（左连接非唯一字段，是局部笛卡尔积。） 然后增加条件筛选，此时添加了非唯一条件，笛卡尔积自动去除 1234567891011可以统计所有的月份：select t1.m,count(t1.m),count(t2.m),count(t2.m)/count(t1.m) from( select userId,date_format(paidTime,&apos;%Y-%m-01&apos;) as m from orderinfo where isPaid = &apos;已支付&apos; GROUP BY userId,date_format(paidTime,&apos;%Y-%m-01&apos;)) t1left join( select userId,date_format(paidTime,&apos;%Y-%m-01&apos;) as m from orderinfo where isPaid = &apos;已支付&apos; GROUP BY userId,date_format(paidTime,&apos;%Y-%m-01&apos;)) t2on t1.userId = t2.userId and t1.m = date_sub(t2.m,interval 1 month)GROUP BY t1.m 统计男女用户的消费频次是否有差异平均数12345678select sex,avg(ct) from ( select o.userId,sex,count(1) as ct from orderinfo as o inner join( select * from userinfo where sex is not null) t on o.userId = t.userId group by userId,sex) t2group by sex 统计多次消费的用户，第一次和最后一次消费间隔是多少?1234select userId,datediff(max(paidTime),min(paidTime)) from orderinfowhere isPaid = &apos;已支付&apos;group by userId having count(1) &gt; 1# datediff把秒数变成天数 统计不同年龄段，用户的消费金额是否有差异?年龄除10然后取整数 123456select o.userId,age,count(o.userId) from orderinfo oinner join( select userId,ceil((year(now())-year(birth))/10) as age from userinfo where birth &gt; &apos;1900-00-00&apos;)ton o.userId = t.userIdgroup by o.userId,age 平均数 12345678select age,avg(ct) from ( select o.userId,age,count(o.userId) as ct from orderinfo o inner join( select userId,ceil((year(now())-year(birth))/10) as age from userinfo where birth &gt; &apos;1900-00-00&apos;)t on o.userId = t.userId group by o.userId,age)t2group by age 统计消费的二八法则，消费的top20%用户，贡献了多少额度先统计总人数 12345select count(userId)*0.2 from(select userId,sum(price) as total from orderinfo owhere isPaid = &apos;已支付&apos;group by userIdorder by total desc)as t 统计贡献 123456select count(userId),sum(total) from( select userId,sum(price) as total from orderinfo o where isPaid = &apos;已支付&apos; group by userId order by total desc limit 17000)t SQL连接PowerBI]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Data Analysis</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一天入门数据分析]]></title>
    <url>%2F2019%2F08%2F20%2Fintroduction-to-data-analysis%2F</url>
    <content type="text"><![CDATA[一、数据分析框架——15分钟七门课程 数据思维 业务知识 Excel 数据可视化 SQL 统计学 Python 分析师既可以用Excel完成一份最基础的数据报告，也能用Python深入挖掘 真正决定数据分析师上限的是能力，而不是工具 数据分析是解决问题的，锻炼出解决问题的思路框架，奠定能力发展的基础 二、数据分析思维——2小时1. 三种核心思维 结构化 公式化 业务化 结构化思维 现在有一个线下销售的产品。我们发现8月的销售额度下降，和去年同比下降了20%。我想先观察时间趋势下的波劢，看是突然暴跌，还是逐渐下降。再按照丌同地区的数据看一下差异，有没有地区性的因素影响。我也准备问几个销售员，看一下现在的市场环境怎么样，听说有几家竞争对手也缩水了，看一下是丌是这个原因。顾客访谈也要做，但是往常一直找丌出原因，这次我也丌抱希望，姑且试试吧。要是还找丌出原因，那我也很绝望. 思维的缺陷： 想到一点是一点 做假设，但乱打一枪 一次性分析，没有复用性 业务看了会流泪，老板看了想打人 还是没结果 将分析思维结构化 将论点归纳和整理 将论点递迚和拆解 将论点完善和补充 结构化思维： 核心论点：可以是假设、是问题、是预测、是原因 结构拆解：自上而下，将核心论点层层拆解成分论点，上下之间呈因果或者依赖关系 MECE：相互独立、完全穷尽。论点之间避免交叉和重复，分论点尽量完善 验证：论点可量化——用数据说话——可验证性 思维导图式的思维方式 查看资料及背景，将结论列成一张表/卡片 把表上的结论，依据主题分类 将同一类型的结论，按顺序区分 讨论同一级别的共通结论，将其结论放在上一段位置 公式化 业务化如何预估上海地区共享单车投放量？ 单车是有损耗的，计算公式中应该考虑单车的消耗因素 结构化+公式化——理性思考 业务化——感性分析 有没有从业务方的角度思考？ 真的分析出原因了吗？ 能不能将分析结果落地？ 用结构化思考+公式化拆解，获得的最终分析论点。很多时候，是现象。数据是某个结果的体现，但不代表原因。 换位思考也是业务化重要思维。 2. 数据分析的思维技巧七种方法 象限法 假设法 对比法 二八法 指数法 多维法 漏斗法 象限法 核心：象限法是一种策略驱动的思维 应用：适用范围广、戓略分析、产品分析、市场分析、客户管理、用户管理、商品管理等 优点：直观，清晰，对数据迚行人工的划分。划分结果可以直接应用于策略 须知：象限法划分可以按中位数，也可以按平均数，或者经验 多维法 用户统计维度:性别、年龄…用户行为维度:注册用户、用户偏好、用户兴趣、用户流失…消费维度:消费金额、消费频率、消费水平…商品维度:商品品类、商品品牌、商品属性… 假设法 没数据的时候怎么分析 很多时候，数据分析是没有数据可明确参考的:比如新迚入一个市场，公司开拓某样产品。老板让你预测一年后的销量，戒者产品的数据基础非常糟糕，你拿丌到数据。 核心：假设法是一种启发思考驱动的思维 应用：它更多的是一种思考方式，假设——验证——判断 优点：当没有直观数据或者线索分析时，以假设先行的方式进行推断，这是一个论证的过程。 须知：不知可以假设前提，也能假设概率或者比例，一切都能假设，只要能自圆其说。 指数法 中国今年的经济指标如何?美国NBA最佳球星是谁?竞争对手产品表现的如何?哪位是天善学院最帅的男人? NBA比赛数据贡献值: (得分+篮板+劣攻+抢断+封盖)-(出手次数-命中次数)-(罚球次数- 罚球命中次数)-(失误次数/球员上场比赛的场次) 很多时候，我们有数据，但丌知道怎么应用。就是因为缺乏了一个有效性的方向。这个方向可以成为目标指数。通过设置不同的权重，将数据加工成指数，达到聚焦的目的。 指数法举例：反比例： 收敛得更厉害：log/log加线性权重 总结核心：指数法是一种目标驱动的思维 应用：和假设法不同，假设法是缺乏有效的数据，指数法是无法利用数据，指数法是无法利用数据将其加工可利用的。 优点：目标驱动力强，直观、简洁、有效。对业务有一定的指导作用。一旦设立指数，不易频繁变动。 须知：指数法没统一的标准，很多指数更依赖经验的加工。 二八法百分之八十的数据是没有价值的，只有20%的用户才是有价值的 数据中20%的变量将直接产生80%的效果。 持续关注TopN的数据，是一个非常好的习惯 虽然指标很多，但是往往某些指标更有价值，二八法则不仅能分析数据，也能管理数据。 二八法：核心：二八法是一种抓重点的思维 应用：二八法则存在于几乎所有的领域，所以这种分析思维没有局限 优点：和业务紧密相关，和KPI更紧密相关。几乎花费最少的精力就能达到不错的效果，性价比很优 须知：在条件允许的情况下，数据分析依旧不能放弃全局 ，否则会让思路变得狭隘 对比法 节日大促，女生消费占比从60%变为70%，女生节日爱消费 ： 这个结论是有问题的 占比提高了，不代表绝对值提高了。某商品平时销售 额100万女生占60万，节日销售额80万女生占56 万，女生真的消费变高了? 谁说节日销售额会提高？别忘了竞争对手 孤数不证 竞争对手对比 类别对比 特征和属性对比 时间同比环比 转化对比 前后变化对比 对比法：核心：对比法是一种挖掘数据规律的思考方式 应用：对比更多是一种习惯，是数据分析的牛角尖，一次合格的分析，一定要用到N次对比 优点：对比法可以发想很多数据间的规律，它可以与任何思维技巧结合，比如多维对比、象限对比、假设对比等 须知：在条件允许的情况下，数据分析依旧不能放弃全局，否则会让思路变得狭隘。 3. 如何在业务时间锻炼数据分析思维好奇心尿布旁边放啤酒，增加啤酒的销量**是假的**！！ 买了尿布的人会买啤酒，但是买啤酒的人会买尿布么? 尿布旁边应该摆放其他东西么?啤酒是否是最好选择? 怎么摆放啤酒?部分还是全部品类? 场景型的摆放是否比品类摆放更好? 数据呢? 生活中的练习走在夜市： 这个夜市一天的人流量是多少?一年的 人流量又是多少? 「现煮小卷」每天的营业额是多少? 这个夜市，哪家店的利润是最高的?它 比最低的高出多少?原因是什么? 如何从数据分析的角度提高最低店的营业额? 夜店准备弄一次活劢，如何设计一套数 据评估方案评估活劢效果? 工作中： 为什么领导戒者同事丌认同这次分析?原因是什么? 如果我的职位比现在高两级，我会去怎么分析? 让我再次分析一年前做的那个案例，我 会怎么去优化和改迚? 我的历史分析，能用三种核心思维去优化和迭代吗? 三、业务——2小时1. 为什么业务重要？惟有理解业务，才能建立业务数据模型 2. 经典业务分析指标模型未动 ， 指标先行如果你不能衡量它，你就无法增长它 指标可以让老板更好地管理，需要建立分析框架，必须确立好指标 应该选取哪些指标分析： 核心指标 好的指标应该是比率 好的指标应该能带来显著效果 好的指标不应该虚荣 好的指标不应该复杂 2.1 市场营销指标客户/用户生命周期 企业/产品和消费者在整个业务关系阶段的周期。 不同业务划分的阶段丌同。传统营销中， 分为潜在用户，兴趣用户，新客户，老/ 熟客户，流失客户。 用户价值 业务领域千千万万，怎么定义最有效的用户呢?请出指数法，将业务最关注的几个指标一起加工吧。 用户贡献 = 产出量/投入量*100% 用户价值 = (贡献1+贡献2+……) 比如金融行业会以存款+贷款+信用卡+ 年费+……-风险-流失 RFM模型用户生命周期中，衡量客户价值的立方体模型。利用R最近一次消费时间，M总消费金额，F消费频次，将用户划分成多个群体。 用户分群，营销矩阵用户分群是市场营销中的一种常见策略，它提取用户的几个核心维度，用象限法将其归纳和分类。 AARRR框架Acquisition用户获取、Activation用户活跃、Retention用户留存、Revenue营收、Refer传播。 用户获取 渠道到达量: 俗称曝光量。有多少人看到了产品推广相关的线索。 渠道转化率: 有多少用户因为曝光而心 劢Cost Per，包含CPM、CPC、CPS、 CPD、CPT等。 渠道ROI: 推广营销的熟悉KPI，投资回报率，利润/投资*100%。 用户获取 日应用下载量: app的下载量，这里指 点击下载，丌代表下载完成 日新增用户数: 以用户注册提交资料为基准 获客成本: 为获取一位用户需要支付的成本 一次会话用户数占比: 指新用户下载完 App，仅打开过产品一次，且该次使用 时长在2分钟以内。「防止机器人刷单，灰色流量」 用户活跃 日/周/月活跃用户应用下载量:活跃 标准是用户用过产品，广义上，网页浏 览内容算「用」，在公众号下单算 「用」，不限于打开APP。 活跃用户占比:活跃用户数在总用户数的比例，衡量的是产品健康程度 用户活跃： 用户会话session次数: 用户打开产品操 作和使用，直到退出产品的整个周期。5 分钟内没有操作，默讣会话操作结束。 用户访问时长: 一次会话的持续时间。 用户平均访问次数: 一段时间内的用户平均产生会话次数。 用户留存 用户在某段时间内使用产品，过了一段时间后仍旧继续使用的用户。 假设产品某天新增用户1000个，第二天 仍旧活跃的用户有350个，那么称次日 留存率有35%，如果第七天仍旧活跃的 用户有100个，那么称七日留存率为 10%。 营收： 付费用户数: 花了钱的 付费用户数占比: 每日付费用户占活跃用户数比，也可以计算总付费用户占总用户数比 ARPU: 某时间段内每位用户平均收入 ARPPU: 某时间段内每位付费用户平均 收入，排除了未付费的 营收： 客单价: 每一位用户平均贩买商品的金额。销售总额/顾客总数 LTV: 用户生命周期价值，和市场营销 的客户价值接近，经常用在游戏运营电 商运营中。 LTV = ARPU * 1/流失率 传播2.2 用户行为指标用户行为 用户行为的数据分析是一个很广泛的课题，丌同业务领域背景的用户行为分析不一样。 这里简单概括说几个方法。 功能使用 功能使用率/渗透率:使用某功能的用户占总活跃数之比。 比如点赞、评论、收藏、关注、搜索、添加好友，均可以算做功能使用。这些指标在特定业务中均有作用。 用户会话会话session:也叫做session，是用户 在一次访问过程中，从开始到结束的整 个过程。 在网页端，30分钟内没有操作， 默讣会话操作结束。 用户路径路径图:用户在一次会话的过程中，其访问产品内部的浏览轨迹。通过此，可以加工出关键路径转化率。 2.3 电子商务指标购物篮分析 笔单价:用户每次贩买支付的金额，即每笔订单的支出。和客单价对应。件单价:商品的平均价格。 成交率:支付成功的用户在总的客流量中的占比。 贩物篮系数:平均每笔订单中，卖出了多少商品。贩物篮系数是多多益善，它也和商品关联规则有关系。 好基友:复购率和回购率 复贩率是一段时间内多次消费的用户占 总消费用户数乊比。有例如4月有1000 位用户消费，其中500位消费了两次以 上，则复贩率是50%。 回贩率是一段时间内消费过的用户，在 下一段时间内仍旧消费的占比。例如4月 的消费用户数1000，其中600位在5月 继续消费，则回贩率为60%。 2.4 流量指标浏览量和访客量 PV: 浏览次数。互联网早起的统计指标， 用户在网页的一次访问请求可以看作一 个PV，用户看了十个网页，则PV为10。 UV: 是一定时间内访问网页的人数，正式名称独立访客数。在同一天内，丌管 用户访问了多少网页，他都只算一个独立访客。 技术上，UV会通过cookie或IP衡量。 访客行为 新老访客占比: 衡量网站的生命力 访客时间: 衡量内容质量丌是看内容的 UV，而是看内容的访问时间。 新老访客占比: 衡量网站的生命力 来源: 访客从哪里来，技术上，通过来 源网站的参数提取，可以区分SEM， SEO或者外链等。 退出率和跳出率 退出率: 从该页退出的页面访问数/进入该页的访问数。 跳出率: 浏览单页即推出的次数/访问次数。 跳出率一般衡量各个落地页，营销页等页面。退出率则更偏产品，仸何页面都有退出率 2.5 怎么生成指标 访客访问时长 + UV = 重度访问用户占比 浏览时间5分钟以上的用户在整个访客中占比.用户会话次数 + 成交率 = 有效消费会话占比 用户在所有的会话中，其中有多少次有消费? 3. 业务的分析框架3.1 如何建立业务分析框架用指标建立业务分析框架 从指标的角度出发 从业务的角度出发 从流程的角度出发 市场营销模型 对机会客户线性加权的加工： 潜在客户转化率 机会客户转化率 新客付费转化率 不同渠道在新客中的占比 不同渠道在新客中的付费转化率 AARRR模型 二次激活的线性加权加工： 推送激活转化率 有效推送成功率 有效推送到达率 用户打开率 不同推送的转化率 用户行为模型（内容平台） 点赞/评论/收藏的线性加权： 点赞用户活跃占比 评论用户活跃占比 收藏用户活跃占比 内容指数 电子商务模型 购物车的线性加权： 不同商品类别的占比（对比法） 不同价格档次的占比（象限法） 不同商品下单支付率（漏斗法） 流量模型 搜索引擎流量、搜索引擎优化的线性加权 3.2 应对各类业务场景 Step.1 练习Step.2 熟悉业务Step.3 应用三种核心思维Step.4 归纳和整理出指标Step.5 画出框架Step.6 检查、应用、修正Step.7 应用和迭代 //TODO 视频2.30必看 4. 数据化管理业务 四、Excel——2小时（多练习） 不会因为你会Python而成为数据分析师，而是能用任何工具解决问题 1. 为什么用Excel？1.1 Excel的学习路径 Excel保证新版本 培养好的数据表格习惯 主动性搜索 多练习 1.2 Excel的常见函数 文本清洗函数 1 bit = 两种可能性，用0戒1存储1 byte = 8 bit，如00000001，一共有256种可能性1 byte可以存256个字符编码，最初的存储方式ASCII，就存了英文+数字+符号汉字远远大于256种可能性，于是用2byte组合表示，叫做GB2312后来为了表示更多的汉子，用了GBK，它是拓展版，连繁体字都包括了可是中国还有少数民族啊!少数民族的文字怎么办?于是又多了GB18030可是全世界有多少国家多少名族?于是@#¥%……&amp;于是发明了一个万国码，叫做*unicode 字符 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 中 x 01001110 00101101 11100100 10111000 10101101 Find Substitute Left Right Mid(提取需要的部分) Text(转换格式) Concatenate(拼接函数) Trim(规整字符串) Replace(替换函数) Len(长度) //TODO EXCEL操作见`DataAnalyst` 关联匹配函数 Lookup Row Vlookup(另一个表主键匹配添加) Column Index(索引) Offset(偏移) Match(查找相对位置) Hyperlink(超链接) Index和Match联合引用——「Match匹配出来的值的另一列」 逻辑运算函数 条件判断 And Not Or False True IF (加在后面加条件) Is 计算统计函数 Sum Rank(排名) Stdev Sumproduct(累加相乘) Rand RandBetween(随机函数) Substotal Count Average Int(取整) Max Min Quartile(分位数) Round(取整) 时间序列函数 2017/02/27 Year Day Month Date Weekday(判断一周中的周几) Now(返回当前的时间) Weeknum(一年中的第几周) Today(返回当前的日期) 1.3 Excel常见技巧快捷键： Ctrl+方向键 Ctrl+Shift +方向键 Ctrl+空格键 Shift+空格键 Ctrl+A 选择整张表 Alt+Enter 换行 数据类型数据透视表条件格式和迷你图分列数组自定义名称自定义下拉菜单冻结删除重复项分析工具库切片1.4 用Excel进行数据分析现在你有一份的餐食数据，我想通过Excel知道 ： 全国点评数最高的饭店是哪家? 哪个城市的饭店人均口味最好? 哪个类型的餐饮评价最好? 类型为川菜的店中，有多少个带「辣」字，又有多少个带「麻」字? 口味、环境、服务，三个评价都在8.0以上的饭店有几家?它们在哪个城市的占比最多? 上海地区中，各个类型饭店服务前五名? 没有评价的饭店有几家? 将人均价格划分成0~50，50~100，100~150，150~200，200+这几个档次， 各个城市分别有几家?其中占比又是多少? 将点评、人均、口味、环境、服务这几个指标加工出一个综合评价系数，并且计算 哪十家店是最好的(开放题)。 对上海地区的日本料理，做一次描述性分析(开放题) 五、数据可视化——2小时（下载Power BI、熟悉基本操作）1. 数据可视化数据可视化之美 数据可视化 数据可视化的目的是让数据更高效 让读者更高效阅读，而不单是自己使用 突出数据背后的规律 突出重要的因素 最后是美观 只要能从图中看到我所要的规律，那么就是靠谱的 2. 常见初级图表图表的基础概念 散点图 散点图 散点图主要解释数据之间的规律。 维度:0+，作为颜色 度量:2 气泡图 气泡图是散点图的变种，引入了第三个度量作为气泡的大小。 维度:1+，作为颜色 度量:3，其中1个是气泡大小 单轴散点图 维度作Y轴，更倾向于洞 察数据在不同类别下的 数据规律 维度:1+，Y轴 度量:2 客户消费维度 消费金额和消费次数的关系 消费金额和最后一次距今消费天数的关系 消费次数和最后一次距今消费天数的关系 客户其他消费维度 消费金额和消费折扣的关系 消费金额和会员积分的关系 消费次数和会员距离的关系 垂直领域消费维度 投资金额和投资次数的关系(金融) 最近一次距今消费和使用次数(SaaS) 折线图 折线图 折线图经常用来观察数据随时间变化的趋势。 折线图中的维度不宜过多，否则会非常混乱和复杂。 维度:1+ 可对比度量:1+ 时间维度:X轴 面积图 面积图是折线图的变种。 面积图更注重数据类别之间随着时间趋势的变化关系。 维度:1 度量:2 柱形图 柱形图 柱形图是类别之间的关系。 维度:2 度量:1+ 直方图 柱形图的统计型变种。 维度:0 度量:1 饼图 饼图（没什么屁用） 饼图可以理解为环状的 柱形图。 饼图的类别不宜过多。饼图除了PPT， 分析时没啥用。 维度:1 度量:1 漏斗图 漏斗图（也没啥用） 漏斗图是对转化过程的 直观展示。单一的漏斗 图没啥用，也是面向 PPT。漏斗图的转化步 骤不应该超过七个。 维度:1 度量:1 雷达图 雷达图 适用于个体的数据和属 性可视化，比较偏描述性数据，常见于CRM， 用户画像。 维度:1+ 度量:1+ 3. 常见的高级图表树形图 树形图（大数据量） 适合数据量较大的情况， 尤其类别较多。比如各 类电商的SKU ·维度:1+ 度量:1 桑基图 桑基图（网站流量、行为轨迹、活跃状态变化） 桑吉图是揭示数据复杂变化趋势的图表。面积图是线性维度，而桑基图可以一对多或者多对一。 维度:2 source,target 度量:1 热力图 热力图 数据在空间上的变化规律。譬如地理空间，譬如网页浏览 维度:2 度量:1 热力图（github、特殊的时间规律） 空间不一定是纯粹空间，也可以是属性和维度的规律组合，比如把它变成星期表。 维度:1 度量:1 关系图 关系图（社交、「很少用到」） 展现不同类别之间的数据关系，常见于各类社交社会媒体。 维度:2 source target 度量:0+ 箱线图 箱线图（数据的分布规律、统计学） 箱线图是统计用图表，用来研究和观察数据分布，也能对比数据分布。 维度:1+ 度量:1 标靶图 标靶图（销售业绩） 也称为子弹图，是变种的条形图。常用于衡量业务销售完成情况。 维度:1+ 度量:2 词云图 词云图（大数据必备图表） 文本分析利器，PPT常 客，卖弄大数据之必备 图表 维度:1 度量:0 地理图 地理图 数据和空间之间的关系。地理图即可以通过经纬度的数值度量绘制，也能通过省市的类别维度绘制。 维度:1(经纬或行政) 度量:1 4. 图表绘制 //TODO 具体见视频4.47～4.55 5. 可视化BI BI（Business Intelligence）即商务智能，它是一套完整的解决方案，用来将企业中现有的数据进行有效的整合，快速准确地提供报表并提出决策依据，帮助企业做出明智的业务经营决策。它是一种产品/服务，这个产品/服务可能包含报表，分析，管理等等利用计算机和编程技术自动化一些商业过程的行为。 商业智能 BI 就是一个把数据变为信息的过程 —— 将企业中的各个部分、各个业务系统中的数据统一的按照一定规则的抽取、清洗，最后加载到一个统一而集中的数据库中。在这个数据库之上，可以做报表展现、也可以做数据分析，最后这些展现和分析的结果将能成为一些决策的重要数据支持，这就是描述商业智能 BI 的一个最简单的价值。简单概括这个过程所体现的三个大的部分就是：Data Source 数据源，Data Warehouse 数据仓库的数据准备，Reporting 报表系统提供报表展现和数据分析。 你的图表，是原因，还是现象? 数据分析师在地理图上发现A省B省C省的某个指标 下跌了，你兴奋的告诉老大这是上个月数据表现不佳的原因。 老大肯定抽你，这是现象。具体的原因要结合更深的分析，这些省市经济程度如何、人口如何、有何 数据共性，这是地理图不会告诉你的 **工具：Power BI** //TODO Power BI的基本使用——视频4.57~4.60 **单一图表的可视化没有意义——****三表成虎** Dashboard Who 是谁在使用?What 用户的目的是什么?How 用户怎么使用? Prower BI有监控，可以知道哪些人看了哪些图表。可以进行简单地调研，来改进自己的BI。后台调用监控日志，砍掉不需要的BI，加强需要的BI。 主次分明 贴合场景 指标结构 DashBoard是一个不断改进不断更新的过程。 六、数据库——1小时（有基础、多练习）1. 数据库数据库相关 数据库是数据存储的集合，表是数据结构化的信息 列存储表中的组织信息，行存储表中的明细信息 主键是表中唯一标识，主键不具备业务意义 Tips： 表的主键不做强制要求，但建议设立主键值必须唯一每行必须有一个主键，不可为空主键值不可被修改主键值被删除后不可重用表A的主键，可以做为表B的字段，此时不受约束 2. Join Students.addressId = Address.idStudents.id = Scores.studentIdScores.courseId = Courses.id 3. SQL练习题统计不同月份的下单人数统计用户三月份的回购率和复购率统计男女用户的消费频次是否有差异统计多次消费的用户，第一次和最后一次消费间隔是多少?统计不同年龄段，用户的消费金额是否有差异?统计消费的二八法则，消费的top20%用户，贡献了多少额度 八、Python——N小时（数据分析、爬虫、深度学习）1. Python的数据科学环境2. Python基础3. NumPy和Pandas4. 数据可视化5. 数据分析案例6. 数据分析平台七、统计学——N小时（配合Python食用）1. 描述统计学拿到数据的时候怎么做？ 男——0，女——1 「分类数据」 分类数据的描述统计 频数统计——单纯对各分类计数 频数百分比——单纯对各分类计数就可 数值数据描述统计 统计度量： 图形 统计度量： 平均数、中位数、众数 分位数 //TODO 阅读 贾俊平版《统计学》]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Data Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot]]></title>
    <url>%2F2019%2F08%2F15%2FSpringBoot%2F</url>
    <content type="text"><![CDATA[一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备http://www.gulixueyuan.com/ 谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World!"; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 ——- 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")//@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.atguigu.springboot.service.HelloService"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration———&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println("配置类@Bean给容器中添加组件了..."); return new HelloService(); &#125;&#125; 4、配置文件占位符1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式1234567891011121314151617181920server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar —spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar —spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar —server.port=8087 —server.context-path=/abc 多个配置用空格分开； —配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = "spring.http.encoding") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—-数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings("rawtypes")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = "http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志...");&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;springProfile name="dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name="!dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler("/webjars/**") .addResourceLocations( "classpath:/META-INF/resources/webjars/") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html"); public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—-Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path="/hello" view-name="success"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/hello"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = "spring.messages")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * "org.mypackage"), it will be resolved from the classpath root. */ private String basename = "messages"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="asserts/css/bootstrap.min.css" th:href="@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;" rel="stylesheet"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href="asserts/css/signin.css" th:href="@&#123;/asserts/css/signin.css&#125;" rel="stylesheet"&gt; &lt;/head&gt; &lt;body class="text-center"&gt; &lt;form class="form-signin" action="dashboard.html"&gt; &lt;img class="mb-4" th:src="@&#123;/asserts/img/bootstrap-solid.svg&#125;" src="asserts/img/bootstrap-solid.svg" alt="" width="72" height="72"&gt; &lt;h1 class="h3 mb-3 font-weight-normal" th:text="#&#123;login.tip&#125;"&gt;Please sign in&lt;/h1&gt; &lt;label class="sr-only" th:text="#&#123;login.username&#125;"&gt;Username&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="Username" th:placeholder="#&#123;login.username&#125;" required="" autofocus=""&gt; &lt;label class="sr-only" th:text="#&#123;login.password&#125;"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" placeholder="Password" th:placeholder="#&#123;login.password&#125;" required=""&gt; &lt;div class="checkbox mb-3"&gt; &lt;label&gt; &lt;input type="checkbox" value="remember-me"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#&#123;login.btn&#125;"&gt;Sign in&lt;/button&gt; &lt;p class="mt-5 mb-3 text-muted"&gt;© 2017-2018&lt;/p&gt; &lt;a class="btn btn-sm"&gt;中文&lt;/a&gt; &lt;a class="btn btn-sm"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = "spring.mvc", name = "locale") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter("l"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split("_"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style="color: red" th:text="$&#123;msg&#125;" th:if="$&#123;not #strings.isEmpty(msg)&#125;"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute("loginUser"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute("msg","没有权限请先登陆"); request.getRequestDispatcher("/index.html").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); registry.addViewController("/main.html").setViewName("dashboard"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**") .excludePathPatterns("/index.html","/","/user/login"); &#125; &#125;; return adapter; &#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—-GET 添加 addEmp?xxx emp—-POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—-PUT 删除 deleteEmp?id=1 emp/{id}—-DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert="~&#123;footer :: copy&#125;"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert="footer :: copy"&gt;&lt;/div&gt;&lt;div th:replace="footer :: copy"&gt;&lt;/div&gt;&lt;div th:include="footer :: copy"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 123456789101112131415161718&lt;nav class="col-md-2 d-none d-md-block bg-light sidebar" id="sidebar"&gt; &lt;div class="sidebar-sticky"&gt; &lt;ul class="nav flex-column"&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link active" th:class="$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;" href="#" th:href="@&#123;/main.html&#125;"&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"&gt; &lt;path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"&gt;&lt;/path&gt; &lt;polyline points="9 22 9 12 15 12 15 22"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class="sr-only"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace="commons/bar::#sidebar(activeUri='emps')"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type="email" class="form-control" placeholder="zhangsan@atguigu.com"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—-Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action="@&#123;/emp&#125;" method="post"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name="_method";值就是我们指定的请求方式--&gt; &lt;input type="hidden" name="_method" value="put" th:if="$&#123;emp!=null&#125;"/&gt; &lt;input type="hidden" name="id" th:if="$&#123;emp!=null&#125;" th:value="$&#123;emp.id&#125;"&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name="lastName" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name="email" type="email" class="form-control" placeholder="zhangsan@atguigu.com" th:value="$&#123;emp!=null&#125;?$&#123;emp.email&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class="form-control" name="department.id"&gt; &lt;option th:selected="$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;" th:value="$&#123;dept.id&#125;" th:each="dept:$&#123;depts&#125;" th:text="$&#123;dept.departmentName&#125;"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary" th:text="$&#123;emp!=null&#125;?'修改':'添加'"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each="emp:$&#123;emps&#125;"&gt; &lt;td th:text="$&#123;emp.id&#125;"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text="$&#123;emp.email&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.gender&#125;==0?'女':'男'"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.department.departmentName&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class="btn btn-sm btn-primary" th:href="@&#123;/emp/&#125;+$&#123;emp.id&#125;"&gt;编辑&lt;/a&gt; &lt;button th:attr="del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;" class="btn btn-sm btn-danger deleteBtn"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(".deleteBtn").click(function()&#123; //删除当前员工的 $("#deleteEmpForm").attr("action",$(this).attr("del_uri")).submit(); return false; &#125;);&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put("timestamp", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView("error", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value("$&#123;error.path:/error&#125;")private String path = "/error"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = "error/" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("code","user.notexist"); map.put("message",e.getMessage()); return map; &#125;&#125;//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute("javax.servlet.error.status_code"); */ request.setAttribute("javax.servlet.error.status_code",500); map.put("code","user.notexist"); map.put("message",e.getMessage()); //转发到/error return "forward:/error"; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put("company","atguigu"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125; 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),"/myServlet"); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet")); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir("tomcat")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 5）、嵌入式Servlet容器启动原理；什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—-应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>JavaWeb</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析与挖掘基础]]></title>
    <url>%2F2019%2F08%2F15%2Fdatadigging01-base%2F</url>
    <content type="text"><![CDATA[简介什么是数据分析和挖掘？所谓数据分析，即对已知的数据进行分析，然后提取出一些有价值的信息，比如统计出平均数、标准差等信息，数据分析的数据量有时可能不会太大，而数据挖掘，是指对大量的数据进行分析与挖掘，得到一些未知的、有价值的信息等，比如从网站的用户或用户行为数据中挖掘出用户的潜在需求信息，从而对网站进行改善等。 数据挖掘需要数据分析为基础 数据分析与数据挖掘能做什么事？数据挖掘技术可以帮助我们更好地发现事物之间的规律。所以，我们可以利用数据挖掘技术实现数据规律的探索，比如发现窃电用户、发掘用户潜在需求、实现信息的个性化推送、发现疾病与症状甚至疾病与药物之间的规律……等。 数据挖掘的过程？ 定义目标 （分析什么数据，解决什么问题） 获取数据（爬虫、下载统计网站的数据） 数据探索 数据预处理(数据清洗【去掉脏数据】、数据集成【集中】、数据变换【规范 化】、数据规约【精简、合并】) 挖掘建模(分类、聚类、关联、预测) 模型评价与发布 相关模块相关模块简介 numpy 可以高效处理数据、提供数组支持、很多模块都依赖他，比如pandas、 scipy、matplotlib都依赖他，所以这个模块是基础。 pandas 我们课程后续用得最多的一个模块，主要用于进行数据探索和数据分析。 matplotlib 作图模块，解决可视化问题。 scipy 主要进行数值计算，同时支持矩阵运算，并提供了很多高等数据处理功能， 比如积分、傅里叶变换、微分方程求解等。 statsmodels 这个模块主要用于统计分析 Gensim 这个模块主要用于文本挖掘 sklearn、keras 前者机器学习，后者深度学习 numpy、mkl和scipy模块建议下载安装 相关模块基本使用numpy1234567891011import numpyx = numpy.array(["a","9","2"])y = numpy.array([[1,2,3,4], [5,6,7,8], [9,0,1,2,3], [4,5,6,67]])print(y)print(y[1][2]) pandas12345678910111213141516171819202122232425262728293031323334353637import pandas as pda'''Series #index索引DataFrame'''a = pda.Series([8,9,2,1])print(a)# indexa = pda.Series([8,9,2,1],index=["one","two","three","four"])print(a)b = pda.DataFrame([[5,4,3,2],[6,4,3,4],[3,4,6,4]])print(b)b = pda.DataFrame([[5,4,3,2],[6,4,3,4],[3,4,6,4]],columns = ["one","two","three","four"])print(b)c = pda.DataFrame(&#123; "one":4, "two":[6,5,3], "three":list(str(982))&#125;)print(c)# 头部尾部数据，默认前五行d = c.head(2) # 前两行e = c.tail(1) # 后一行print(d)print(e)# 统计信息，总计、平均数、标准差、最小、分位数、最大print(b.describe())# 转置print(c.T) Python数据导入导入excel1234567891011import pandas as pdai = pda.read_csv("/Users/biandudu/Documents/webcrawerfiles/hexun.csv")print(i.describe())# 按照某一列排序print(i.sort_values(by="hits"))j = pda.read_excel("/Users/biandudu/Documents/webcrawerfiles/abc.xls")print(j) 导入mysql123456789import pandas as pdaimport pymysqlconn = pymysql.connect(host="127.0.0.1",user="root",passwd="123456",db="data_analysis")sql = "select * from company"k = pda.read_sql(sql,conn)print(k.describe()) 导入html 使用pandas，可以直接从html网页中加载对应table表格中的数据，但是在使用read_html()之前，需要先安装html5lib模块与beautifulsoup4模块。 pda.read_html() 导入文本pda.read_table()]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>DataMine</tag>
        <tag>Data Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How Africa is Becoming China's China]]></title>
    <url>%2F2019%2F05%2F24%2FAferica-China%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/China.mp4","pic":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/2019-08-28%2F1566993623.png"},"danmaku":{"id":"Africa","api":"https://dplayer.moerats.com/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>Share</tag>
        <tag>China</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MFCC探索]]></title>
    <url>%2F2019%2F01%2F16%2FMFCCExplore%2F</url>
    <content type="text"><![CDATA[毕业设计进展报告五——陶家成一周主要工作内容 了解特征提取的过程 了解MFCC及其实现原理 了解HMM 打了一些codeforces的题 《语音信号处理》、《Automatic Speech Recognition》 未完成： 了解傅立叶变换及其在深度学习中的应用 具体内容关于音频特征MFCC提取MFCC概述 根据人耳听觉机理的研究发现，人耳对不同频率的声波有不同的听觉敏感度。所以，人们从低频到高频这一段频带内按临界带宽的大小由密到疏安排一组带通滤波器，对输入信号进行滤波。将每个带通滤波器输出的信号能量作为信号的基本特征，对此特征经过进一步处理后就可以作为语音的输入特征。由于这种特征不依赖于信号的性质，对输入信号不做任何的假设和限制，又利用了听觉模型的研究成果。因此，这种参数比基于声道模型的LPCC相比具有更好的鲁邦性，更符合人耳的听觉特性，而且当信噪比降低时仍然具有较好的识别性能。 梅尔倒谱系数是在Mel标度频率域提取出来的倒谱参数，Mel标度描述了人耳频率的非线性特性，它与频率的关系可用下式近似表示： ​ $Mel(f) = 2595 · lg(1 + f/700)$ Mel频率与线性频率的关系： MFCC特征提取过程包括 对音频信号预加重、分帧和加窗 FFT(快速傅里叶变换)得到频谱 频谱通过Mel滤波器组得到Mel频谱 在Mel频谱上面进行倒谱分析得到MFCC特征 通过这个MFCC特征提取过程，语音就可以通过一系列的倒谱向量来描述了，每个向量就是每帧的MFCC特征向量。语音识别系统就可以接着在MFCC特征的基础上进行训练和识别了。 预加重 预加重的目的是提升高频部分，对语音的高频部分进行加重，去除口唇辐射的影响，增加语音的高频分辨率使信号的频谱变得平坦，保持在低频到高频的整个频带中，能用同样的信噪比求频谱。原因是因为对于语音信号来说，语音的低频段能量较大，能量主要分布在低频段，语音的功率谱密度随频率的增高而下降，这样，鉴频器输出就会高频段的输出信噪比明显下降，从而导致高频传输衰弱，使高频传输困难，这对信号的质量会带来很大的影响。因此，在传输之前把信号的高频部分进行加重，然后接收端再去重，能够提高信号传输质量。 预加重相当于图片处理中的灰度拉伸/二值化，「增加识别的准确性」 预加重其实是将语音信号通过一个高通滤波器： $x_p(n) = x(n) - k·(n-1)$ （任取k，但是语音处理通常用0.9-0.97） 分帧 语音信号的变化是非常迅速的，但是通常傅里叶变换适用于分析平稳的信号。我们假设在较短的时间跨度范围内，语音信号的变换是平坦的，一般取这个时间跨度为20ms-40ms。为什么取这个范围呢，因为能够保证一帧内既有足够多的周期，又不会变化太剧烈。 为了「分离平滑帧」 加窗 每帧信号通常要与一个平滑的窗函数相乘，让帧两端平滑地衰减到零，这样可以降低傅里叶变换后旁瓣的强度，取得更高质量的频谱。对每一帧，选择一个窗函数，窗函数的宽度就是帧长。常用的窗函数有矩形窗、汉明窗、汉宁窗、高斯窗等。 为了「取得更高质量的频谱」 假设分帧后的信号为S(n), n=0,1…,N-1, N为帧的大小，那么乘上汉明窗 后，W(n)的形式如下： FFT(快速傅立叶变换) 由于信号在时域上的变换通常很难看出信号的特性，所以通常将它转换为频域上的能量分布来观察，不同的能量分布，就能代表不同语音的特性。所以在乘上汉明窗后，每帧还必须再经过快速傅里叶变换以得到在频谱上的能量分布。 得到「频谱的能量分布」 对语音信号频谱取模平方得到语音信号谱线能量。 声谱图「重点部分」声谱图的作用： 音素以及它们的属性更易于观察 通过观察共振峰和它们的转变可以更好的识别声音 隐马尔科夫模型就是隐含地对声谱图进行建模以达到好的识别性能 能够直观的评估TTS系统（text to speech）的好坏，直接对比合成的语音和自然的语音声谱图的匹配度即可 经过前面的预处理，每帧语音都对应一个频谱。 「但是这部分还是看不太懂」 计算通过Mel滤波器的能量将能量谱通过一组Mel尺度的三角形滤波器组，定义一个有M个滤波器的滤波器组（滤波器的个数和临界带的个数相近），采用的滤波器为三角滤波器，中心频率为f(m) 。M通常取22-26。各f(m)之间的间隔随着m值的减小而缩小，随着m值的增大而增宽，如图所示： 对频谱进行平滑化，并消除谐波的作用，突显原先语音的共振峰。（因此一段语音的音调或音高，是不会呈现在MFCC 参数内，换句话说，以MFCC 为特征的语音辨识系统，并不会受到输入语音的音调不同而有所影响）此外，还可以降低运算量。 三角滤波器的频率响应定义为: 计算每个滤波器组输出的对数能量为 ： 计算DCT倒谱经离散余弦变换（DCT）得到MFCC系数 : 将上述的对数能量带入离散余弦变换，求出L阶的Mel参数。L阶指MFCC系数阶数，通常取12-16。这里M是三角滤波器个数。 在六大区实现的官方源码中使用HTK实现MFCC和HMM 整个HTK是使用HMM作为语音识别的核心，当HMM应用于孤立词语音识别时，它用不同的隐含状态来描述不同的语音发音，对于连续语音识别系统，多个孤立词HMM子模型按一定的语言模型组成的复合HMM模型序列来刻画连续的语音信号，在序列中每个模型直接对应于相关的发音，并且每一个模型都有进入和退出状态，这两个状态没有对应的观察矢量，只用于不同模型的连接。 HTK是英国剑桥大学开发的一套基于C语言的隐马尔科夫模型工具箱，主要应用于语音识别、语音合成的研究，也被用在其他领域，如字符识别和DNA排序等。HTK是重量级的HMM版本。 代码位置：inferenceLSTM/read_data和inferenceLSTM/HTKfile HTK文件结构：帧数：4字节（第0-第3字节） 采样周期：4字节（第4-第7字节） 每一帧的字节数：2字节（第8-第9字节） 参数类型：2字节（第10-第11字节） 数据：N字节（第12字节开始-文件结尾） TODO 把文件中的主要代码和预处理脚本都理清看懂 完成采集数据集的准备工作，弄清音频的要求 弄懂声谱图部分，性能调优的方向之一 看书《深度学习中文版》 第三章——概率与信息论 第八章——深度模型中的优化 第十章——循环和递归网络——LSTM 学好算法，打打codeforces ADD 了解傅立叶变换及其在深度学习中的应用]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>About</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Understanding RNN & LSTM]]></title>
    <url>%2F2019%2F01%2F05%2FLSTM%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/LSTM1.mp4","pic":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/2019-09-01%2F1567318915.png"},"danmaku":{"id":"LSTM","api":"https://dplayer.moerats.com/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>Share</tag>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语音识别初实现]]></title>
    <url>%2F2019%2F01%2F04%2FASRExplore%2F</url>
    <content type="text"><![CDATA[语音识别初实现——傅立叶变换、MFCC、HMM读取和绘制音频数据 读取音频文件并可视化展现 音频文件是实际音频信哈的数字化形式，实际的音频信号是复杂的连续波形。为了将其保存成数字化形式，需要对音频信号进行采样并将其转换成数字。语音通常以44100 Hz的频率进行采样，这就意味着每秒钟信号被分解成44100份，然后这些抽样值被保存。 代码实现：123456789101112131415161718192021222324252627282930import numpy as npimport matplotlib.pyplot as pltfrom scipy.io import wavfile# 使用wavfile包从input_read.wav中读取音频文件:sampling_freq, audio = wavfile.read('input_read.wav')# 打印信号相关参数print ('\nShape:', audio.shape)print ('Datatype:', audio.dtype)print ('Duration:', round(audio.shape[0] / float(sampling_freq), 3), 'seconds')# 标准化audio = audio / (2.**15)# 提取前30个值画图audio = audio[:30]# 建立时间轴，x轴按照采样频率因子进行缩放x_values = np.arange(0, len(audio), 1) / float(sampling_freq)# 单位转换为secondsx_values *= 1000# 画出声音信号图形plt.plot(x_values, audio, color='black')plt.xlabel('Time (ms)')plt.ylabel('Amplitude')plt.title('Audio signal')plt.show() 将音频信号转化为频域 音频信号是不同频率、幅度和相位的正弦波的复杂混合。正弦波也称作正弦曲线。音频信号的频率内容中隐藏了很多信息。事实上，一个音频信号的性质由其频率内容决定。世界上的语音和音乐都是基于这个事实的。 //Todo 傅立叶变换 123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npfrom scipy.io import wavfileimport matplotlib.pyplot as plt# Read the input filesampling_freq, audio = wavfile.read('input_freq.wav')# Normalize the valuesaudio = audio / (2.**15)# 提取数组长度len_audio = len(audio)# 傅立叶变换，因为傅立叶变换是关于中心点对称的，因此只需要转换信号的前半部分。# 最终目标是提取功率信号，先将信号的值平方transformed_signal = np.fft.fft(audio)half_length = np.ceil((len_audio + 1) / 2.0)transformed_signal = abs(transformed_signal[0:half_length])transformed_signal /= float(len_audio)transformed_signal **= 2# 提取信号长度len_ts = len(transformed_signal)# 将部分信号乘以2if len_audio % 2: transformed_signal[1:len_ts] *= 2else: transformed_signal[1:len_ts-1] *= 2# 获取功率信号power = 10 * np.log10(transformed_signal)# Build the time axisx_values = np.arange(0, half_length, 1) * (sampling_freq / len_audio) / 1000.0# Plot the figureplt.figure()plt.plot(x_values, power, color='black')plt.xlabel('Freq (in kHz)')plt.ylabel('Power (in dB)')plt.show() 提取频域特征 将信号转换为频域之后，还需要将其转换成有用的形式。梅尔频率倒谱系数(Mel Frequency Cepstrum Coefficient，MFCC)可以解决这个问题。MFCC首先计算信号的功率谱，然后用滤波器组和离散余弦变换的组合来提取特征。 //Todo 梅尔频率倒谱系数 1234567891011121314151617181920212223242526272829303132import numpy as npimport matplotlib.pyplot as pltfrom scipy.io import wavfile from features import mfcc, logfbank# Read input sound filesampling_freq, audio = wavfile.read("input_freq.wav")# Extract MFCC and Filter bank features# 提取MFCC和过滤器组特征mfcc_features = mfcc(audio, sampling_freq)filterbank_features = logfbank(audio, sampling_freq)# Print parameters# 查看可以生成多少个窗体print ('\nMFCC:\nNumber of windows =', mfcc_features.shape[0])print ('Length of each feature =', mfcc_features.shape[1])print ('\nFilter bank:\nNumber of windows =', filterbank_features.shape[0])print ('Length of each feature =', filterbank_features.shape[1])# Plot the features# 画出特征图mfcc_features = mfcc_features.Tplt.matshow(mfcc_features)plt.title('MFCC')# 滤波器组特征可视化，需要转换矩阵，使得域是水平的filterbank_features = filterbank_features.Tplt.matshow(filterbank_features)plt.title('Filter bank')plt.show() 创建一个隐马尔可夫模型 本例将用到隐马尔科夫模型(Hidden Markov Models，HMMs)来做语音识别。隐马尔科夫模型非常擅长建立时间序列数据模型。因为一个音频信号同时也是一个时间序列信号，因此隐马尔科夫模型也同样适用于音频信号的处理。假定输出是通过隐藏状态生成的，我们的目标是找到这些隐藏状态，以便对信号建模。 // Todo 隐马尔科夫模型 创建一个语音识别器 我们需要为每一类构建一个隐马尔科夫模型。如果想识别新的输入文件中的单词，需要对该文件运行所有的模型，并找出最佳分数的结果。下面将用到在前一节构建的隐马尔科夫类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import osimport argparse import numpy as npfrom scipy.io import wavfile from hmmlearn import hmmfrom features import mfcc# 用于解析命令行中输入的参数def build_arg_parser(): parser = argparse.ArgumentParser(description='Trains the HMM classifier') parser.add_argument("--input-folder", dest="input_folder", required=True, help="Input folder containing the audio files in subfolders") return parser# 创建类处理HHM相关过程class HMMTrainer(object): # 初始化该类。下面将用到高斯隐马尔科夫模型(Gaussian HMMs)来对数据建模。参数 n_components定义了隐藏状态的个数，参数cov_type定义了转移矩阵的协方差类型，参数 n_iter定义了训练的迭代次数 def __init__(self, model_name='GaussianHMM', n_components=4, cov_type='diag', n_iter=1000): # 初始化变量 self.model_name = model_name self.n_components = n_components self.cov_type = cov_type self.n_iter = n_iter self.models = [] # 用以下参数定义模型 if self.model_name == 'GaussianHMM': self.model = hmm.GaussianHMM(n_components=self.n_components, covariance_type=self.cov_type, n_iter=self.n_iter) else: raise TypeError('Invalid model type') # 输入数据是一个NumPy数组，数组的每个元素都是一个特征向量，每个特征向量都包含k 个维度 # X is a 2D numpy array where each row is 13D def train(self, X): np.seterr(all='ignore') self.models.append(self.model.fit(X)) # 基于该模型定义一个提取分数的方法 # Run the model on input data def get_score(self, input_data): return self.model.score(input_data) # 定义一个main函数，解析输入的参数if __name__=='__main__': args = build_arg_parser().parse_args() input_folder = args.input_folder # 初始化隐马尔科夫模型的变量 hmm_models = [] # 解析包含所有数据库音频文件的输入路径 for dirname in os.listdir(input_folder): # 提取子文件夹的名称 subfolder = os.path.join(input_folder, dirname) if not os.path.isdir(subfolder): continue # 子文件夹的名称即为该类的标记，提取标记 label = subfolder[subfolder.rfind('/') + 1:] # 初始化变量 X = np.array([]) y_words = [] # 迭代每一个子文件夹中的音频文件（分别保留一个进行测试） for filename in [x for x in os.listdir(subfolder) if x.endswith('.wav')][:-1]: # 读取每个音频文件 filepath = os.path.join(subfolder, filename) sampling_freq, audio = wavfile.read(filepath) # 提取MFCC特征 mfcc_features = mfcc(audio, sampling_freq) # 将MFCC特征添加到X变量 if len(X) == 0: X = mfcc_features else: X = np.append(X, mfcc_features, axis=0) # 添加标记 y_words.append(label) print 'X.shape =', X.shape # 一旦提取完当前类所有文件的特征，就可以训练并保存隐马尔科夫模型了。因为隐马尔科夫模型是一个无监督学习的生成模型，所以并不需要利用标记针对每一类构建隐马尔科夫模型。 # Train and save HMM model hmm_trainer = HMMTrainer() hmm_trainer.train(X) hmm_models.append((hmm_trainer, label)) hmm_trainer = None # Test files（获取一个未被用于训练的测试文件列表） input_files = [ 'data/pineapple/pineapple15.wav', 'data/orange/orange15.wav', 'data/apple/apple15.wav', 'data/kiwi/kiwi15.wav' ] # 为输入数据分类 for input_file in input_files: # Read input file sampling_freq, audio = wavfile.read(input_file) # 提取MFCC特征 mfcc_features = mfcc(audio, sampling_freq) # Define variables max_score = None output_label = None # 迭代HMM模型并选取得分最高的模型 # the one with the highest score for item in hmm_models: hmm_model, label = item # 提取并保存最大分数 score = hmm_model.get_score(mfcc_features) if score &gt; max_score: max_score = score output_label = label # Print the output print "\nTrue:", input_file[input_file.find('/')+1:input_file.rfind('/')] print "Predicted:", output_label]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>About</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习初探]]></title>
    <url>%2F2019%2F01%2F03%2FDLWithPyFirstExlpore%2F</url>
    <content type="text"><![CDATA[深度学习初探——基于Python的理论和实现此书特点： 从零开始实现深度学习程序 最终实现一个高精度识别图像的系统 从实现层面理解误差反向传播法、卷积运算 不介绍深度学习框架 不介绍参数调优 不进行GPU相关实现 目标：有能力进一步去阅读最新的论文或者神经网络相关的理论方面的技术书。 Python入门Numpy 在深度学习的实现中，经常出现数组和矩阵的计算。NumPy 的数组类 (numpy.array)中提供了很多便捷的方法，在实现深度学习时，我们将使用这些方法。 导入Numpy库Python中使用import语句来导入库。这里的import numpy as np，直译的话就是“将 numpy 作为 np 导入”的意思。通过写成这样的形式，之后NumPy 相关的方法均可通过 np 来调用。 生成Numpy数组生成 NumPy 数组，需要使用 np.array() 方法。 Numpy的算数运算当数组 x 和数组 y 的元素个数相同时，可以对各个元素进行算术运算。 Numpy的N维数组1A = np.array([[1, 2], [3, 4]]) 广播形状不同的数组之间也可以进行运算。标量数组扩展成2*2数组再计算，称之为广播。 访问元素逐个访问，for语句访问，数组访问 Matplotlib 在深度学习的实验中，图形的绘制和数据的可视化非常重要。Matplotlib是用于绘制图形的库，使用 Matplotlib 可以轻松地绘制图形和实现数据的可视化。 pyplot的功能添加标题和x轴标签名等功能 1234567891011121314151617# coding: utf-8import numpy as npimport matplotlib.pyplot as plt# 生成数据x = np.arange(0, 6, 0.1) # 以0.1为单位，生成0到6的数据y1 = np.sin(x)y2 = np.cos(x)# 绘制图形plt.plot(x, y1, label="sin")plt.plot(x, y2, linestyle = "--", label="cos")plt.xlabel("x") # x轴的标签plt.ylabel("y") # y轴的标签plt.title('sin &amp; cos')plt.legend()plt.show() 显示图像pyplot提供了用于显示图像的方法imshow()。另外，可以使用matplotlib.image 模块的 imread() 方法读入图像。 12345678# coding: utf-8import matplotlib.pyplot as pltfrom matplotlib.image import imreadimg = imread('../dataset/lena.png') #读入图像plt.imshow(img)plt.show() 图像放在dataset目录下，可以直接读取。 感知机感知机是什么？ 感知机是作为神经网络(深度学习)的起源的算法。感知机接收多个输入信号，输出一个信号。这里所说的“信号”可以想象成电流或河流那样具备“流动性”的东西。像电流流过导线，向前方输送电子一样，感知机的信号也会形成流，向前方输送信息。但是，和实际的电流不同的是，感知机的信号只有“流 / 不流”(1/0)两种取值。 x1、x2 是输入信号，y是输出信号，w1、w2 是权重(w是weight的首字母)。图中的○称为“神经元”或者“节点”。输入信号被送往神经元时，会被分别乘以固定的权重(w1x1、w2x2)。神经元会计算传送过来的信号的总和，只有当这个总和超过了某个界限值时，才会输出1。这也称为“神经元被激活”。b称为偏置的参数，用于控制神经元被激活的容易程度。 数学表示： 感知机多个输入信号有各自的权重，这些权重发挥着控制着各个信号的重要性的作用。权重越大，信号的重要性就越高。（权重相当于电流中的电阻，电阻决定电流流动难度的参数） 简单逻辑电路我们已经知道使用感知机可以表示与门、与非门、或门的逻辑电路。这里重要的一点是:与门、与非门、或门的感知机构造是一样的。实 际 上 ， 3 个门电路只有参数的值(权重和阈值)不同 。 感知机的实现使用权重和偏置实现与门： 123456789101112131415161718# coding: utf-8import numpy as npdef AND(x1, x2): x = np.array([x1, x2]) w = np.array([0.5, 0.5]) b = -0.7 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 else: return 1if __name__ == '__main__': for xs in [(0, 0), (1, 0), (0, 1), (1, 1)]: y = AND(xs[0], xs[1]) print(str(xs) + " -&gt; " + str(y)) 使用感知机可以实现与门、与非门、或门三种逻辑电路。 感知机的局限性 感知机无法实现异或门 感知机无法表示曲线 多层感知机 通过组合与门、与非门、或门实现异或门 通过叠加层(加深层)，感知机能进行更加灵活的表示。 神经网络 感知机的作用是：即便对于复杂的函数，也隐含着能够表示它的可能性。神经网络的一个重要性质是可以自动从数据中学习合适的权重参数。 从感知机到神经网络神经网络的例子用图来表示神经网络，分为输入层、输出层和中间层。中间层也叫隐藏层，隐藏层的神经元肉眼看不见。神经元的连接方式而言，与感知机并无差别。 复习感知机明确表示出偏置，简化式子，引入新函数h(x) ： 激活函数h(x)函数会将输入信号的总和转换为输出信号，这种函数一般称为激活函数(activation function)。激活函数的作用在于决定如何来激活输入信号的总和。 先计算输入信号的加权总和，然后用激活函数转换这一总和： 明确显示激活函数计算过程的神经元 ： 信号的加权总和为节点 a，然后节点 a 被激活函数 h() 转换成节点 y。“神经元”和“节点”两个术语的含义相同。 激活函数是连接感知机和神经网络的桥梁。 激活函数 激活函数以阈值为界，一旦输入超过阈值，就切换输出。这样的函数称为“阶跃函数”。因此，可以说感知机中使用了阶跃函数作为激活函数。也就是说，在激活函数的众多候选函数中，感知机使用了阶跃函数。那么，如果感知机使用其他函数作为激活函数的话会怎么样呢?实际上，如果将激活函数从阶跃函数换成其他函数，就可以进入神经网络的世界了。 sigmoid函数神经网络经常使用的一个激活函数sigmoid函数： 神经网络利用sigmoid函数作为激活函数，进行信号的转换，转换后的信号被传送到下一个神经元。感知机和神经网络的主要区别就在于这个激活函数。在其它方面，比如神经元的多层连接的构造，信号的传递方法等，基本上和感知机是一样的。 阶跃函数的实现简单的阶跃函数： 12345def step_function(x): if x &gt; 0: return 1 else: return 0 支持NumPy数组的实现： 123def step_function(x): y = x &gt; 0 return y.astype(np.int) NumPy数组进行不等号运算后，数组的各个元素都会进行不等号运算，生成一个布尔型的数组。数组y是个布尔型的数组，但是阶跃函数是会输出int型的0或1的函数。因此需要转换为int型。 可以用 astype() 方法转换 NumPy 数组的类型。astype() 方法通过参数指定期望的类型，这个例子中是 np.int 型。 阶跃函数的图形图形上表示上面定义的阶跃函数，需要用到matplotlib库： 12345678910111213import numpy as npimport matplotlib.pylab as pltdef step_function(x): return np.array(x &gt; 0, dtype = np.int)#−5.0到5.0的范围内，以0.1为单位，生成 NumPy数组([-5.0, -4.9, ..., 4.9])x = np.arange(-5.0,5.0,0.1)#step_function()以该NumPy数组为 参数，对数组的各个元素执行阶跃函数运算，并以数组形式返回运算结果。y = step_function(x)plt.plot(x,y)plt.ylim(-0.1,1.1) #指定y轴的范围plt.show() 阶跃函数以 0 为界，输出从 0 切换为 1(或者从 1 切换为 0)。 它的值呈阶梯式变化，所以称为阶跃函数。 sigmoid函数的实现12345def sigmoid(x): return 1 / (1 + np.exp(-x))x = np.array([-1.0, 1.0, 2.0])sigmoid(x) 在python中可以如此表示sigmoid函数，当传入参数x为NumPy数组时，也能被正确计算，是因为NumPy的广播功能。 现在把上面的阶跃函数换成sigmoid函数： sigmoid函数和阶跃函数的比较： sigmoid函数是一条平滑的曲线，输入输出发生连续的变化。阶跃则是以0为界，急剧变化。 阶跃函数只能返回0和1，sigmoid函数可以返回实数 都是非线性函数： 激活函数不能使用线性函数，使用线性函数，加深网络的层数就没有意义了。 线性函数无法发挥多层网络带来的优势 ReLU函数sigmoid早就开始用了，现在主要使用ReLU（Rectified Linear Unit）函数。 ReLU函数输入大于 0 时，直接输出该值;在输入小于等于 0 时，输出 0 ： ReLU函数的实现： 12def relu(x): return np.maximum(0,x) 多维数组的运算多维数组运算可以高效实现神经网络 二维矩阵1B = np.array([[1,2], [3,4], [5,6]]) 矩阵的乘积：（np.dot(A, B)和np.dot(B, A)不同） 123A = np.array([[1,2], [3,4]])B = np.array([[5,6], [7,8]])np.dot(A, B) A的列数必须和B的行数相等才能计算np.dot(A,B) 神经网络的内积使用NumPy矩阵实现神经网络：（省略了偏置和激活函数，只有权重） 三层神经网络的实现巧妙使用NumPy数组，可以使用很少的代码实现神经网络的前向处理。 符号确认 表示前一层的第 2 个神经元 x2 到后一层的第 1 个神经元 的权重。w(weight) 各层间信号传递的实现 矩阵乘法运算，则可以表示成： 代码简单实现上述式子： 123456X = np.array([1.0, 0.5])W1 = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.6]]) B1 = np.array([0.1, 0.2, 0.3])A1 = np.dot(X, W1) + B1 #x的列数和w的行数相同，w和x对应维度的个数也保持一致#前面的乘积的到一个3列，加上B的3列 隐藏层的加权和(加权信号和偏置的总和)用 a 表示，被激活函数转换后的信号用 z 表示。此外，图中 h() 表示激活函数，这里我们使用的是 sigmoid 函数： 1234Z1 = sigmoid(A1)print(A1)print(Z1) 下面实现第一层到第二层的信号传递： 1234567W2 = np.array([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]])B2 = np.array([0.1, 0.2])print(Z1.shape) # (3,) print(W2.shape) # (3, 2) print(B2.shape) # (2,)A2 = np.dot(Z1, W2) + B2 Z2 = sigmoid(A2) 实现基本相同，但是最后的激活函数和隐藏层的有所不同。 12345678def identity_function(x): return xW3 = np.array([[0.1, 0.3], [0.2, 0.4]]) B3 = np.array([0.1, 0.2])A3 = np.dot(Z2, W3) + B3Y = identity_function(A3) # 或者Y = A3 这里的identity_function()函数（恒等函数），并将其作为输出层的激活函数。这样实现只是为了和之前的流程保持统一。 输出层所用的函数：根据求解问题的性质决定： 回归问题用恒等函数 二元分类问题使用sigmoid函数 多元分类问题使用softmax函数 代码实现小结12345678910111213141516171819202122232425def init_network(): #初始化为字典变量&#123;&#125; network = &#123;&#125; network['W1'] = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.6]]) network['b1'] = np.array([0.1, 0.2, 0.3]) network['W2'] = np.array([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]]) network['b2'] = np.array([0.1, 0.2]) network['W3'] = np.array([[0.1, 0.3], [0.2, 0.4]]) network['b3'] = np.array([0.1, 0.2]) return networkdef forward(network,x): W1, W2, W3 = network['W1'], network['W2'], network['W3'] b1, b2, b3 = network['b1'], network['b2'], network['b3'] a1 = np.dot(x, W1) + b1 z1 = sigmoid(a1) a2 = np.dot(z1, W2) + b2 z2 = sigmoid(a2) a3 = np.dot(z2, W3) + b3 y = identity_function(a3) return ynetwork = init_network()x = np.array([1.0, 0.5])y = forward(network, x)print(y) # [ 0.31682708 0.69627909] 定义了init_network()和forward()函数，分别进行权重的初始化和信号处理。后面会有backword()处理函数（从输出往输入方向的处理）。通过NumPy的多维数组，高效地实现了神经网络。 输出层的设计神经网络可以用在分类问题和回归问题上，需要根据情况改变输出层的激活函数，回归问题用恒等函数，分类问题用softmax函数。 恒等函数和softmax 函数和前面隐藏层的激活函数一样，恒等函数进行的转换处理可以用一根箭头表示。 分类问题中的softmax函数可以用下面的式子表示： softmax 函数的分子是输入信号 ak 的指数函数，分母是所有输入信号的指数函数的和。 softmax函数的输出通过肩头和所有的信号相连，输出层的各个神经元都受到输入信号的影响。 softmax函数的实现： 123456def softmax(a): exp_a = np.exp(a) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y 实现softmax函数的注意事项上面的softmax的实现存在溢出问题，指数运算的值很容易溢出，如果超大的值进行除法运算就会出现不确定的情况。溢出问题在进行计算的运算时必须注意！ 改进： 指数运算时加上某个常数并不会改变运算结果，这里的C‘为了防止溢出，一般使用输入信号中的最大值的相反数。 softmax改进后的函数实现： 1234567def softmax(a): c = np.max(a) exp_a = np.exp(a-c) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y softmax的函数特征 因为指数函数是单调递增函数，即便使用了softmax函数各个元素之间的大小关系也不会改变。一般来说，神经网络只把输出值最大的神经元对应的类别作为识别结果。即便使用softmax函数，输出值最大的神经元也不会改变，在神经网络分类时，softmax函数可以省略。 求解机器学习问题的步骤可以分为“学习”A 和“推理”两个阶段。首先，在学习阶段进行模型的学习 B，然后，在推理阶段，用学到的模型对未知的数据进行推理(分类)。如前所述，推理阶段一般会省略输出层的 softmax 函数。在输出层使用 softmax 函数是因为它和神经网络的学习有关系。 softmax的函数输出总是在0.0到1.0之间 softmax函数的输出值总和为1，所以softmax可以解释为概率。 通过使用softmax函数，可以使用概率论统计的方法处理问题 输出层神经元数量输出层的神经元数量需要根据待解决的问题来决定。对于分类问题，输出层的神经元数量一般设定为类别的数量。 手写数字识别使用学习到的参数，先实现神经网络的“推理处理”。这个推理处理也称为神经网络的前向传播(forward propagation)。 MNIST数据集什么是MNIST？ MNIST手写数据集，是机器学习最有名的数据集之一。MNIST有训练图像6w张，测试图像1w张。 一般使用方法：先用训练图像进行学习，再用学习到的模型度量能够多大程度上对测试图像进行正确的分类。 MNIST图像数据是28像素x28像素的灰度图像，各个像素取值在0-255之间，每个图像对应有数字标签。 ch03/mnist_show.py使用mnist.py中的load_mnist()函数，就可以读取MNIST数据： 1234567891011121314151617181920212223242526# coding: utf-8import sys, ossys.path.append(os.pardir) # 为了导入父目录的文件而进行的设定import numpy as npfrom dataset.mnist import load_mnist # 调入自定义的load_mnist函数from PIL import Imagedef img_show(img): # Image.fromarray把保存为 NumPy 数组的图像数据转换为 PIL 用 的数据对象 pil_img = Image.fromarray(np.uint8(img)) pil_img.show()(x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=False)# 当flatten=True时读入的图像是以一列NumPy数组的形式保存的，显示图像时需要调用reshape()方法img = x_train[0]label = t_train[0]print(label) # 5print(img.shape) # (784,)img = img.reshape(28, 28) # 通过 reshape() 方法的参数指定期望的形状，更改 NumPy 数组的形状。print(img.shape) # (28, 28)img_show(img) 关于PIL（Python Image Library）是Python的图像处理标准库，功能非常强大，API简单易用。 PIL中的Image和NumPy中的array相互转换 PIL Image转换为array 1img = np.asarray(image 如果出现read-only错误，并不是转换的错误，一般是你读取的图片的时候，默认选择的是”r”,”rb”模式有关。 1img.flags.writeable = True # 将数组改为读写模式 array转换成image 1Image.fromarray(np.unit8(img)) 关于load_mnist函数的解释位于`dataset/mnist.py的load_mnist函数： 123456789101112131415161718192021222324def load_mnist(normalize=True, flatten=True, one_hot_label=False): # 如果数据不存在，调用init方法下载并转换 if not os.path.exists(save_file): init_mnist() # with能够自动处理上下文环境产生的异常 with open(save_file, 'rb') as f: dataset = pickle.load(f) if normalize: for key in ('train_img', 'test_img'): dataset[key] = dataset[key].astype(np.float32) dataset[key] /= 255.0 if one_hot_label: dataset['train_label'] = _change_one_hot_label(dataset['train_label']) dataset['test_label'] = _change_one_hot_label(dataset['test_label']) if not flatten: for key in ('train_img', 'test_img'): dataset[key] = dataset[key].reshape(-1, 1, 28, 28) return (dataset['train_img'], dataset['train_label']), (dataset['test_img'], dataset['test_label']) 通过传入布尔值来执行相关操作的函数： normalize（正规化）：将图像的像素值正规化为0.0~1.0。 将图像的各个像素值除以 255，使得数据的值在 0.0~1.0 的范围内。像这样把数据限定到某个范围内的处理称为正规化(normalization)。 flatten（扁平化）：是否将图像展开为一维数组。 one_hot_label（一条标签数组）：one_hot_label为True的情况下，标签作为one-hot数组返回。「one-hot数组是指[0,0,1,0,0,0,0,0,0,0]这样的数组」 读入MNIST数据集，返回(训练图像, 训练标签), (测试图像, 测试标签) 神经网路的推理处理神经网络输入层有784个神经元，输出层有10个神经元，输入层784源于图像大小28 x 28，输出层的10来源于10类别分类。此外还有两个隐藏层，第一层50个神经元，第二层100个神经元。50和100可以为任意值。 定义 get_data()、init_network()、predict() ：【neuralnet_mnist.py】 1234567891011121314151617181920212223242526272829303132333435363738394041424344# coding: utf-8import sys, ossys.path.append(os.pardir) # 为了导入父目录的文件而进行的设定import numpy as npimport picklefrom dataset.mnist import load_mnistfrom common.functions import sigmoid, softmax# 返回测试图像和测试标签def get_data(): (x_train, t_train), (x_test, t_test) = load_mnist(normalize=True, flatten=True, one_hot_label=False) return x_test, t_test# 读入保存在pickle文件sample_weight.pkl中的权重参数，这个文件以字典变量的形式保存了权重和偏置参数def init_network(): with open("sample_weight.pkl", 'rb') as f: network = pickle.load(f) return networkdef predict(network, x): W1, W2, W3 = network['W1'], network['W2'], network['W3'] b1, b2, b3 = network['b1'], network['b2'], network['b3'] a1 = np.dot(x, W1) + b1 z1 = sigmoid(a1) a2 = np.dot(z1, W2) + b2 z2 = sigmoid(a2) a3 = np.dot(z2, W3) + b3 y = softmax(a3) return yx, t = get_data() # 取出数据network = init_network()accuracy_cnt = 0for i in range(len(x)): y = predict(network, x[i]) p= np.argmax(y) # 获取概率最高的元素的索引 if p == t[i]: accuracy_cnt += 1print("Accuracy:" + str(float(accuracy_cnt) / len(x))) 这三个函数实现了神经网络的推理处理，然后评价识别精度（accuracy）： 获取MNIST的数据集，生成网络。 用 for 语句逐一取出保存在 x 中的图像数据，用 predict() 函数进行分类。「predict() 函数以 NumPy 数组的形式输出各个标签对应的概率」 取出这个概率列表中的最大值的索引，作为预测结果。「np.argmax(x) 将获取被赋给参数 x 的数组中的最大值元素的索引」 比较神经网络所预测的答案和正确解标签，将回答正确的概率作为识别精度 「注:」此处是假设学习已经完成，学习中的参数保存在sample_weight.pkl文件中，在推理阶段，直接加载这些学习到的参数 在刚才的例子中，作为一种预处理，我们将各个像素值除以 255，进行了简单的正规化。实际上，很多预处理都会考虑到数据的整体分布。比如，利用数据整体的均值或标准差，移动数据，使数据整体以 0 为中心分布，或者进行正规化，把数据的延展控制在一定范围内。除此之外，还有将数据整体的分布形状均匀化的方法，即数据白化(whitening)等。 批处理多维数组对应维度的元素个数一致，输入由784个元素组成的一维数组，最终输出元素个数为10的一维数组： 这是只输入一张图像数据时的处理流程。 比如，我们想用 predict()函数一次性打包处理 100 张图像。为此，可以把 x 的形状改为 100 × 784，将100 张图像打包作为输入数据： 此时，输入的100张图像的结果被一次性输出了。 12345678910111213x, t = get_data()network = init_network()batch_size = 100 # 批数量accuracy_cnt = 0for i in range(0, len(x), batch_size): x_batch = x[i:i+batch_size] y_batch = predict(network, x_batch) p = np.argmax(y_batch, axis=1) accuracy_cnt += np.sum(p == t[i:i+batch_size])print("Accuracy:" + str(float(accuracy_cnt) / len(x))) 批处理代码实现中的不同之处： 首先是range()函数： range(start, end)生成一个start到end-1之间的整数构成的列表 range(start, end, step)下一个元素会增加step x[i:i+batch_n]会取出从第 i 个到第 i+batch_n 个之间的数据。 通过 argmax() 获取值最大的元素的索引。不过这里需要注意的是，我们给定了参数 axis=1。这指定了在 100 × 10 的数组中，沿着第 1 维方向(以第 1 维为轴)找到值最大的元素的索引(第 0 维对应第 1 个维度)。 最后，比较一下以批为单位进行分类的结果和实际的答案 本章介绍的神经网络和上一章的感知机在信号的按层传递这一点上是相同的，但是，向下一个神经元发送信号时，改变信号的激活函数有很大差异。神经网络中使用的是平滑变化的 sigmoid函数，而感知机中使用的是信号急剧变化的阶跃函数。 神经网络学习 “学习”是指从训练数据中自动获取最优权重参数的过程。为了使神经网络能进行学习，将导入损失函数这一指标。而学习的目的就是以该损失函数为基准，找出能使它的值达到最小的权重参数。为了找出尽可能小的损失函数的值，利用了函数斜率的梯度法。 误差反向传播法 数值微分虽然简单，也容易实现，但缺点是计算上比较费时间。误差反向传播法能够高效计算权重参数的梯度。正确理解误差反向传播法，有两种方法：数学式和计算图 与学习相关的技巧 神经网络的学习中一些重要观点，主题涉及寻找最优权重参数的最优化方法、权重参数的初始值、超参数设定方法等。为了应对过拟合，还将介绍权值衰减、Dropout 等正则化方法，并进行实现。 卷积神经网络 本章主题是卷积神经网络（CNN），CNN用于图像识别、语音识别等场合，在图像识别比赛中，基于深度学习的方法几乎都以CNN为基础。 深度学习 深度学习是加深了层的深度神经网络。基于之前介绍的网络，只需通过叠加层，就可以创建深度网络。 关于神经网络，已经学了很多：构成神经网络的各种层、学习时的有效技巧、对图像特别有效的CNN、参数的最优方法等。本章将这些知识汇总起来，创建一个深度网络，挑战MNIST数据集的手写数字识别。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02 熟悉Urllib库]]></title>
    <url>%2F2018%2F12%2F12%2FPython-data-analysis02%2F</url>
    <content type="text"><![CDATA[三、Urllib库1. Urllib基础方法 urlretrieve() 爬一个网页 urlcleanup() 清除urlretrieve()生成的缓存 info() 展现基本环境信息 getcode() 当前网页的状态码 geturl() 当前网页的网址 1234567891011import urllib.requestimport sslssl._create_default_https_context = ssl._create_unverified_contexturllib.request.urlretrieve("http://hellobi.com",filename="/Users/biandudu/Documents/webcrawerfiles/1.html")urllib.request.urlcleanup()file = urllib.request.urlopen("http://www.hellobi.com"，timeout=5)print(file.info())print(file.getcode())print(file.geturl()) 2. 超时设置 并抛出异常 有些网站反应快，我们希望2秒钟没有反应，则判断为超时，那么此时，timeout的值就是2，再比如，有些网站服务器反应慢，那么此时，我们希望100秒没有反应，才判断为超时，那么此时timeout的值就是100。 1234567891011121314import urllib.requestimport sslssl._create_default_https_context = ssl._create_unverified_contextfor i in range(1,30): try: file = urllib.request.urlopen("http://hellobi.com", timeout=0.5) data = file.read() print(len(data)) except Exception as e: print("异常："+str(e))file.close() 3. 自动模拟HTTP请求 客户端如果要与服务器端进行通信，需要通过http请求进行，http请求有很多种，我们在此会讲post与get两种请求方式。比如登陆、搜索某些信息的时候会用到。 12345678910111213import urllib.requestimport sslssl._create_default_https_context = ssl._create_unverified_contextkeywd = "张译天"keywd = urllib.request.quote(keywd) # 对中文编码url = "http://www.baidu.com/s?wd="+keywd+"&amp;ie=utf-8&amp;tn=96542061_hao_pg"req = urllib.request.Request(url)data = urllib.request.urlopen(req).read()fh = open("/Users/biandudu/Documents/webcrawerfiles/2.html","wb")fh.write(data)fh.close() 自动提交post请求首先登陆这个网站：www.iqianyue.com/mypost/ 并分析源码 12345678910111213141516171819import urllib.requestimport urllib.parseimport sslssl._create_default_https_context = ssl._create_unverified_context# 设置表单内容url = "http://www.iqianyue.com/mypost/"mydata = urllib.parse.urlencode(&#123; "name":"ceo@sfsfd", "pass":"1232jas"&#125;).encode("utf-8") # 设置对应的信息，对应的编码# 封装请求req = urllib.request.Request(url,mydata) # 提交到的地址，提交的数据data = urllib.request.urlopen(req).read() # urlopen将对应请求提交过去，爬数据fh = open("/Users/biandudu/Documents/webcrawerfiles/3.html","wb") # 写入本地文件，wb二进制写入fh.write(data)fh.close() Tips： 找到登录，只需要关注 form 里的 name属性 找不到登录，隐藏在js文件中，我们需要通过 抓包 来进行分析 4. 异常处理 301 Moved Permanently 重定向到新的URL，永久性 302 Found 重定向到临时的URL，非永久性 304 Not Modified 请求的资源未更新 400 Bad Request 非法请求 401 Unauthorized 请求未经授权 403 Forbidden 禁止访问 404 Not Found 未找到对应页面 500 Internal Server Error 服务器内部错误 501 Not Implemented 服务器不支持实现请求所需要的功能 URLError和HTTPError12345678910111213import urllib.errorimport urllib.requestimport sslssl._create_default_https_context = ssl._create_unverified_contexttry: urllib.request.urlopen("http://blog.csdksdfjs.net/dsd") # csdn爬取会被屏蔽except urllib.error.URLError as e: # 捕获异常 if hasattr(e,"code"): # 是否有这个状态码属性，判断有没有code print(e.code) if hasattr(e,"reason"): # 判断是否有reason这个属性 print(e.reason) 5. 浏览器伪装技术 我们可以试试爬取csdn博客，我们发现会返回403，因为对方服务器会 对爬虫进行屏蔽。此时，我们需要伪装成浏览器才能爬取。浏览器伪装我们一般通过报头进行，接下来我们通过实战分析一下。 如果没有伪装会报403禁止访问错误1234567891011121314import urllib.requestimport sslssl._create_default_https_context = ssl._create_unverified_contexturl = "https://ask.hellobi.com/blog/weiwei/5322"headers=("User-Agent","Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36")opener = urllib.request.build_opener() # 创建一个opener对象opener.addheaders = [headers] # 添加报头信息data = opener.open(url).read()fh = open("/Users/biandudu/Documents/webcrawerfiles/6.html","wb")fh.write(data)fh.close() 6. Python新闻爬虫实战 需求:将新浪新闻首页(http://news.sina.com.cn/)所有新闻都爬到 本地。 思路:先爬首页，通过正则获取所有新闻链接，然后依次爬各新闻，并存储到本地。 12345678910111213141516import urllib.requestimport reimport sslssl._create_default_https_context = ssl._create_unverified_contextdata = urllib.request.urlopen("http://news.sina.com.cn/").read()data2 = data.decode("utf-8","ignore") # 有时候设置utf-8还会报错，就添加一个ignorepat='href="(https://news.sina.com.cn/.*?)"'allurl = re.compile(pat).findall(data2)for i in range(0,len(allurl)): thisurl = allurl[i] file = "/Users/biandudu/Documents/webcrawerfiles/sinanews/"+str(i)+".html" urllib.request.urlretrieve(thisurl,file) 作业三: 提取出版社信息并写入文件中12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from urllib import requestimport re,xlwt,datetimehtml=request.urlopen("https://read.douban.com/provider/all").read() #读取网页源代码内容html.decode("utf-8")wzgz="&lt;a href=\"(.*?)\" class=\"provider-item\"&gt;&lt;div class=\"col-media\"&gt;&lt;div class=\"cm-left avatar\"&gt;&lt;div class=\"avatar\"&gt;&lt;img src=\"(.*?)\"/&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"cm-body\"&gt;&lt;div class=\"name\"&gt;(.*?)&lt;/div&gt;&lt;div class=\"works-num\"&gt;(.*?) 部作品在售&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/a&gt;"xx=re.compile(wzgz).findall(str(html,"utf-8")) #通过正则表达式匹配在网页源代码中提取所需内容#print(xx)#创建workbook和sheet对象workbook = xlwt.Workbook()sheet1 = workbook.add_sheet('sheet1',cell_overwrite_ok=True)#初始化excel样式style = xlwt.XFStyle()#为样式创建字体font = xlwt.Font()font.name = 'Times New Roman'font.bold = True#设置样式的字体style.font = font#在sheet1表的第1行设置字段名称并写入数据sheet1.write(0,0,"序号",style)sheet1.write(0,1,"出版社-URL",style)sheet1.write(0,2,"LOGO-URL",style)sheet1.write(0,3,"出版社名称",style)sheet1.write(0,4,"在售作品数量",style)a=0 #定义行号初始值h=0 #定义在售数量初始值for i in xx: #print(str(a+1),i[0]) sheet1.write(a+1,0,a+1,style) #在第a+1行第1列写入序号 sheet1.write(a+1,1,"https://read.douban.com"+str(i[0]),style) #在第a+1行第2列写入出版社URL sheet1.write(a+1,2,i[1],style) #在第a+1行第3列写入LOGO-URL sheet1.write(a+1,3,i[2],style) #在第a+1行第4列写入出版社名称 sheet1.write(a+1,4,int(i[3]),style) #在第a+1行第5列写入在售数量 h+=int(i[3]) #在售数量累计求和 a+=1 if a==a: #判断XX列表是否遍历结束，并在sheet1表尾行写入在售数量求和的值 t=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S") t1=datetime.datetime.now().strftime("%Y%m%d%H%M%S") sheet1.write(a+1,3,"合计",style) #在sheet1表尾行写入“合计” sheet1.write(a+1,4,h,style) #在sheet1表尾行写入在售数量累计值 sheet1.write(a+2,3,"采集时间",style) #在sheet1表尾行写入数据采集时间 sheet1.write(a+2,4,t,style) #在sheet1表尾行写入数据采集时间workbook.save("d:/豆瓣出版社汇总表"+str(t1)+".xls") #保存该excel文件,有同名文件时无法直接覆盖print("数据写入excel文件完毕！")print("在售书数量合计："+str(h))]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Data Analysis</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 爬虫入门]]></title>
    <url>%2F2018%2F12%2F12%2FPython-data-analysis%2F</url>
    <content type="text"><![CDATA[一. Python初识一些简单概念 Python中没有数组的概念 列表[] 123可以存储元素: abc=[“My”, “You”]如果要选取列表中的元素 abc[1] 输出 ‘You’要替换列表中的元素: abc[1]=”He” 元祖() 12Cde=(“My”, “You”)选取元素同样用 cde[1] 列表和元组的区别 列表中的元素是可以修改的 但是元组这种数据类型呢 是不能修改的 集合 123parame = &#123;value01,value02,...&#125;或者set(value) 字典 1d = &#123;key1 : value1, key2 : value2 &#125; 简单代码展示函数的使用： 123456789101112def abc(): print("abcd!")def function1(a,b): if(a&gt;b): print(a) else: print(b)function1(10,19)abc() 模块： 12345import data_05functiondefinitiondata=data_05functiondefinition.function1(19,10)print(data) 文件写入： 12345fh = open("/Users/biandudu/Desktop/PythonDataAnalysis/file1.txt","w")contents1 = "我是文件内容"fh.write(contents1)fh.close() 文件读取： 1234567891011fh1 = open("/Users/biandudu/Desktop/PythonDataAnalysis/file2.txt","r")# data2 = fh1.read()# print(data2)while True: line = fh1.readline() if len(line)==0: break print(line)fh1.close() 异常抛出： 1234567# 中间异常不处理，会导致程序的崩溃try: print("my") printasa("sss")except Exception as err: print(err) print("hello") 作业作业一：输出乘法口诀12345for i in range(1,10): for j in range(1,i+1): print(str(i)+"*"+str(j)+"="+str(i*j)+" ",end="") # end=""意思是末尾不换行，加空格 print() 作业二：将多个Excel表格内容合并思路可以采用一些操作Excel的模块来实现，比如xlrd、xlwt、openyxl、xlsxwriter等模块。xlrd模块主要用于读取Excel表，xlwt与xlsxwriter模块主要用于将数据写入表中，两个模块任选其一即可，但是xlwt与xlsxwriter模块不支持修改表，所以在信息追加的时候会较麻烦，其实这个问题至少有两种思路解决： A、换成其他模块，比如openpyxl等，这个模块实现起来会相对简单一些 B、仍然使用xlwt与xlsxwriter等模块，但是先将每次读取的信息存储到list（列表）中，然后，最后一次写入。这一种方式稍微复杂一些 此外，还有一个难点，即一个表格中有多个sheet，我们希望能够用程序自动获取这多个sheet，然后将各sheet中的内容一并写入到最终表格中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import xlrd,xlsxwriter #设置要合并的所有文件allxls=["F:/第一个测试文件.xls","F:/第二个测试文件.xls","F:/第三个测试文件.xls"]#设置合并到的文件endxls ="F:/endxls.xls"#打开表格def open_xls(file): try: fh=xlrd.open_workbook(file) return fh except Exception as e: print(str("打开出错，错误为："+e))#获取所有sheetdef getsheet(fh): return fh.sheets()#读取某个sheet的行数def getnrows(fh,sheet): table=fh.sheets()[sheet] content=table.nrows return content#读取某个文件的内容并返回所有行的值def getfilect(fh,fl,shnum): fh=open_xls(fl) table=fh.sheet_by_name(shname[shnum]) num=getnrows(fh,shnum) lenrvalue=len(rvalue) for row in range(0,num): rdata=table.row_values(row) rvalue.append(rdata) #print(rvalue[lenrvalue:]) filevalue.append(rvalue[lenrvalue:]) return filevalue#存储所有读取的结果filevalue=[]#存储一个标签的结果svalue=[]#存储一行结果rvalue=[]#存储各sheet名shname=[]#读取第一个待读文件，获得sheet数fh=open_xls(allxls[0])sh=getsheet(fh)x=0for sheet in sh: shname.append(sheet.name) svalue.append([]) x+=1#依次读取各sheet的内容#依次读取各文件当前sheet的内容for shnum in range(0,x): for fl in allxls: print("正在读取文件："+str(fl)+"的第"+str(shnum)+"个标签的…") filevalue=getfilect(fh,fl,shnum) svalue[shnum].append(filevalue) #print(svalue[0]) #print(svalue[1])#由于append具有叠加关系，分析可得所有信息均在svalue[0][0]中存储#svalue[0][0]元素数量为sheet标签数(sn)*文件数(fn)sn=xfn=len(allxls)endvalue=[]#设置一个函数专门获取svalue里面的数据，即获取各项标签的数据def getsvalue(k): for z in range(k,k+fn): endvalue.append(svalue[0][0][z]) return endvalue#打开最终写入的文件wb1=xlsxwriter.Workbook(endxls)#创建一个sheet工作对象ws=wb1.add_worksheet()polit=0linenum=0#依次遍历每个sheet中的数据for s in range(0,sn*fn,fn): thisvalue=getsvalue(s) tvalue=thisvalue[polit:] #将一个标签的内容写入新文件中 for a in range(0,len(tvalue)): for b in range(0,len(tvalue[a])): for c in range(0,len(tvalue[a][b])): #print(linenum) #print(c) data=tvalue[a][b][c] ws.write(linenum,c,data) linenum+=1 #叠加关系，需要设置分割点 polit=len(thisvalue)wb1.close() 二. 爬虫初识 简单来说，网络爬虫就是自动从互联网中定向或不定向地采集信息的一种程序。网络爬虫有很多种类型，常用的有通用网络爬虫（搜索引擎）、聚焦网络爬虫（定向采集「信息过滤提取规则」）等。 通用网络爬虫可以应用在搜索引擎中，聚焦网络爬虫可以从互联网中自动采集信息并代替我们筛选出相关的数据出来 搜索引擎 采集金融数据 采集商品数据 自动过滤广告 采集竞争对手的客户数据 采集行业相关数据，进行数据分析 ……. 爬虫运行原理通用爬虫 聚焦网络爬虫 对爬取目标的定义和描述。在聚焦网络爬虫中，我们首先要依据爬取需求定义好该聚焦网络爬虫爬取的目标，以及进行相关的描述 获取初始的URL 根据初始的URL爬取网页，并获得新的URL 从新的URL中 过滤 掉与爬取目标无关的链接。因为聚焦网络爬虫对网页的抓取是有目的性，所以与目标无关的网页将会被过滤掉。同时，也需要将已爬取的URL地址存放到一个列表中，用于去重和判断爬取的进程 将 过滤后的链接放到URL队列 中 从URL队列中，根据 搜索算法 ，确当URL的 优先级 ，并确定下一步要抓取的URL地址。在通用网络爬虫中，下一步爬取那些URL，是不太重要的，但是在聚焦网络爬虫中，由于其具有目的性，故而下一步爬取哪些URL地址相对来说是比较重要的。对于聚焦网络爬虫来说，不同的爬取顺序，可能导致爬虫的执行效率不同，所以，我们需要依据搜索策略来确定下一步需要爬取那些URL地址 从下一步要爬取的URL地址中，读取新的URL，然后依据新的URL地址爬取网页，并重复上述爬取的过程 满足系统中设置的停止条件时，或无法获取新的URL地址时，停止爬行 正则表达式什么是正则表达式 提取出关键的数据，可以通过一些表达式进行提取，正则表达式就是其中一种进行数据筛选的表达式。 原子 原子是正则表达式中最基本的组成单位，每个正则表达式中至少要包含一个原子。常见的原子类型有: 普通字符 非打印字符 通用字符 原子表 普通字符和非打印字符123456789101112131415161718import repat="yue"pat2="\n" # 非打印字符string="http://yum.iqianyue.com"string2="abcd"string3='''absbddfsdfsfdfsfdfsf''' # 三引号可以加入换行的句子rst1=re.search(pat,string)rst2=re.search(pat,string2)rst3=re.search(pat2,string3)print(rst1)print(rst2)print(rst3) 通用字符和原子表\w——匹配任意字母数字下划线 \d ——匹配任意十进制数 \s ——匹配空白字符 \W ——和\w互补的关系，匹配任意除了字母数字下划线的字符 \D ——和\d互补 \S ——和\s互补 1234567891011121314import repat3 = "\w\dpython\w"pat4 = "pytho[ajs]n" # ajs任意其一都可以匹配 [原子表]string = "hohoiha3python3oioih"string2 = "sfsdkfpythoandsfd"rst3 = re.search(pat3,string)rst4 = re.search(pat4,string2)print(rst3)print(rst4) 元字符 所谓的元字符，就是正则表达式中具有一些特殊含义的字符，比如重复N次前面的字符等。 全部元字符：菜鸟教程——元字符 12345678910111213import repat = ".python..."pat2 = "python|php"string = "sfafapythonfaf"string2 = "shshdsphpskfdsfpythonsfsdf"rst = re.search(pat,string)rst2 = re.search(pat2,string2)print(rst)print(rst2) 模式修正符 所谓的模式修正符，即可以在不改变正则表达式的情况下，通过模式修正符改变正则表达式的含义，从而实现一些匹配结果的调整等功能。 模式修正符 说明 i 表示在和模式进行匹配进不区分大小写 m 将模式视为多行，使用^和$表示任何一行都可以以正则表达式开始或结束 s 如果没有使用这个模式修正符号，元字符中的”.”默认不能表示换行符号,将字符串视为单行 x 表示模式中的空白忽略不计 e 正则表达式必须使用在preg_replace替换字符串的函数中时才可以使用(讲这个函数时再说) A 以模式字符串开头，相当于元字符^ Z 以模式字符串结尾，相当于元字符$ U 正则表达式的特点：就是比较“贪婪”，使用该模式修正符可以取消贪婪模式 123456789import repat = ".python..."string = "sfafaPythonfaf"rst = re.search(pat,string,re.I) # 模式修正；不区分大小写print(rst) 贪婪模式与懒惰模式 贪婪模式的核心点就是尽可能多的匹配，而懒惰模式的核心点就是尽可能少的匹配。 123456789101112import repat = "p.*y" # 贪婪模式pat2 = "p.*?y"string = "sfafapythonfafsfsfsfpythonsdfsfpython"rst = re.search(pat,string)rst2 = re.search(pat2,string)print(rst)print(rst2) 正则表达式函数 正则表达式函数有re.match()函数、re.search()函数、全局匹配函数、re.sub()函数 re.match() 如果开头不是就直接返回None re.search 可以出现在字符串的任意位置 re.sub() re.compile 可以搜索匹配全部满足条件的 1rst = re.compile(pat1).findall(string) 常见正则实例123456789import repat = "[a-zA-Z]+://[^\s]*[.com|.cn]"string = '&lt;a herf="http://www.baidu,com&gt;hshfhksdf&lt;/a&gt;'rst = re.compile(pat).findall(string)print(rst) 简单的爬虫提取CSDN的QQ群1234567891011121314import urllib.requestimport reimport sslpat = "学员群(.*?)&lt;/span&gt;"ssl._create_default_https_context = ssl._create_unverified_contextdata = urllib.request.urlopen("https://edu.csdn.net/course/detail/4358").read()result = re.compile(pat).findall(str(data))print(result)]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Data Analysis</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Heart of a Lio]]></title>
    <url>%2F2018%2F10%2F17%2FLioMessi%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/Videos/Gatorade%20-%20Heart%20of%20a%20Lio.mp4","pic":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/2019-08-28%2F1566963521.png"},"danmaku":{"id":"LioMessi","api":"https://dplayer.moerats.com/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>Share</tag>
        <tag>Inspirational</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM02-Java内存区域与内存溢出异常]]></title>
    <url>%2F2018%2F10%2F05%2FJVMpro02%2F</url>
    <content type="text"><![CDATA[概述对C、C++开发人员来说，在内存管理领域，他们有着最高的权力，但同时肩负着每一个对象从开始到终结的维护责任。而对于Java程序员而言，由于JVM的自动内存管理机制，Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将为成为一项十分艰难的工作。 运行时数据区域Java 虚拟机在执行 Java 程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java 虚拟机规范将 JVM 所管理的内存分为以下几个运行时数据区：程序计数器、Java 虚拟机栈、本地方法栈、Java 堆、方法区。下面详细阐述各数据区所存储的数据类型。 程序计数器(Program Counter Register) 作用：记录当前线程所执行到字节码的行号。字节码解释器工作的时就是通过改变这个计数器的值来选取下一条所需要执行的字节码指令。 意义：由于JVM的多线程是通过线程轮换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令。所以为了实现并行，并保证各个线程指令安全顺利执行，每条线程都需要有一个独立的程序计数器。 记录内容： 如果线程正在执行一个Java方法，计数器记录的是正在执行的虚拟字节码指令的地址。 如果正在执行Native方法，计数器值为空(Undefined)。 可能出现的异常：此内存区域是唯一一个在Java虚拟机规范中没有任何内存溢出异常(OutOfMemoryError)的区域。 Java虚拟机栈(Java Virtual Machine Stacks) Java内存区常被分为堆内存（Heap）和栈内存（Stack），其中栈内存其实指的就是虚拟机栈，或者说是虚拟机栈中的局部变量表部分 作用：虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个线帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 特点： Java虚拟机栈也是线程私有的，它的生命周期与线程相同。 每一个方法从调用直至执行完成的过程就对应着一个线帧在虚拟机栈中从入栈到出栈的过程。 存储内容： 局部变量表，包括编译期可知的各种基本数据类型、对象引用(reference类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或次对象相关位置)、指向一条字节码指令的returnAddress类型 值得注意的是：局部变量表所需的内存空间在编译期间完成分配。在方法运行的阶段是不会改变局部变量表的大小的 可能出现的异常： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 如果在动态扩展内存的时候无法申请到足够的内存，就会抛出OutOfMemoryError异常。 本地方法栈(Native Method Stack) 特点：与虚拟机栈类似，区别在于虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法则为虚拟机所使用的Native方法服务 可能抛出的异常：与虚拟机栈一样，本地方法栈区域也乎抛出StackOverflowError和OutOfMemoryError异常。 Java堆(Java Heap) Java堆是垃圾收集器管理的主要区域（GC堆），可细分为：新生代，老年代，按空间可细分为：Eden空间，From Survivor空间，To Survivor空间 作用： Java Heap是被所有线程共享的一块区域，在虚拟机启动时创建。 此内存区域的唯一目的就是存放对象实例，让对象实例更好地分配内存。 垃圾回收机制(GC)：堆是垃圾收集器管理的主要区域，可以更好地回收内存。 存储内容： 存放对象实例，几乎所有的对象实例都在这里进行分配。堆可以处于物理上不连续的内存空间，只要逻辑上是连续的就可以。 值得注意的是：在JIT编译器等技术的发展下，所有对象都在堆上进行分配已变得不那么绝对。有些对象实例也可以分配在栈中。 可能出现的异常： 实现堆可以是固定大小的，也可以通过设置配置文件设置该为可扩展的。 如果堆上没有内存进行分配，并无法进行扩展时，将会抛出OutOfMemoryError异常。 方法区(Method Area) 作用：方法区和Java堆一样，是各个线程共享的内存区域。 意义：对运行时常量池、常量、静态变量等数据做出了规定。 存储内容：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 可能出现的异常：当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池(Runtime Constant Pool) 作用用于存放编译期生成的各种字面量和符号的引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 特征运行时常量池对于Class文件常量池的另一个特征是具备动态性，在运行期间也可能将新的常量放入池中，例如String类的intern() 可能抛出的异常运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 直接内存(Direct Memory) 作用JDK1.4中新加入NIO类，引入一种基于通道与缓冲的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffeer对象作为这块内存的引用进行操作。（在一些场景中显著提高性能，因为避免了Java堆和Native堆中来回复制数据） 可能抛出的异常服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常会忽略直接内存，使得内存区域总和大于物理内存限制(包括物理等和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。 HotSpot虚拟机对象对象创建 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。 内存分配的两种方式： 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定 指针碰撞Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离 空闲列表Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值 对象的内存布局 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding） HotSpot虚拟机的对象头包括两部分信息： Mark Word第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit。 类型指针对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。 对象的访问定位 建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。 目前主流的访问方式有使用句柄和直接指针两种： 句柄访问 直接指针访问 对比优势： 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。Sun HotSpot虚拟机是使用第二种方式进行对象虚拟机访问的。 OutOfMemoryError异常 除了程序计数器，其他运行时区域都有可能抛出OutOfMemoryError异常 Java堆溢出 内存泄露查看泄露对象到GC Roots的引用链，定位泄露代码位置。 内存溢出如果不存在泄露，即内存中的对象确实都还必须活着，检查JVM堆参数（-Xmx与-Xms），调大参数，检查代码是否存在某些对象生命周期过长，持有状态过长的情况，减少程序运行期的内存消耗。 虚拟机栈、本地方法栈溢出HotSpot不区分虚拟机栈和本地方法栈，栈容量只能由-Xss参数设定。 StackOverFlow：线程申请的栈深度超过允许的最大深度 OutOfMemoryError： 虚拟机扩展时无法申请到足够的内存空间 StackOverFlow的情况：递归调用方法，定义大量的本地变量，增大此方法帧中本地变量表的长度。 OutOfMemoryError：多线程下的内存溢出，与栈空间是否足够大并不存在任何联系。为每个线程的栈分配的内存越大（参数-Xss），那么可以建立的线程数量就越少，建立线程时就越容易把剩下的内存耗尽，越容易内存溢出。在这种情况下，如果不能减少线程数目或者更换64位虚拟机时，减少最大堆和减少栈容量能够换区更多的线程。 方法区和运行时常量池溢出 运行时常量池String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的引用。JDK7的intern()方法的实现有所不同，当常量池中没有该字符串时，不再是在常量池中创建与此String内容相同的字符串，而改为在常量池中记录堆中首次出现的该字符串的引用，并返回该引用 方法区方法区用于存放Class的相关信息，如果运行时产生大量的类去填满方法区，就可能发生方法区的内存溢出。 例如主流框架Spring、Hibernate对大量的类进行增强时，利用CGLib字节码生成动态类；大量JSP或动态JSP(JSP第一次运行时需要编译为Java类）。 本机直接内存溢出Java虚拟机可以通过参数-XX:MaxDirectMemorySize设定本机直接内存可用大小，如果不指定，则默认与java堆内存大小相同。JDK中可以通过反射获取Unsafe类(Unsafe的getUnsafe()方法只有启动类加载器Bootstrap才能返回实例)直接操作本机直接内存。通过使用-XX:MaxDirectMemorySize=10M，限制最大可使用的本机直接内存大小为10MB。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Reading</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM01-走近Java]]></title>
    <url>%2F2018%2F10%2F04%2FJVMpro01%2F</url>
    <content type="text"><![CDATA[第一章的内容大致翻阅了一下感觉还是挺多的，大致都是关于Java的特点、发展史、Java未来的走向以及阅读OpenJDK源码的指导。对于第一章的内容我也准备做一些总结，以备以后的扩充和温故。 Java的特性和优点 提升了开发效率 结构严谨，面向对象 摆脱硬件束缚，“一次编写，到处运行” 相对安全的内存管理和访问机制，避免了绝大部分的内存泄漏和指针越界问题(内存回收机制) 热点代码检测和运行时编译及优化，运行次数越多性能越好 完善的应用程序接口(第三方类库) Java的技术体系Sun公司所定义的Java技术体系包括以下几个组成部分： Jav程序设计语言 各种硬件平台上的Java虚拟机 Class文件格式（面向对象的载体） Java API库（Java自带可调用的库） 来自商业机构和开源社区的第三方Java类库（封装好的库） JDK(Java Development Kit)：1+2+4，也就是支持Java开发的最小环境。JRE(Java Runtime Environment)：JavaSE(Java Standard Edition)的API+虚拟机。 Java技术体系模块图： 按照技术服务领域划分，Java技术体系可以分为4个平台： JavaCard：支持一些Java小程序运行在小内存设备上的平台，如智能卡 JavaME(Micro Edition)：支持Java运行在移动终端上的平台，对JavaAPI有所精简，并加入了针对移动端的支持 JavaSE(Standard Edition)：支持面向桌面级应用(如Windows下的应用程序)的Java平台，提供了完整的Java核心API。 JavaEE(Enterprise Edition)：支持使用多层架构的企业应用(如ERP、CRM应用)的Java平台，对JavaSE API做了大量的扩充并提供相关的部署支持 入门版(Card)👉阉割版(ME)👉标配(SE)👉Pro(EE) Java发展史 1991年，提出绿色项目（猜想可能是针对c/c++中的垃圾回收，内存处理之类的问题而提出的一个更友好的语言概念）; 创立oak（java语言的前身，为了解决家用电器的通信问题而诞生，没有理想市场，不久后将要失败）;设计出硬件原型；同时设计出注释器。 1992年，更名为java; Star-Seven Prototype(七星原型，度娘上查了好久没找到，有机会去翻墙再查吧。 猜想可能是当时那个版本的七大基本规范吧。。。先记下来); 1993年，TV Set-top Box ( 可能是在电视机顶盒 试用吧)；发布应用开发平台。。 1994年，LiveOak（可能是oak发展有一些起色的意思吧。英语不好真的很忧伤。）;发布Era浏览器；继而发布HotJava浏览器；设计出java编译器； 1995年，正式注册java,并相继获得Netscape,Oracle,Microsoft的支持，HotJava进一步发展。 1996年，java1.0发布。 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术 1997年，java1.1发布。 1997年9月，JavaDeveloperConnection社区成员超过十万 。 1998年2月，JDK1.1被下载超过2,000,000次 1998年，java1.2发布。 1998年12月8日，JAVA2企业平台J2EE发布。 1999年6月，SUN公司发布Java的三个版本：标准版、企业版和微型版（J2SE、J2EE、J2ME） 2000年，java1.3发布。 2002年，java1.4发布，自此Java的计算能力有了大幅提升。 2004年，java5.0发布，J2SE1.5发布，是Java语言的发展史上的又一里程碑事件。为了表示这个版本的重要性，J2SE1.5更名为J2SE5.0 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字“2”：J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。 2006年，java6.0发布，并半开源。 2010年，Oracle收购Sun公司，苹果不再支持java 2011年，java7.0发布。 2014年，java8.0发布。 Java虚拟机发展史 Sun Classic/Exact VM(初代)：世界上第一款商用Java虚拟机，Sun公司研发，主要特点：慢。 Sun HotSpot VM(新技术)：目前使用范围最广的虚拟机，是Sun从一家名为Longview Technologies公司收购来的。主要特点：热点探测技术。 Sun Mobile-Embedded VM/Meta-Circular VM(探索)：面对移动嵌入式市场的探索 BEA JRockit /IBM J9 VM(其它公司)：当时号称”世界上最快的Java虚拟机” Azul VM/BEA Liquid VM(特定硬件)：高性能Java的武器，特定硬件可以最大限度地发挥硬件的能力，提升Java程序的执行能力。 Apache Harmony/Google Android Dalvik VM(高速发展)：安卓虚拟机。是Android平台的核心组成部分之一。 Microsoft JVM(彩蛋)：2333 Java的未来 模块化：说起来也就是解除功能模块和功能模块之间的耦合，降低系统维护消耗。(书上也没仔细说，大家看着标题脑补一下也就知道是干嘛的) 混合语言：对系统来说是好事(因为不同语言有不同语言的特点 也就是擅长的地方)，但是对于Java程序员的要求也会因此而提高。 多核并行：顺应发展 丰富语法：更新JDK版本 64位虚拟机：现在64位虚拟机速度没有32位快，主要是Java EE对64位虚拟机的要求比较急迫。 自己编译JDK想要一探JDK内部的实现机制，最便捷的路径之一就是自己编译一套JDK，通过阅读和跟踪调试JDK源码去了解Java技术体系的原理，虽然门槛会高一点，但肯定会比阅读各种书籍、文章更加贴近本质。另外，JDK中很多底层方法都是本地化的，需要跟踪这些方法的运作或对JDK进行Hack的时候，都需要自己编译一套JDK。 OpenJDK源码结构图： 123456789101112131415161718192021222324252627282930313233343536373839├─agent Serviceability Agent的客户端实现 ├─make 用来build出HotSpot的各种配置文件 ├─src HotSpot VM的源代码 │ ├─cpu CPU相关代码（汇编器、模板解释器、ad文件、部分runtime函数在这里实现） │ ├─os 操作系相关代码 │ ├─os_cpu 操作系统+CPU的组合相关的代码 │ └─share 平台无关的共通代码 │ ├─tools 工具 │ │ ├─hsdis 反汇编插件 │ │ ├─IdealGraphVisualizer 将server编译器的中间代码可视化的工具 │ │ ├─launcher 启动程序“Java” │ │ ├─LogCompilation 将-XX:+LogCompilation输出的日志（hotspot.log）整理成更容易阅读的格式的工具 │ │ └─ProjectCreator 生成Visual Studio的project文件的工具 │ └─vm HotSpot VM的核心代码 │ ├─adlc 平台描述文件（上面的cpu或os_cpu里的*.ad文件）的编译器 │ ├─asm 汇编器接口 │ ├─c1 client编译器（又称“C1”） │ ├─ci 动态编译器的公共服务/从动态编译器到VM的接口 │ ├─classfile 类文件的处理（包括类加载和系统符号表等） │ ├─code 动态生成的代码的管理 │ ├─compiler 从VM调用动态编译器的接口 │ ├─gc_implementation GC的实现 │ │ ├─concurrentMarkSweep Concurrent Mark Sweep GC的实现 │ │ ├─g1 Garbage-First GC的实现（不使用老的分代式GC框架） │ │ ├─parallelScavenge ParallelScavenge GC的实现（server VM默认，不使用老的分代式GC框架） │ │ ├─parNew ParNew GC的实现 │ │ └─shared GC的共通实现 │ ├─gc_interface GC的接口 │ ├─interpreter 解释器，包括“模板解释器”（官方版在用）和“C++解释器”（官方版不在用） │ ├─libadt 一些抽象数据结构 │ ├─memory 内存管理相关（老的分代式GC框架也在这里） │ ├─oops HotSpot VM的对象系统的实现 │ ├─opto server编译器（又称“C2”或“Opto”） │ ├─prims HotSpot VM的对外接口，包括部分标准库的native部分和JVMTI实现 │ ├─runtime 运行时支持库（包括线程管理、编译器调度、锁、反射等） │ ├─services 主要是用来支持JMX之类的管理功能的接口 │ ├─shark 基于LLVM的JIT编译器（官方版里没有使用） │ └─utilities 一些基本的工具类 └─test 单元测试]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Reading</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何编写Alfred Workflow]]></title>
    <url>%2F2018%2F09%2F21%2FAlfredKnowledgeBase%2F</url>
    <content type="text"><![CDATA[语言基础Alfred官方并没有给出详细的Alfred Workflow撰写教程，原因是写一个Workflow的实际门槛是很低的。他们大部分是使用一门了解的语言来书写的。在Alfred也罗列了这些语言： 包括： bash, zsh, PHP, Ruby, Python, Perl, AppleScript, JavaScript 开发者只需要会使用上面任意的语言，就可以开始编写自己的Alfred Workflow了。 如何使用Alfred？Alfred有个很好的地方，就是能在Alfred中看到你所使用的Alfred的具体实现，workflow也都是开源的。大部分workflow都可以直接在Alfred的workflows选项卡下看到，部分workflow可能需要调用一些脚本文件，你也可以进入对应的workflow文件夹下打开具体的脚本文件（可以通过workflows👉Show in Finder打开对应的workflow文件夹） Alfred workflow有几个关键组成部分，包括Triggers、Inputs、Actions、Outputs。 Triggers用于设置快捷键，并不是必备的，因为Option+Space快捷键就可以快捷打开Alfred输入框 Inputs定义了在Alfred输入框中输入对应的keyword调用相关的操作 Action就是keyword调用的操作 Outputs一般用于显示操作的结果，提示操作成功与否，以Post Notification较为常见，通过Mac的notification center提示。 🤨Alfred使用手册🤨 👉[Alfred2.5.1使用全攻略](https://www.maoshu.cc/1934.html) 👉[Alfred：基础功能及设置](https://sspai.com/post/32979) 👉[编写 Alfred 使用的 Workflow](https://www.zhihu.com/question/22301362)]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Alfred</tag>
        <tag>Workflow</tag>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alfred的OSS图床Workflow(python)]]></title>
    <url>%2F2018%2F09%2F20%2FAlfredWorkflowOSS%2F</url>
    <content type="text"><![CDATA[前言什么是Alfred？Alfred依靠它强大的工作流机制，可以极大地提高Mac系统的工作效率。 作为 Mac 上最强大的效率工具，Alfred 在 Spotlight（MacOS X 自带的搜索和快速启动引擎）的基础上优化了快速启动与搜索的功能，还引入了 Workflows 等强大的扩展功能，使之成为了一个拥有无限自动化潜力的「工具平台」软件，可以用它来实现近乎一切有关自动的想法。 为什么要使用这个Workflow？因为在编写个人博客，每次插入图片的时候都需要将图片上传到OSS图床，具体需要以下步骤： 截图 保存图片到桌面 打开浏览器 登陆阿里云 打开OSS控制台 上传图片 等待并获取url 回到markdown编辑器粘贴到![]()中 而现在使用这款插件只需要三步： 截图 Toggle Alfred 并键入：OSS 回到markdown编辑器粘贴 好吧，其实主要还是因为穷QAQ，因为不需要折腾的iPic需要订阅，每年¥68。 安装及配置环境 一台MacOS的电脑 Alfred 阿里云OSS python3环境 python3依赖oss2和pyobjc包 👉python3安装教程 安装依赖打开命令行输入：1pip install oss2 1pip install pyobjc 脚本需要修改的参数修改位置：右键OSS - 选择Open in Finder - 修改其中的clipboard_data.py文件 修改下面这三行的内容： 123access_key_id = &apos;&lt;yourAccessKeyId&gt;&apos;access_key_secret = &apos;&lt;yourAccessKeySecret&gt;&apos;bucket_name = &apos;&lt;yourBucketName&gt;&apos; 1bucket = oss2.Bucket(auth, &apos;http://oss-cn-hangzhou.aliyuncs.com&apos;, bucket_name) 👉如何获取AccessKey ID和Secret 如何使用复制一张图片，调用alfred，输入oss命令稍等一小会儿，会显示url和md两种返回格式，点击url或者md便可以获得对应地址在剪切板中，粘贴，所见即所得 👉[GIthub地址](https://github.com/CQHui/oss_upload) **最后，感谢 @[CQhui](https://github.com/CQHui) 写的AlfredWorkflow！**]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Alfred</tag>
        <tag>tech</tag>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识遗传算法]]></title>
    <url>%2F2018%2F09%2F18%2FGeneticAlgorithm01%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/Videos/AI%20learns%20to%20play%20Google%20Chrome%20Dinosaur%20Game%20--%20Can%20you%20beat%20it.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() [Github源码链接](https://github.com/Code-Bullet/Google-Chrome-Dino-Game-AI) 什么是遗传算法？遗传算法的由来 Species to survive, is not the most strong, is not the most intelligent， but those who make a rapid response to change. 物尽天择，适者生存。 查尔斯达尔文在一百多年前提出的“生物进化论”，他证明生物的起源是在遗传、变异、生存斗争和自然选择中，从简单到复杂、从低等到高等不断地发展变化而来的。达尔文的进化论给美国的科学家霍兰德留下了深刻的印象，他从计算机角度思考了这个问题，也就是遗传算法的由来。遗传算法也便继承了“进化论”的思想，将需要解决的问题模拟成一个生物进化的过程，通过复制、交叉、突变等操作产生下一代的解，并逐步淘汰适应度(Fitness)低的解，经过N代自然选择后，会进化出适应度函数值很高的个体。 定义：&emsp;&emsp;遗传算法（Genetic Algorithm, GA）起源于对生物系统所进行的计算机模拟研究。它是模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种高效、并行、全局搜索的方法，能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最佳解。 相关术语 table th:nth-of-type(1){ width: 25%; } table th:nth-of-type(2){ width: 75%; } 相关术语 解释 基因型(genotype) 性状染色体的内部表现 表现型(phenotype) 染色体决定的性状的外部表现，或者说，根据基因型形成的个体的外部表现 进化(evolution) 种群逐渐适应生存环境，品质不断得到改良。生物的进化是以种群的形式进行的 适应度(fitness) 度量某个物种对于生存环境的适应程度 选择(selection) 以一定的概率从种群中选择若干个个体。一般，选择过程是一种基于适应度的优胜劣汰的过程 复制(reproduction) 细胞分裂时，遗传物质DNA通过复制而转移到新产生的细胞中，新细胞就继承了旧细胞的基因。 交叉(crossover) 两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交 变异(mutation) 复制时可能（很小的概率）产生某些复制差错，变异产生新的染色体，表现出新的性状 编码(coding) DNA中遗传信息在一个长链上按一定的模式排列。遗传编码可看作从表现型到基因型的映射 解码(decoding) 基因型到表现型的映射 个体（individual） 指染色体带有特征的实体 种群（population） 个体的集合，该集合内个体数称为种群的大小 遗传算法的应用遗传算法的有趣应用很多，诸如寻路问题，8数码问题，囚犯困境，动作控制，找圆心问题（在一个不规则的多边形中，寻找一个包含在该多边形内的最大圆圈的圆心），TSP问题，生产调度，模式识别，神经网络，自适应控制等。 一个简单的例子求解函数 f(x) = x + 10*sin(5*x) + 7*cos(4*x) 在区间[0,9]的最大值 那么如何通过遗传算法找到这个函数的最大值呢？ 事实上，不管一个函数的形状多么奇怪，遗传算法都能在很短的时间内找到它在一个区间内的(近似)最大值。 👉具体分析 遗传算法思想GA的组成： 编码(产生初始种群)👉创造染色体 个体👉种群 适应度函数 遗传算子(选择、交叉、变异) 运行参数 种群大小 染色体长度 最大迭代次数 交叉概率 变异概率 是否选择精英操作 GA算法特点遗传算法的优点 群体搜索，易于并行化处理； 不是盲目穷举，而是启发式搜索； 适应度函数不受连续、可微等条件的约束，适用范围很广。 容易实现。一旦有了一个遗传算法的程序，如果想解决一个新的问题，只需针对新的问题重新进行基因编码就行；如果编码方法也相同，那只需要改变一下适应度函数就可以了。 遗传算法的缺点 全局搜索能力不强,很容易陷入局部最优解跳不出来；(可结合SA进行改进,因为SA在理率上是100%得到全局最优的,但搜索代价高) 将遗传算法用于解决各种实际问题后，人们发现遣传算法也会由于各种原因过早向目标函数的局部最优解收敛，从而很难找到全局最优解。其中有些是由于目标函数的特性造成的，例如函数具有欺骗性，不满足构造模块假说等等；另外一些则是由于算法设计不当。为此，不断有人对遗传算法提出各种各样的改进方案。例如：针对原先的定长二进制编码方案；提出了动态编码、实数编码等改进方案；针对按比例的选择机制，提出了竞争选择、按续挑选等改进方案；针对原先的一点交算子，提出了两点交、多点交、均匀交等算子；针对原先遗传算法各控制参数在进化过程中不变的情况，提出了退化遗传算法、自适应遗传算法等。另外，针对不同问题还出现了分布式遗传算法、并行遗传算法等等。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云产品]]></title>
    <url>%2F2018%2F09%2F16%2FAbout-AliCloud%2F</url>
    <content type="text"><![CDATA[产品及功能ESC(Elastic Compute Service)以虚拟机的方式将一台物理机分成多台云服务器，提供可伸缩的计算服务。 衍生产品： 阿里云从云服务器ESC衍生出来很多云服务器系列，例如适用于初级用户的轻量应用服务器，还有 为了迎合各种高性能场景的云服务器，诸如GPU云服务器、FPGA云服务器等，总之都是云服务器，是企业上云的基本款。 关于轻量应用服务器： 精简了一些 ECS 的功能，比如说安骑士。把安全组的操作也做了适当减法更适合用户操作。 轻量应用服务器有轻量两个字，意味着其无法持续进行高负载运行（即 CPU 长时间高负载占用），如果我们要利用 轻量应用服务器 来进行持续的渲染、转码、机器学习等持续高负载操作那么就不可以了，也不支持 Nvme 这样的超高性能的 SSD，这对于读写敏感的操作就不好了。 阿里云的“云翼计划”的学生服务器就是轻量应用服务器。 RDS(Relational Database Service)通过云服务的方式让关系型数据库管理、操作和扩展变得更加简单。 OSS(Open Store Service)对任意大小数据对象提供高可用、高可靠的海量存储服务。 相关文章： 阿里云对象存储OSS &lt;/p&gt; SLB(Server Load Balance)基于LVS和Tengine实现的4层和7层负载均衡，有动态扩容。 OCS(Open Cache Service)基于内部Tair，增加一层Proxy，支持海量小数据的高速访问。 OTS(Open Table Service)海量(结构化)数据存储和实时查询服务 CDN(Content Delevery Network)通过覆盖全网的缓存服务以及负载均衡等技术将用户请求定向到最合适的区域，提高用户服务的响应速度及网站服务能力。 OAS(Open Archive Service)离线归档，冷数据备份，类似Amazon Glacier ODPS(Open Data Processing Service)海量数据处理和分析平台。 SLS(Simple Log Service)解决异构、分布式系统中日志实时收集、存储与查询的基础服务]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>About</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云对象存储OSS]]></title>
    <url>%2F2018%2F09%2F14%2FAliCloudOSS%2F</url>
    <content type="text"><![CDATA[OSS阿里云对象存储服务（Object Storage Service，简称 OSS），提供海量、安全、低成本、高可靠的云存储服务。其性质相当于阿里云提供的网盘服务，支持最基本的上传和下载，支持外链。OSS的存储空间以外网流出流量都是要收费的 CDN（CDN加速）全称：Content Delivery Network，内容分发网络是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络，替代传统以WEB Server为中心的数据传输模式。相当于访问就近的服务器点就个人博客而言，不需要CDN加速 存储量存储量指占用的存储空间容量 流量流量指您使用的网络带宽流量累计值，包括外网流出流量、内网流出流量、外网流入流量、内网流入流量、CDN回源流出流量、跨区域复制流量： 外网流出流量(收费): 通过互联网从 OSS 下载数据到本地端所产生的下行流量 内网流出流量(免费): 通过阿里云内网从 OSS 下载数据到 ECS 服务器所产生的下行流量 外网流入流量(免费) : 通过互联网从本地端上传数据到 OSS 所产生的上行流量 内网流入流量(免费) : 通过阿里云内网从 ECS 服务器上传数据到 OSS 所产生的上行流量 CDN回源流出流量(收费) : 通过 CDN 服务层下载 OSS 的数据所产生的回源下行流量 跨区域复制流量(收费) : 使用跨区域复制功能将源 Bucket 的数据同步复制到目标 Bucket 时所产生的流出流量 请求次数调用 OSS OPEN API 的请求次数。比如: 你的一篇博客中有6张图片(都是使用OSS存储做外链),那么当你打开这篇博客时就产生了6次请求。另外: OSS 控制台操作也是通过 OSS OPEN API 调用实现的，因此使用 OSS 控制台也会产生请求次数。 收费模式： 按量付费： 存储费用：存储单价 x 存储量 流量费用：外网流出流量忙时单价 x 流量 请求费用：Put请求 + Get请求汇总的费用 包年包月： 存储费用：存储包平均每月的费用 流量费用：外网流出流量包平均每月的费用 请求费用：Put请求 + Get请求汇总的费用 OSS+CDN组合： 存储费用：存储包平均每月的费用 流量费用：CDN公网流量费用 + CDN回源流量费用 请求费用：CDN回源请求费用 总结：个人博客建议按流量计费]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo进阶]]></title>
    <url>%2F2018%2F09%2F04%2FAdvancedOperationInHexo%2F</url>
    <content type="text"><![CDATA[目录结构12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 为什么在custom.styl修改CSS文件?👉Stylus让CSS也能编程 修改文章页宽打开\themes\next\source\css\ _variables\base.styl文件，找到以下字段并修改为合适的宽度: 1content-desktop-large = 1000px 修改小型代码块颜色修改\themes\next\source\css\ _variables\base.styl文件，修改代码加入自定义颜色： 123456789$black-deep = #222$red = #ff2a2a$blue-bright = #87daff$blue = #0684bd$blue-deep = #262a30$orange = #fc6423// 下面是我自定义的颜色$my-code-foreground = #dd0055 // 用``围出的代码块字体颜色$my-code-background = #eee // 用``围出的代码块背景颜色 修改$code-background和$code-foreground的值 123456// Code &amp; Code Blocks // 用``围出的代码块 // -------------------------------------------------- $code-font-family = $font-family-monospace $code-font-size = 15px $code-background = $my-code-background $code-foreground = $my-code-foreground $code-border-radius = 4px 添加文章结束标记同样在themes/next/layout/_macro/post.swig 中，在 wechat-subscriber.swig之前添加如下代码： 1&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------- The End ----------------&lt;/div&gt; 把侧边栏头像变成圆形，并且鼠标停留在上面发生旋转效果修改themes\next\source\css\_common\components\sidebar\sidebar-author.styl： 1234567891011121314151617181920212223242526272829.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: site-author-image-border-color; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 修改链接文字样式打开themes\next\source\css\_common\components\post\post.styl添加以下代码，给链接添加颜色： 12345678.post-body p a&#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #ff106c; text-decoration: underline; &#125;&#125; 为next主题的主页文章添加阴影效果打开themes/next/source/css/_custom/custom.styl文件添加： 1234567.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 为next主题添加nest背景特效背景几何线条是采用的nest效果，一个基于html5 canvas绘制的网页背景效果，非常赞！来自github的开源项目canvas-nest 特性 不依赖任何框架或者内库，比如不依赖 非常小，只有1.66kb 非常容易实现，配置简单，即使不是web的开发者，也能简单搞定 配置选项 color: 线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B)，注意用,分割 opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 不足：CPU占用过高 修改_layout.swig打开next/layout/_layout.swig在&lt;/body&gt;之前添加如下代码 可参考官方文档：Canvas-Nest 123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 修改主题配置文件打开/next/_config.yml，添加如下代码 1234567# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 运行hexo clean 和 hero g -d 之后就可以在网页上看到效果了。 隐藏网页底部powered by hexo/强力驱动打开hexo/themes/next/layout/_partials/footer.swig 找到下面这段代码，用第一行和最后一行注释掉即可 123456789101112131415&lt;!--&lt;div class="powered-by"&gt;&#123;# #&#125;&#123;&#123; __('footer.powered', '') &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class="theme-info"&gt; &#123;&#123; __('footer.theme') &#125;&#125; &lt;/div&gt;--&gt; 侧栏加入已运行时间themes/next/layout/_custom中添加sidebar.swig文件: 1234567891011121314151617181920212223242526&lt;div id="days"&gt;&lt;/div&gt; &lt;script&gt; function show_date_time()&#123; window.setTimeout("show_date_time()", 1000); BirthDay=new Date("01/10/2017 12:34:56"); today=new Date(); timeold=(today.getTime()-BirthDay.getTime()); sectimeold=timeold/1000 secondsold=Math.floor(sectimeold); msPerDay=24*60*60*1000 e_daysold=timeold/msPerDay daysold=Math.floor(e_daysold); e_hrsold=(e_daysold-daysold)*24; hrsold=setzero(Math.floor(e_hrsold)); e_minsold=(e_hrsold-hrsold)*60; minsold=setzero(Math.floor((e_hrsold-hrsold)*60)); seconds=setzero(Math.floor((e_minsold-minsold)*60)); document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"; &#125;function setzero(i)&#123; if (i&lt;10) &#123;i="0" + i&#125;; return i;&#125;show_date_time();&lt;/script&gt; 在themes/next/layout/_macro/sidebar.swig中的&lt;/section&gt;之前添加: 1&#123;% include &apos;../_custom/sidebar.swig&apos; %&#125; 设置时间样式： 1234567// 自定义的侧栏时间样式#days &#123; display: block; color: #fffa74; font-size: 14px; margin-top: 15px;&#125; 更改tagcloud为彩色themes/next/layout/page.swig找到tagcloud并替换: 1&#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: '#9733EE', end_color: '#FF512F'&#125;) &#125;&#125; 设置动态titlethemes/next/source/js/src下创建dytitle.js： 12345678910111213141516var OriginTitile = document.title;var titleTime;document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="shortcut icon"]').attr('href', "/TEP.png"); document.title = 'w(ﾟДﾟ)w 出BUG啦！！！！'; clearTimeout(titleTime); &#125; else &#123; $('[rel="shortcut icon"]').attr('href', "/favicon.png"); document.title = '♪(^∇^*)又好了。。。 ' + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125;&#125;); 修改themes/next/layout/layout.swing,在 &lt;/body&gt; 之前添加: 1&lt;script type="text/javascript" src="/js/src/dytitle.js"&gt;&lt;/script&gt; 修改文章底部带#的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 文字样式先在themes/next/source/css/_custom/custom.styl中添加以下样式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221// 下载样式a#download &#123;display: inline-block;padding: 0 10px;color: #000;background: transparent;border: 2px solid #000;border-radius: 2px;transition: all .5s ease;font-weight: bold;&amp;:hover &#123;background: #000;color: #fff;&#125;&#125;/ /颜色块-黄span#inline-yellow &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #f0ad4e;&#125;// 颜色块-绿span#inline-green &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #5cb85c;&#125;// 颜色块-蓝span#inline-blue &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #2780e3;&#125;// 颜色块-紫span#inline-purple &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #9954bb;&#125;// 左侧边框红色块级p#div-border-left-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#125;// 左侧边框黄色块级p#div-border-left-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #f0ad4e;&#125;// 左侧边框绿色块级p#div-border-left-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #5cb85c;&#125;// 左侧边框蓝色块级p#div-border-left-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #2780e3;&#125;// 左侧边框紫色块级p#div-border-left-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #9954bb;&#125;// 右侧边框红色块级p#div-border-right-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #df3e3e;&#125;// 右侧边框黄色块级p#div-border-right-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #f0ad4e;&#125;// 右侧边框绿色块级p#div-border-right-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #5cb85c;&#125;// 右侧边框蓝色块级p#div-border-right-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #2780e3;&#125;// 右侧边框紫色块级p#div-border-right-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #9954bb;&#125;// 上侧边框红色p#div-border-top-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #df3e3e;&#125;// 上侧边框黄色p#div-border-top-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #f0ad4e;&#125;// 上侧边框绿色p#div-border-top-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #5cb85c;&#125;// 上侧边框蓝色p#div-border-top-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#125;// 上侧边框紫色p#div-border-top-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #9954bb;&#125; 用法如下： 12&lt;span id=&quot;inline-blue&quot;&gt;站点配置文件&lt;/span&gt;， &lt;span id=&quot;inline-purple&quot;&gt;主题配置文件&lt;/span&gt; 站点配置文件，主题配置文件 12&lt;p id="div-border-left-red"&gt;左边红色&lt;/p&gt;&lt;p id="div-border-top-blue"&gt;上边蓝色&lt;/p&gt; 左边红色上边蓝色 在文档中增加图标采用的是Font Awesome的图标。 给文档加密打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在开头的四个meta之后插入以下代码：1234567891011121314&lt;script&gt; (function () &#123; if ('&#123;&#123; page.password &#125;&#125;') &#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;') &#123; alert('密码错误！'); if (history.length === 1) &#123; location.replace("http://xxxxxxx.xxx"); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 然后在MD文章头文件中加入 password: password 侧边栏推荐阅读打开主题配置文件&lt;/p&gt;修改成这样就行了（links里面写你想要推荐的链接）：1234567891011# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 优设: http://www.uisdc.com/ 张鑫旭: http://www.zhangxinxu.com/ Web前端导航: http://www.alloyteam.com/nav/ 前端书籍资料: http://www.36zhen.com/t?id=3448 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/ 新增评论系统去除评论系统下方的powered by valine打开/next/layout/_third-party/comments/valine.swig文件，123456789101112131415161718new Valine(&#123; el: '#comments' , verify: &#123;&#123; theme.valine.verify &#125;&#125;, notify: &#123;&#123; theme.valine.notify &#125;&#125;, appId: '&#123;&#123; theme.valine.appid &#125;&#125;', appKey: '&#123;&#123; theme.valine.appkey &#125;&#125;', placeholder: '&#123;&#123; theme.valine.placeholder &#125;&#125;', avatar:'&#123;&#123; theme.valine.avatar &#125;&#125;', guest_info:guest, pageSize:'&#123;&#123; theme.valine.pageSize &#125;&#125;' || 10,&#125;);//新增以下代码即可，可以移除.info下所有子节点。var infoEle = document.querySelector('#comments .info');if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0)&#123; infoEle.childNodes.forEach(function(item) &#123; item.parentNode.removeChild(item); &#125;);&#125;]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP三次握手和四次挥手]]></title>
    <url>%2F2018%2F08%2F07%2FTCPShakeandWave%2F</url>
    <content type="text"><![CDATA[TCP三次握手建立连接 第一次握手：客户端发送syn包(seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 通俗一点来讲，就是 主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。 为什么要三次握手？ 在谢希仁著《计算机网络》中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误” 在谢希仁著《计算机网络》书中同时举了一个例子，如下： “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 所以三次握手是为了防止服务器端一直等待而浪费资源。 TCP四次挥手 当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要四次挥手？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。 FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方） FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方） CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方） LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方） TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方） CLOSED: 表示连接中断。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Communication Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通信协议 —— TCP UDP HTTP]]></title>
    <url>%2F2018%2F08%2F07%2FTCP-UDP-HTTP%2F</url>
    <content type="text"><![CDATA[什么是Http、Socket、TCP/IP？HTTP ( HyperText Transfer Protocal ) ，即：超文本传输协议，从1990年开始就在WWW上广泛应用，是当今在WWW上应用最多的协议，Http是应用层协议，当浏览网页的时候，浏览爱和Web服务器之间就会通过HTTP在Internet上进行数据的发送和接收，Http是一个基于请求/响应模式的、无状态的协议。即我们通常所说的Request/Response。HTTP是利用TCP在两台电脑（通常是Web服务器和客户端）之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。 Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。Socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。 TCP/IP 模型在原有OSI模型的基础上进行了简化，由原先的八层（应用层、表示层、会话层、传输层、网络层、数据链路层、物理层）变成了四层（应用层、传输层、网际层IP、网络接口层） TCP HTTP UDP SOCKET四者的关系？ IP是网络层协议，相当于高速公路；TCP和UDP是传输层协议，相当于卡车；HTTP是应用层的协议，相当于货物；SOCKET是TCP/IP网络的API，相当于码头和车站 TCP/IP是一个协议组，可以分为四个层次：网络接口层、网络层、传输层、和应用层。 在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 在传输层中有TCP协议和UDP协议。 在应用层中有FTP、HTTP、TELNET、SMTP、DNS等协议。 HTTP是从Web服务器传输超文本到本地浏览器的传送协议。 TCP和UDP的区别TCP（Transmission Control Protocol）传输控制协议：类似打电话 面向连接、传输可靠、有序、传输大量数据、速度慢、对系统资源要求多、程序结构复杂 每一条TCP连接只能是点到点的 TCP首部开销20字节 UDP（User Data Protocol）用户数据报协议：类似发短信 面向非连接、传输不可靠、无序、传输少量数据、速度快、对系统资源要求少、程序结构简单 UDP支持一对一，一对多，多对一和多对多的交互通信 UDP首部开销小，只有8个字节]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Communication Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库的基本操作]]></title>
    <url>%2F2018%2F07%2F18%2FOraclebase%2F</url>
    <content type="text"><![CDATA[数据库和数据表的基本操作创建数据表创建表——主键约束1234567891011121314151617181920212223create table tb_emp2&#123; id number(11) PRIMARY KEY, name varchar(25), dept number(11), salary number(9,2)&#125;;# 联合主键create table tb_emp2&#123; name varchar(25), deptId number(11), salary number(9,2) PRIMARY KEY(name,deptId)&#125;;# 添加主键ALTER TABLE tb_emp2ADD CONSTRAINT pk_id PRIMARY KEY KEY(id);# 移除主键ALTER TABLE tb1_emp1DROP CONSTRAINT pk_id; 查看数据表是否创建成功12DESC tb_empl;DESCRIBE tb_empl; 非空约束、唯一性约束、默认约束、检查约束、属性自增123456789create table tb_emp2&#123; id number(11) generated by default as identity, name varchar(25) NOT NULL UNIQUE, dept number(11) DEFAULT 1111, salary number(9,2), gender varchar2(2) CONSTRAINT CHK_GENDER CHECK(gender=&apos;男&apos; or gender=&apos;女&apos;)&#125;; 123456789101112131415# 非空约束AlTER TABLE tb_emp5MODIFY name NOT NULL;AlTER TABLE tb_emp5MODIFY name NULL;# 唯一性约束ALTER TABLEtb_emp5ADD CONSTRAINT unq_name UNIQUE(name);ALTER TABLE DROP CONSTRAINT unq_name# 检查约束ALTER TABLE tb_emp2ADD CONSTRAINT chk_gender CHECK(gender=&apos;男&apos; or gender=&apos;女&apos;);ALTER TABLE tb_emp5DROP CONSTRAINT chk_gender 互联网开发中为什么尽量不用外键 避免使用外键，可以在插入数据时通过程序维持约束关系。 使用外键约束缺点： 有额外开销，每次插入数据都需要在两个表中查询判断 在高并发大流量的场景，使用外键更容易造成死锁 删除主键表的数据时，需先删除外键表的数据 修改外键表字段时，需重建外键约束 扩展性问题： 做平台迁移方便，从Mysql迁移到Oracle，像触发器、外键这种东西，都可以利用框架本身的特性来实现，而不用依赖于数据库本身的特性，做迁移更加方便。 分库分表方便，在水平拆分和分库的情况下，外键是无法生效的。将数据间关系的维护，放入应用程序中，为将来的分库分表省去很多的麻烦。 修改数据库表修改表名 1ALTER TABLE &lt;tablename&gt; RENAME TO &lt;newname&gt; 修改字段 1ALTER TABLE &lt;tablename&gt; MODIFY &lt;fieldname&gt; &lt;datatype&gt; 修改字段名 1ALTER TABLE &lt;tablename&gt; RENAME COLUMN &lt;fieldname&gt; TO &lt;newfieldname&gt; 添加字段 1ALTER TABLE &lt;tablename&gt; ADD &lt;fieldname&gt; &lt;datatype&gt; 删除字段 1ALTER TABLE &lt;tablename&gt; DROP COLUMN &lt;fieldname&gt; 视图的操作视图概述 视图(view)，也称虚表, 不占用物理空间，这个也是相对概念，因为视图本身的定义语句还是要存储在数据字典里的。视图只有逻辑定义。每次使用的时候, 只是重新执行SQL。 视图看上去非常象数据库的物理表，对它的操作同任何其它的表一样。当通过视图修改数据时，实际上是在改变基表中的数据；相反地，基表数据的改变也会自动反映在由基表产生的视图中。由于逻辑上的原因，有些Oracle视图可以修改对应的基表，有些则不能（仅仅能查询）。 视图的作用 简单化 看到的就是需要的。视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。 安全性 通过视图用户只能查询和修改他们所能见到的数据。数据库中的其它数据则既看不见也取不到。数据库授权命令可以使每个用户对数据库的检索限制到特定的数据库对象上，但不能授权到数据库特定行和特定的列上。通过Oracle视图，用户可以被限制在数据的不同子集上 逻辑数据独立性 视图可帮助用户屏蔽真实表结构变化带来的影响。 创建视图1234567891011121314151617# 简单视图CREATE VIEW view_t2 AS SELECT quantity, price FROM tmp_12;# 多表创建视图CREATE VIEW stu_glasee(id,name,glass)AS SELECT student.s_id,student.name,stu_info.glass FROM student,stu_info WHERE student.s_id = stu_info.s_id;#视图上的视图CREATE OR REPLACE VIEW stu_gl_glassAS SELECT stu_glass_id, stu_glass.name FROM stu_glass; 查看视图1DESCRIBE view_t; 修改视图12345678910CREATE OR REPLACE VIEW view_tAS SELECT * FROM t;# 为QUTY添加唯一约束，约束名T_UNQ，NOVALIDATE表示此前数据和以后数据都不检查ALTER VIEW view_tADD CONSTRAINT T_UNQ UNIQUE (QUTY)DISABLE NOVALIDATE;ALTER VIEW view_tDROP CONSTRAINT T_UNQ; 更新视图1UPDATE view_t SET quty=5 更新视图view_t后，基本表t的内容也更新了，基本表更新后，另一个视图的view_t2中的内容也会更新。 视图的删除操作最终也是通过删除基本表的记录实现的。 删除视图1DROP VIEW &lt;view_name&gt; 限制视图的数据操作设置视图的只读属性123CREATE OR REPLACE VIEW view_tt ASSELECT quantity,price FROM tWITH READ ONLY; 设置视图的检查属性12345CREATE OR REPLACE VIEW view_tc ASSELECT quantity,price FROM tWHERE price&gt;10WITH CHECK OPTION;# 创建完成后，插入、更新、 删除操作会受到检查条件的限制 视图的应用创建表：1234567891011121314CREATE TABLE stu&#123; s_id NUMBER(11) PRIMARY KEY, s_name VARCHAR2(20) NOT NULL, addr VARCHAR2(50) NOT NULL, tel VARCHAR2(50) NOT NULL&#125;# Oracle插入操作和MySQL不同INSERT INT stu VALUES(1,&apos;XiaoWang&apos;,&apos;Henan&apos;,&apos;0371-12345678&apos;);INSERT INTO stu VALUES(2,&apos;XiaoLi&apos;,&apos;Hebei&apos;,&apos;13889072345&apos;);INSERT INTO stu VALUES(3,&apos;XiaoTian&apos;,&apos;Henan&apos;,&apos;0371-12345670&apos;); 12345678910111213create table sign( s_id number(11) primary key, s_name varchar2(20) not null, s_sch varchar2(50) not null, s_sign_sch varchar(50) not null)insert into sign values(1,&apos;XiaoWang&apos;,&apos;Middle School1&apos;,&apos;Peking University&apos;);insert into sign values(2,&apos;XiaoLi&apos;,&apos;Middle School2&apos;,&apos;Tsinghua University&apos;);insert into sign values(3,&apos;XiaoTian&apos;,&apos;Middle School3&apos;,&apos;Tsinghua University&apos;); 123456789101112create table stu_mark( s_id number(11) primary key, s_name varchar2(20) not null, mark number(11) not null);insert into stu_mark values(1,&apos;XiaoWang&apos;,80);insert into stu_mark values(2,&apos;XiaoLi&apos;,71);insert into stu_mark values(3,&apos;XiaoaTian&apos;,70); 创建北京大学的学生视图123456create view view_peking as select stu_mark.s_id,stu_mark.s_name,stu_mark.mark,sign.s_sign_sch from stu_mark,sign where sign.s_sign_sch = &apos;Peking University&apos; and stu_mark.s_id = sign.s_id and stu_mark.mark&gt;=41; 创建考上清华的学生视图123456create view view_tsinghua as select stu_mark.s_id,stu_mark.s_name,stu_mark.mark,sign.s_sign_sch from stu_mark,sign where sign.s_sign_sch = &apos;Tsinghua University&apos; and stu_mark.s_id = sign.s_id and stu_mark.mark&gt;=40; 更正XiaoTian的成绩12update stu_mark set mark = mark-50 where stu_mark.s_name = &apos;XiaoTian&apos; 视图和表中的数据都同时更改了 总结Oracle中视图和表的区别以及联系是什么？区别： 视图是已经编译好的sql语句。而表不是 视图没有实际的物理记录。而表有。 表是内容，视图是窗口表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时四对它进行修改，但视图只能有创建的语句来修改 表是内模式，试图是外模式 视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。 表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。 视图的建立和删除只影响视图本身，不影响对应的基本表。 联系： 视图（view）是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。 什么时候视图不能进行更新操作？ 视图中不包含基表被定义为非空的列 在定义是图的SELECT语句后的字段列表中使用了数学表达式 在定义是图的SELECT语句后的字段列表中使用了集合函数 在定义视图的SELECT语句中使用了DISTINCT、UNION、TOP、GROUP BY、HAVING子句 插入、更新、删除数据插入数据12345678# 一条记录，可指定字段insert into person(age,name,id,info) values (22,&apos;Suse&apos;,2,dancer)# 多条记录插入时，使用多条的INSERT语句插入效率高# 插入查询结果到表中insert into person(id,name,age,info)select id,name,age,info from person_old; 更新数据12update person set age = 15,name = &apos;LiMing&apos; where id = 11;update person set info=&apos;student&apos; where age between 19 and 22; 删除数据12delete from person where id = 11delete from person where age between 19 and 22; 综合实例update12update books set price=price+5 where note = &apos;novel&apos;;update books set price=40,note=&apos;drama&apos; where name = &apos;EmmaT&apos;;]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识汇总]]></title>
    <url>%2F2018%2F01%2F14%2FFirstInterviewForJava%2F</url>
    <content type="text"><![CDATA[定义部分Q1: 什么是面向对象编程思想？ 面向对象是相对于面向过程的。面向对象不用关心处理问题的细节，只需要关心结果。 面向对象有三大特性：封装、继承和多态。封装的目的是复用；继承目的是共用；多态目的是多种实现。 Q2: Servlet的概念及功能？ Servlet是JavaEE规范中的Web开发组件 Servlet运行在服务器端，需要Servlet容器的支持，例如Tomcat 可以通过浏览器访问Servlet，Servlet可以生成动态页面返回给浏览器 Servlet也是一段代码，是一个Java类，这个Java类需要遵守一定的编写规范 Q3: JSP(Java Server Pages)概念？ JSP是JavaEE规范中的Web组件，用来编写动态页面 JSP运行在服务器端，本质是Servlet JSP文件以.jsp为后缀，在Eclipse的工程目录中存在WebContent目录下 JSP文件可以直接在浏览器中访问 JSP文件中的内容就是 HTML+Java代码，静态部分使用HTML和文本即可，动态部分使用Java代码 Q4: Servlet与JSP的作用？ JSP往往用来生成动态页面，而Servlet虽然可以生成动态页面却过于麻烦，往往用来接收JSP的请求，处理请求，然后跳转到不同JSP页面进行结果显示； Servlet和JSP之间的跳转有两种方式，分别是响应重定向和请求转发； 响应重定向相当于客户端重新发出请求，之前的请求不再保存；请求转发是把当前请求转发到下一个资源；比较常用的是请求转发； 请求参数是用户提交请求时，自动封装到请求对象中的一些输入信息，都是String类型； 请求属性可以是任意类型的对象，可以用setAttribute方法将对象作为属性存储到请求对象中； Q5: JDBC的概念？ JDBC是指Java数据库连接，是一种标准Java应用编程接口，用来连接Java编程语言和广泛的数据库 JDBC的本质是一种规范，它提供了一套完整的借口，允许便捷式访问到底层数据库，因此Java编写不同类型的可执行文件都可以使用JDBC驱动程序来访问数据库。 Q6: SSM框架的基本概念 SSM框架，是Spring + SpringMVC + MyBatis的缩写，是目前主流的Java EE框架，适用于搭建各种大型企业级应用系统。 SSM框架将系统划分为表现层，controller层，service层，DAO层 Spring实现业务对象管理，Mybatis座位数据对象的持久化引擎，Spring MVC负责请求的转发和视图管理 Q7: Spring的功能： Spring 容器提供了IOC机制，可以创建对象以及管理对象之间的调用关系，避免了硬编码造成的程序耦合 提供了AOP（面向切面编程方式）功能，可以实现很多特定功能 声明式事务控制处理 对JDBC进行了轻量级的封装，可以更加灵活的去操作数据库 提供了MVC设计模式的解决方案 提供了文件上传、定时器等常用工具类 对于其他优秀框架的支持（如：Struts、Hibernate、MyBatis、Quartz等） Spring的IoC容器是Spring的核心，Spring AOP是Spring框架的重要组成部分。 Q8: IoC (Inversion of Control) 控制反转？ 在传统的程序设计中，当调用者需要被调用者的协助时，通常由调用者来创建被调用者的实例。但在spring里创建被调用者的工作不再由调用者来完成，因此控制反转（IoC）；创建被调用者实例的工作通常由spring容器来完成，然后注入调用者，因此也被称为依赖注入（DI），依赖注入和控制反转是同一个概念。 IoC是解耦,提供一种构造对象的方式，使得一种功能能有多种实现，且不构成依赖。spring 的IOC的缺点：占用内存多、构造对象慢、启动慢。 控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。所以IoC也叫依赖注入（Dependency Injection）。实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。 Q9: AOP和OOP的联系和区别？ OOP的封装要求将功能分散到不同的对象中去，在软件设计中称为指责分配。让不同的类实现不同的方法，这样代码就分散到一个个类中去了，降低了代码的复杂程度，使类可重用。面向对象设计让类与类之间无法联系，而不能将这些重复的代码统一起来。因此分散代码的同时，也增加了代码的重复性。也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。从技术上来说，AOP基本上是通过代理机制实现的。AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。 OOP (Object Oriented Programming) 侧重于静态，名词，状态，组织，数据，载体是空间 AOP (Aspect Oriented Programming) 侧重于动态，动词，行为，调用，算法，载体是时间 Q10: MVC (Model-View-Controller) 框架？ MVC是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 MVC虽然分为三部分，但是MVC跟经典三层没有任何关系，它只存在于Web层，将Web层的数据、业务处理和显示分隔开。 model是应用程序中用于处理数据逻辑的部分。通常模型对象负责在数据库中存取数据。 view是应用程序中处理数据显示的部分。通常视图是依据数据模型创建的。 controller是应用程序中处理数据交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送。 对于开发存在大量用户界面，并且业务逻辑复杂的大型应用程序，MVC将会使你的软件在健壮性、代码重用和结构方面上一个新的台阶。尽管在最初构建MVC框架时会花费一定的工作量，但从长远角度看，它会大大提高后期软件开发的效率。 MVC是用来分割页面和数据库访问的框架，降低两者的耦合度，同时通过Controller的控制，使系统更加的灵活，代码更加健壮，复用性更强。 Q11: 为什么使用MyBatis？ 在我们传统的 JDBC 中，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的繁琐又枯燥。而我们在使用了 MyBatis 之后，只需要提供 SQL 语句就好了，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 Java相关小知识点01 run是线程执行的方法 start是启动线程对象，使之从新建状态进入就绪状态 sleep让线程睡眠，在此期间线程不消耗CPU资源 suspend使线程挂起，暂停执行，如果想要恢复线程，必须由其它线程调用resume方法]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库整理]]></title>
    <url>%2F2018%2F01%2F02%2FSQLfirstview%2F</url>
    <content type="text"><![CDATA[关于主键和外键： 简而言之，SQL的主键和外键就是起约束作用。 关系型数据库中一条记录中有若干个属性，若其中某一个属性组（注意是组）能唯一标识一条记录，该属性就可以成为一个主键。 成绩表中单一一个属性无法唯一标识一条记录，学号和课程编号的组合才可以唯一标识一条记录，所以学号和课程编号的属性组是一个主键。 成绩表中的学号不是成绩表中的主键，但它和学生表中的学号相对应，并且学生表中的学号是学生表的主键，则称成绩表中的学号是学生表的外键；同理，成绩表中的课程号是课程表的外键。 定义： 123主键：唯一标识一条记录，不能有重复，不允许为空。外键：表的外键是另一表的主键，外键是可以有重复的，可以是空值。索引：该字段没有重复值，但可以有一个空值。 作用： 123主键：用来保证数据完整性外键：用来和其他表建立联系用索引：用来提高查询排序的速度 个数： 123主键：主键只能有一个。外键：一个表可以有多个外键。索引：一个表可以有多个唯一索引。 常用数据库查询操作数据库查询 数据库操作的原理就是将需求翻译成数据库语言 简单的单表查询操作查询“数据库原理”课程的学分； 12SELECT cname，credit FROM course WHERE cname = ‘数据库原理’从course表中取出cname和credit数据，条件是cname为数据库原理 查询选修了课程编号为“C01”的学生的学号和成绩，并将成绩按降序输出； 12SELECT sno，grade FROM sc WHERE cno = ‘C01’ ORDER BY grade DESC；从sc表中选出sno和grade数据，条件是cno是C01，按grade降序输出 查询学号为“31401”的学生选修的课程编号和成绩； 12SELECT cno，grade FROM sc WHERE sno = ‘31401’从sc表中选出cno和grade两个数据，条件是sno为31401 查询选修了课程编号为“C01”且成绩高于85分的学生的学号和成绩； 12SELECT sno, grade FROM sc WHERE cno = &apos;C01&apos; AND grade &gt; 85;从sc表中查询sno和grade，条件是cno为C01以及grade大于85分 简单的多表的连接查询 由于学号和成绩分别在student和sc表中，所以这是多表查询，多表查询注意隐含条件的表达 查询选修了课程编号为“C01”且成绩高于85分的学生的学号、姓名和成绩； 12SELECT sc.sno, sname, grade FROM student, sc WHERE student.sno = sc.sno AND cno = &apos;C01&apos; AND grade &gt;85;从student和sc表中选取学号、姓名和成绩，条件是课程编号C01、成绩&gt;85、并且【学生编号相同】 查询所有学生的学号、姓名、选修的课程名称和成绩； 12SELECT sc.sno, sname, cname, grade FROM student, sc, course WHERE sc.sno = student.sno AND sc.cno = course.cno;从student、course和sc表中查询学号、姓名、课程名和成绩，条件是三个表中的学号均相同 复杂的查询操作 GROUP BY用于合计函数，根据一个或多个列对结果集进行分组，比如这题想要得到的是 学生 的 课程总和 ，所以GROUP BY学生，合计课程号cno 查询至少选了三门课程的学生的学号和姓名； 12345SELECT sc.sno, sname FROM sc, student WHERE sc.sno = student.sno GROUP BY sc.sno HAVING COUNT(sc.cno)&gt;=3从sc和student表中查询，条件是学号相同，并且统计选课&gt;=3 GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组 查询所有学生的学号和他选修课程的最高成绩，要求他的选修课程中没有成绩为空的； 12SELECT sno, max(grade) FROM sc GROUP BY sno HAVING MIN(grade) &gt; 0;这里调用一个max，并且选课成绩不为空仍然用group by和having min 带有IN、比较符的嵌套查询查询修了数据库原理的学生的学号和姓名; 123456SELECT sc.sno, sname FROM student, scWHERE sc.sno = student.sno AND sc.cno IN (SELECT cno FROM course WHERE cname = &apos;数据库原理&apos;)；从student和sc中查询学号和姓名，条件是学号相同，这里IN相当于等号【在course表中数据库对应的cno】 inner join表示输出前后两个表的共同部分on【共同的志向条件】 查询没有选修数据库原理的学生的学号和姓名； 12345678SELECT sno, sname FROM studentWHERE sno NOT IN (SELECT sc.sno FROM sc INNER JOIN course ON sc.cno = course.cno WHERE (course.cname = &apos;数据库原理&apos;))从student表中查询学号姓名，条件是sno不等于（从【sc和course表中cno相同】中选出sno，条件是cname为数据库原理） 查询至少选修了【学号为“31401”的学生所选修的所有课程】的学生的学号和姓名； EXCEPT 仅返回那些不存在于第二个 SELECT 语句结果的记录（差集） DISTINCT 关键字同 SELECT 语句一起使用，可以去除所有重复记录，只返回唯一项 EXISTS 和 NOT EXISTS 表示是否存在，只返回True/False 123456select distinct sno, snamefrom student where not exists ((select cno from sc where sno=’31401’) except (select cno from sc where sc.sno=student.sno));（31401选的课程号减去别的同学所选的课程号）【判断是否存在】，不存在返回真，选出不重复的学生 但是MYSQL没有except关键字，只能用建立视图解决问题： 视图的优点：简单、安全、数据独立 左连接where只影向右表，右连接where只影响左表 「select * from tbl1 Left Join tbl2 where tbl1.ID = tbl2.ID」 左连接后的检索结果是显示tbl1的所有数据和tbl2中满足where 条件的数据 [左连接实例]:http://www.w3school.com.cn/sql/sql_join_left.asp 12345678910111213create view temp as select distinct cno from sc where sno=’31401’;第一步，选出学号为31401所选的所有课程，创建视图create view ttemp as select temp.cno, sno from temp left join sc on temp.cno=sc.cno ; 第二步，选出cno和sno，从temp表以及sc表中cno相同的数据，「对照temp.cno把学号输入一遍」，创建视图另一种写法：【create view ttemp as select temp.cno, sno from temp, sc where temp.cno=sc.cno(+)】select sno,sname from student where sno in (select sno from ttemp group by sno having count(distinct cno)=3);第三步，查找从学生表中查询学号姓名，条件是sno等于【从ttemp中选出sno，不重复的cno个数大于等于3的sno】 由浅入深多表查询多表连接分为三类 内连接：（joind，inner join） 外连接：（left join，left outer join，right join，right outer join，union） 交叉连接：（cross join） 一、内连接语法： 对内连接 123SELECT table1.column, table2.columnFROM table1, table2WHERE table1.column1 = table2.column2; 例：查询每个员工的工号，姓名，工资，部门名和工作地点 123SELECT empno, ename, sal, dname, loc FROM emp, deptWHERE emp.deptno=dept.deptno; 内连接的另一种写法： 123SELECT empno,ename,job,sal,dept.deptno,dname,locFROM emp JOIN dept ON (emp.deptno=dept.deptno); 二、外链接语法 对外连接 123SELECT table1.column, table2.column --右外连接FROM table1, table2WHERE table1.column(+) = table2.column; 123SELECT table1.column, table2.column --左外连接FROM table1, table2WHERE table1.column = table2.column(+); 左外连接就是把左边的表内容全列出来，右边的只显示相同的部分，不存在的写NULL。右外连接就是把右边表内容全列出来，左边只显示相同的部分，不存在的写NULL。全连接就是完整返回左右表所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 例：查询每个员工的工号，姓名，工资，部门名和工作地点 123SELECT empno,ename,job,sal,dept.deptno,dname,loc --右外连接FROM emp,deptWHERE emp.deptno(+)=dept.deptno; 另一种写法： 12SELECT empno,ename,job,sal,dept.deptno,dname,loc --右外连接FROM emp right join dept on (emp.deptno=dept.deptno); 左外链接： 12SELECT empno,ename,job,sal,dept.deptno,dname,loc --左外连接FROM emp left join dept on (emp.deptno=dept.deptno); 全连接： 12SELECT empno,ename,job,sal,d.deptno,dname,locFROM emp e full join dept d on (e.deptno=d.deptno); 三、交叉连接（笛卡尔积） 实际应用中还有这样一种情形，想得到A，B记录的排列组合，即笛卡儿积，这个就不好用集合和元素来表示了。需要用到cross join 12SELECT empno,ename,dnameFROM emp cross join dept; 数据库ODBC接口 利用C语言编程实现简单的数据库应用程序，掌握基于ODBC的数据库访问的基本原理和方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include"windows.h"#include"sql.h"#include"sqlext.h"#include"sqltypes.h" #include"odbcinst.h"struct course_cell&#123; char cno[5]; char cname[20]; int lhour; int credit; char semester[5];&#125;;unsigned char sql_select[]="select * from db.course"; //SQL查询语句 unsigned char sql_dolist[3][100]=&#123;"insert into db.course values('C27','internet',48,2,'')", "update db.course set semester='τ' where cno='C27'", "delete from db.course where cno='C27'"&#125;; //插入、修改、删除语句 unsigned char do_name[3][10]=&#123;"insert","update","delete"&#125;;void show_course(HDBC hdbc) //显示course的内容&#123; HSTMT hstmt; RETCODE retcode; long lenOut1,lenOut2,lenOut3,lenOut4,lenOut5; struct course_cell* ccell; ccell = (struct course_cell*)malloc(sizeof(struct course_cell)); retcode=SQLAllocStmt(hdbc,&amp;hstmt); if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123;//SQLBindCol将应用程序的数据缓冲绑定到结果集的各列 retcode=SQLBindCol(hstmt,1,SQL_C_CHAR,ccell-&gt;cno,5,&amp;lenOut1); retcode=SQLBindCol(hstmt,2,SQL_C_CHAR,ccell-&gt;cname,20,&amp;lenOut2); retcode=SQLBindCol(hstmt,3,SQL_C_SLONG,&amp;ccell-&gt;lhour,sizeof(int),&amp;lenOut3); retcode=SQLBindCol(hstmt,4,SQL_C_SLONG,&amp;ccell-&gt;credit,sizeof(int),&amp;lenOut4); retcode=SQLBindCol(hstmt,5,SQL_C_CHAR,ccell-&gt;semester,5,&amp;lenOut5); retcode=SQLExecDirect(hstmt,sql_select,SQL_NTS); //把SQL语句送到数据库服务器，请求执行由SQL语句定义的数据库访问 if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; printf("db.course is as following:\n"); printf("----------------------------------------------------------------\n"); printf("cno cname lhour credit semester\n"); retcode=SQLFetch(hstmt); /*SQLFetch fetches the next rowset of data from the result set and returns data for all bound columns.相当与SQLFetchAdvances和SQLGetData两个函数*/ while(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; printf("%-10s%-20s%-15d%-16d%-5s\n", ccell-&gt;cno,ccell-&gt;cname,ccell-&gt;lhour,ccell-&gt;credit,ccell-&gt;semester); retcode=SQLFetch(hstmt); &#125; printf("----------------------------------------------------------------\n\n"); &#125; &#125; SQLFreeStmt(hstmt,SQL_DROP);//释放语句句柄&#125; int main()&#123; HENV env; //定义环境句柄 HDBC hdbc; //定义链接句柄 HSTMT hstmt; //定义语句句柄 RETCODE retcode; retcode=SQLAllocEnv(&amp;env); //初始化ODBC环境，返回环境句柄 if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; retcode=SQLAllocConnect(env,&amp;hdbc); //为连接句柄分配内存并返回链接句柄 if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; retcode=SQLConnect(hdbc,(SQLCHAR*)"test",SQL_NTS,(SQLCHAR*)"root",SQL_NTS,(SQLCHAR*)"",SQL_NTS); //连接一个SQL数据资料 if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; show_course(hdbc); //显示初始的course内容 for(int i=0; i&lt;3; i++) //依次执行插入、修改、删除操作 &#123; retcode=SQLAllocStmt(hdbc,&amp;hstmt);//为语句句柄分配内存，并返回语句句柄 retcode=SQLExecDirect(hstmt,sql_dolist[i],SQL_NTS); //把SQL语句送到数据库服务器，请求执行由SQL语句定义的数据库访问 printf("%s ", do_name[i]); if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) printf("success!\n\n"); else printf("fail!\n\n"); SQLFreeStmt(hstmt,SQL_DROP); //释放与语句句柄相关的资源 show_course(hdbc);//显示操作后的新course内容 &#125; SQLDisconnect(hdbc); //切断连接 &#125; SQLFreeConnect(hdbc); //释放与连接句柄相关的资源 &#125; SQLFreeEnv(env); //释放与环境句柄相关的资源&#125; return 0;&#125; 数据库完整性与安全性定义各基表的主键12345678910111213141516171819202122232425CREATE TABLE sc( sno varchar(6) NOT NULL, cno varchar(3) NOT NULL, grade int(11) DEFAULT NULL, PRIMARY KEY (sno,cno))DEFAULT CHARSET = gbk;Create Table student ( sno varchar(6) NOT NULL, sname varchar(6) DEFAULT NULL, sex varchar(2) DEFAULT NULL, bdate datetime DEFAULT NULL, dept varchar(8) DEFAULT NULL, classno varchar(3) DEFAULT NULL, PRIMARY KEY (sno)) DEFAULT CHARSET=gbk；Create Table course ( cno varchar(3) NOT NULL, cname varchar(12) DEFAULT NULL, lhour int(11) DEFAULT NULL, credit int(11) DEFAULT NULL, semester varchar(2) DEFAULT NULL, PRIMARY KEY (cno)) DEFAULT CHARSET=gbk； 删除和添加主键外键12345678alter table course drop primary key;alter table course add primary key(cno);alter table sc add constraint foreign key&lt;sno&gt; references student&lt;sno&gt;;alter table sc add constraint foreign key&lt;cno&gt; references course&lt;cno&gt;;show create table course;查看各表信息 验证完整型约束： 分别向学生表、课程表插入具有相同学号和相同课程编号的学生数据和课程数据，验证其实体完整型约束。可以看出对student和course插入具有相同学号和课程编号的学生数据，都失败了，验证其实体完整型约束。 向学生课表插入一条课表编号课程表中没有的，验证参照完整型约束。插入失败。 定义存储过程 存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。 存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。 存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。 首先定义存储过程的结束符 12DELIMITER //用delimiter修改结束符为// 声明存储过程 1create procedure demo_in_parameter(IN p_in int) 存储过程开始和结束符号: 1BEGIN .... END 变量赋值: 1SET @p_in=1 变量定义: 1DECLARE l_int int unsigned default 4000000; 创建mysql存储过程、存储函数: 1create procedure 存储过程名(参数) 存储过程体: 1create function 存储函数名(参数) 示例：创建数据库备份数据用于示例： 1234create database db1;use db1;create table PLAYERS as select * from TENNIS.PLAYERS;create table MATCHES as select * from TENNIS.MATCHES; 存储过程示例：「删除给定球员参加的所有比赛」 12345678delimiter // #将语句的结束符号从分毫；临时改为两个//# 使用 DELIMITER $$ 命令将语句的结束符号从分号 ; 临时改为两个 $$，使得过程体中使用的分号被直接传递到服务器，而不会被客户端（如mysql）解释。create procedure delete_matches(IN p_playerno INTEGER)BEGIN delete from MATCHES where playerno = p_playerno;END//delimiter; #将语句的结束符号恢复为分号 调用存储过程： 1call sp_name[(传参)]； 触发器 MySQL包含对触发器的支持。触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。 创建触发器语法： 123456CREATE TRIGGER trigger_name #nametrigger_time #触发时机，before/aftertrigger_event ON tbl_name #触发事件：insert/update/delete 建立触发器表名，在哪张表建立触发器。FOR EACH ROWtrigger_stmt #触发器程序体，可以是SQL语句也可以是BEGIN和END包含的多条语句（delimiter）# 由此可见，可以创建（2x3）六种触发器 示例： 假设系统中有两个表：班级表 class(班级号 classID, 班内学生数 stuCount)学生表 student(学号 stuID, 所属班级号 classID)要创建触发器来使班级表中的班内学生数随着学生的添加自动更新，代码如下： 12345678910DELIMITER $create trigger tri_stuInsertAFTER INSERTON student FOR EACH ROWBEGINdeclare c int; #变量定义set c = (select stuCount from class where classID=new.classID); #变量赋值update class set stuCount = c + 1 where classID = new.classID; #变量操作END$DELIMITER ; 数据库查询分析深入理解分组查询例题：把统计时间（statistic）相同的，服务域（service_domain_moid）a中的hd100的数量和hd100s的数量的和计算出来： 首先，我们把service_domain_moid为a的筛选出来，如下： 12SELECT hd100, hd100s FROM statisticWHERE service_domain_moid=&quot;a&quot;; 其次： 我们把统计时间（statistic_time）相同的分组，求和 123SELECT sum(hd100),sum(hd100s)FROM statistic WHERE service_domain_moid=&quot;a&quot;GROUP BY statistic_time; 最后，统计结果按降序排序： 1234SELECT sum(hd100),sum(hd100s)FROM statistic WHERE service_domain_moid=&quot;a&quot;GROUP BY statistic_timeORDER BY statistic_time desc; GROUP BY关键字可以将查询的结果按某个字段或多个字段进行分组，字段中值相等的为一组。其语法规则如下： 1GROUP BY 属性名 [HAVING 条件表达式] [WITH ROLLUP] ORDER BY关键字可以对记录进行排序，其语法规则如下： 1ORDER BY 属性名 [ASC|DESC] 数据库练习题：01 按部门名称查询出员工的人数大于等于100的语句.(员工:emp_employee, 部门名称: department,员工姓名chnalias.) 12SELECT department FROM emp_employeeGROUP BY department HAVING COUNT(*) &gt;= 100; 02 把员工的姓名、性别和年龄显示出来。（员工表emp_employee，员工姓名：chnalias，年龄age，性别：gender。性别表：pub_gendar_info，性别名称：smpalias,与员工表的性别无关） 12SELECT e.chnalias, e.smpalias, e.age FROM emp_employee e INNER JOIN pub_gender g ON(e.gender = g.smpalias) 04 删除员工表中的姓名重复的数据，只保留重复数据中的一条数据。（员工表emp_employee,员工姓名：chnalias） 1234DELETE FROM emp_employeeWHERE id NOT IN( SELECT MAX(id) AS id FROM emp_employee GROUP BY chnalias) AS关键字为查询的字段起一个别名，例如上面的语句里，给MAX(id)起个别名id【AS关键字可省略】 05 查询出差表中的每个员工最近的出差时间和员工姓名(出差表emp_travel,员工姓名chnalias,出差时间godate) 1SELECT chnalias, godate FROM emp_travel ORDER BY godate DESC 数据库查询练习01 没有选修课程编号为C1的学生姓名【多表查询】 首先找出C1对应的chosen_class表中的c_id 12SELECT chose_class.c_id FROM class, chosen_class WHERE class.c_id = chose_class.c_id AND c_name = &quot;C1&quot;; 然后找出没有选修C1的学生 12345SELECT s_name FROM student, chose_classWHERE student.s_id = chose_class.s_id AND c_id NOT IN ( SELECT chose_class.c_id FROM class,chose_class WHERE class.c_id = chose_class.c_id AND c_name = &quot;C1&quot;); 02 列出每门课程名称和平均成绩，并按照程序排序 先分组查找计算每门课对应的平均成绩： 12SELECT c_id, avg(grade) avggrade FROM chosen_classGROUP BY c_id 然后多表查询（名称+成绩）并按照程序排序： 12345SELECT c.c_name, avggrade FROM( SELECT c_id, avg(garde) avggrade FROM chosen_class GROUP BY c_id) b JOIN class c ON c.c_id = b.c_id ORDER BY b.avggrade DESC; 03 选了2门课以上的学生姓名 统计学生id对应的选课数 12SELECT s_id, count(*) countclass FROM chosen_classGROUP BY s_id 1234SELECT s.s_name, b.countclass FROM( SELECT s_id, count(*) countclass FROM chosen_class GROUP BY s_id) b JOIN student s ON (s.s_id = b.s_id)]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[裂纹识别初探]]></title>
    <url>%2F2017%2F10%2F23%2FCrackIdentify%2F</url>
    <content type="text"><![CDATA[裂纹识别的基本步骤 基于概率模型的裂纹识别算法总结 思路：仍然基于传统的模式识别方法，通过计算已知模板与图像的相关性，但是裂纹的形状与走向具有很大的随机性，引入概率论可以更好地建立模板。将概率论引入到理想裂纹模型的建立中，并将所建立的概率模型映射为理想模板。通过计算理想模板与图像像素点对应区域的Bhattacharyya系数来评定像素为裂纹的可能性。进而从X光图像中自动地提取裂纹轮廓。 关于Bhattacharyya系数（相似系数）：可以衡量两个向量间的相似程度。 裂纹中心点概率模型：通过观察裂纹图像发现裂纹中心点灰度低，两侧稍高，裂纹整体灰度地域背景灰度。根据裂纹图像的特点，将裂纹的中心曲线看作是裂纹中心点沿着曲线运动的轨迹。假设理想裂纹的中心点分布概率服从高斯分布，则任意剖面都满足高斯分布。模型窗口中心点是裂纹中心点的概率最大。 理想裂纹模板：基于裂纹灰度分布特点，将理想模型映射成理想模板。 裂纹识别算法： 图像预处理：（处理背景噪声） 斯通滤波：图像中的噪声绝大部分都位于图像频谱中的高频部分，通过高斯低通滤波器，滤除原始图像中的高频部分，避免理想模板与噪声发生误匹配。 阈值分割：采用改进的OSTU方法对图像进行灰度阈值分割，计算出合适的灰度阈值T 灰度拉伸：根据灰度阈值T，将灰度值高于T的像素灰度置为255.确定合适的门限值M，讲地域该门限的像素灰度置为0，根据先验经验，裂纹中心灰度的范围浮动低于10个灰度级左右。（二值化） 灰度拉伸的作用：增强原始图像的对比度，增加裂纹与模板的相似程度，从而增加了识别的准确性 算法流程： 根据式(2)将理想概率模型映射为理想模板矩阵 B。 统计模板矩阵 B 中元素对应的灰度概率分布，建立模 板的概率矩阵 B1，B1 中的元素为 B 中该元素灰度值在模板 中出现的概率。 对预处理后的原始图像进行逐像素循环，计算以当前 点为中心，模板矩阵区域大小内像素灰度分布概率为 i p ，再 根据 i p 与 B1 计算该区域对应的 Bhattacharyya 系数，并将其 作为当前点的替代值，遍历原始图像后生成相似系数矩阵。 将相似系数矩阵映射为灰度图像矩阵，并将其二值化。 对二值图像进行形态学操作，从而在二值图像中得到 裂纹的完整轮廓。将裂纹的轮廓和所在区域在原始图像中标 记出来，从而达到识别裂纹的目的。 形态学操作——消除二值化后的的噪声点 形态学操作流程：图像取反—关运算—膨胀—填充—腐蚀 形态学操作中膨胀和腐蚀的尺度必须一致，否则得到的轮廓尺寸便被人为地引入了方法误差。 经过形态学操作后得到了完整的裂纹轮廓，通过边缘检测算法，将该二值图像中的裂纹轮廓重绘于其对应的原始图像上，并在原始图像上标定出裂纹区域信息，从而完成了对裂纹的识别。 基于图像处理的微波处理材裂纹总结 思路：利用matlab软件中的图像处理模块，通过编程对微波处理木材表面裂纹的彩色扫描图像类型转换、图像增强、图像分割及图像形态学处理，提取图像中存在的裂纹，并最终对裂纹信息进行统计。 图像类型转换： Matlab图像处理模块提供了许多图像类型转换函数，通过这些函数可以实现RGB图像、灰度图像、索引图像及二值图像之间的相互变换。 由于图像后期处理都是在灰度图像基础上进行的，所以需要先将彩色扫描图像转换为灰度图像。在Matlab软件中，可通过调用rgb2gray函数实现彩色图像至灰度图像的转换。 图像增强： 在获取图像的过程中，各种干扰因素的存在会导致源图像中存在噪声，从而影响图像的质量。因此必须先对图像进行增强处理，图像增强可以将图像中感兴趣的特征有选择地突出，并衰减不需要的特征，以便后期对图像特征进行识别分析。 增强对比度：使源图像中各部分的反差增强。本文进行对比度增强处理的目的是使源图像中裂纹区域与其他部分的区别更为明显，主要通过imadjust函数实现。 锐化处理：经过以上的平滑滤波器对图像进行处理后，图像会有一定程度的模糊，进行锐化处理以突出图像的边缘信息，加强图像的轮廓特征，以便于人眼观察和机器识别。 二值图降噪处理：通过调用bwareaopen函数去除尺寸较小的噪声，经过降噪处理后，图像中有部分尺寸较大的噪声仍未去除，如果加大去噪过程中去除对象的尺度，会同时将部分较小的裂纹去除，因此不能采用该方法。而通过roifill函数，采用区域填充的方法可以达到去除大尺寸噪声的目的。 断裂纹闭合：采用形态学处理中的闭运算操作，通过创建一个平面的线性结构元素使裂纹的断裂区域闭合。 裂纹信息统计：采用matlab软件中形态学处理的操作，获得裂纹数量、裂纹长度、宽度及面积等信息，并由此计算机出图像中裂纹区域所占图像面积的比例。首先调用bwlabel函数对裂纹进行编号，可以统计图像中的裂纹数量。其次，利用regionprops函数可以计算出每条裂纹对应的长度、宽度和面积。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令对应的单词]]></title>
    <url>%2F2017%2F01%2F21%2FLinuxAbbreviation%2F</url>
    <content type="text"><![CDATA[特殊命名MySQL = My是最初作者女儿的名字，SQL = Structured Query LanguagePython 得名于电视剧Monty Python&rsquo;s Flying Circusawk = “Aho Weiberger and Kernighan” 三个作者的姓的第一个字母biff = 作者Heidi Stettner在U.C.Berkely养的一条狗,喜欢对邮递员汪汪叫。 目录名：/etc：ETCetera/bin：BINaries/dev：DEVices/lib：LIBraries/mnt：MouNT/proc：PROCesses/tmp：TeMPorary/var：VARiable/srv：SeRVices/opt：OPTion/sbin：Super BINaries（又作Superuser BINaries）/sys：SYStem/usr：Unix Shared Resources 文件管理（包括文件输出管理）：ls — LiStcd — Change Directorypwd — Print Working Directorycp — CoPymv — MoVerm — ReMovepushd — PUSH to Directorypopd — POP from Directorymkdir — MaKe DIRectoryrmdir — ReMove DIRectorycat — CATenatesed — Stream EDitordiff — DIFFerencewc — Word Countchmod — CHange MODechown — CHange OWNerchgrp — CHange GRouPawk — Aho Weinberger and Kernighangawk — Gnu Aho Weinberger and Kernighangrep — General Regular Expression Println — LiNktar — TARball 硬件管理：df — Disk Freedu — Disk Usagedd — Data Descriptionparted — PARTition EDitorlspci — LiSt Peripheral Component Interconnectlscpu — LiSt Central Process Unitlsusb — LiSt Universal Serial Bus 软件及软件包管理：man — MANualapt — Advanced Packaging Tooldpkg — Debian PacKaGeyum — Yellow dog Updater, Modifiedrpm — RPM Package Manager 系统管理：depmod — DEPend MODulelsmod — LiSt MODulemodprobe — MODule PROBEmodinfo — MODule INFOrmationinsmod — INSert MODulermmod — ReMove MODuleps — Processes Statussu — Substitute Userbash — Bourne Again SHellinit — INITializationssh — Secure SHellwine — Wine Is Not an Emulatorexec — EXECutefstab — FileSystem TABlepasswd — PASSWorDtty — TeleTYpesudo — SuperUser DOgrub — GRand Unified Bootloadertzselect — Time Zone SELECTsync — SYNChronize 编辑器：ed — EDitornano — Nano’s ANOther editoremacs — Editor MACroSvi — VIsualvim — Vi Improved 写程序时会用到的：cc — C Compilergcc — Gnu Compiler Collectiongcc — Gnu C Compilerg++ — Gnu c++ compilergcj — Gnu Compiler for Javayacc — Yet Another Compiler Compilerguile — Gnu Ubiquitous Intelligent Language for Extensionsgas — Gnu Assemblerphp — PHP：Hypertext Preprocessorld — Link eDitorgdb — Gnu DeBugtcl — Tool Command Line 图形界面：gnome — GNu Object Model Environmentgdm — Gnome Display Managergtk — Graphic user interface ToolKitqt — Toolkitkde — K Desktop Environmentlxde — Lightweight X11 Desktop Environmentxfce — XForms Common Environment 各种参数-a | —all ; —archive ; —append-b | —blocksize ; —batch-c | —commands ; —create-d | —debuge ; —delete ; —directory-e | —execute ; —edit ; —exclude-f | —force ; —file ; —configuration file-h | —help ; —human readable ; —headers-i | —interactive ; —include-k | —keep ; —kill-l | —long listing format ; —list ; —load-m | —message ; —manual ; —create home-n | —number ; —no-o | —output ; —options-p | —port ; —protocol ; —passwd-q | —quiet-r | —reverse ; —recursive-s | —silent ; —size ; —subject-t | —tag ; —type-u | —user-v | —verbose ; —version-w | —width ; —warning-x | —exclude-y | —yes-z | —zip 许可证：gnu gpl : Gnu General Public Licensegnu lgpl : Gnu General Lesser Public Licensegfdl : Gnu Free Documentation Licenseagpl : Affero General Public Licenseapsl : Apple Public Source Licensebsd : Berkeley Software Distribution license]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《鸟哥的私房菜》思维导图]]></title>
    <url>%2F2017%2F01%2F17%2FLinuxXmind%2F</url>
    <content type="text"><![CDATA[Linux学习计划 Linux文件、目录与磁盘格式 Shell与Shell Script]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb总结]]></title>
    <url>%2F2017%2F01%2F02%2FJavaWeb-bili%2F</url>
    <content type="text"><![CDATA[01 JSP环境搭建JSP动态网页 静态、动态：是否随着 时间、地点、用户操作 的改变而改变 动态网页：需要使用到服务器脚本语言（JSP） 架构C/S、B/S架构 C/S架构的不足：（QQ） 如果软件升级、所有软件都需要升级 维护麻烦，需要维护每一台客户端软件 每一个客户都需要安装客户端软件 B/S架构：（京东网页） 客户端可以通过浏览器直接访问服务端 Tomcat解压后的目录bin：可执行文件（startup.bat、shutdown.bat） conf：配置文件（server.xml） lib：Tomcat依赖的jar文件 log：日志文件（记录出错信息） temp：临时文件 webapps：可执行的项目（将我们开发的项目放入该目录） work：存放由jsp翻译成的Java，以及编辑成class文件（tsp -&gt; java -&gt; class） 配置Tomcat 配置jdk（必须配置Java_HOME）java_home、classPath、path 配置catalina_home 双击 bin/startup.bat 启动tomcat 常见错误：可能与其他服务器端口号冲突。（默认端口8080） 修改端口号：conf/server.xml（70行左右） 访问Tomcathttp://localhost:8888/ 常见状态码： 200: 一切正常 300/301: 页面重定向 404: 资源不存在 403:权限不足（如果访问a目录，但是a目录设置 不可见） 500: 服务器内部错误（代码有误） Apache项目文件结构 如果有index.jsp和index2.jsp文件，通过 welcome 设置默认的初始页面。 JSP：在HTML中嵌套的Java代码 虚拟路径将web项目配置到webapps以外的目录——【配置虚拟路径】 server.xml 文件 Host 代码块内写一个 Context 代码： docBase：实际路径 path：虚拟路径（绝对路径、相对路径「相对于webapps」） 方法二： 在 conf/Catalina/localhost 新建文件 「项目名」.xml 中新增一行 虚拟主机通过 www.test.com 访问本机配置 server.xml 中的 Host 代码块 12345添加Host代码块&lt;Host appBase="D:\study\JspProject" name="www.test.com" &gt; &lt;Context docBase="D:\study\JspProject" path="/"&gt;&lt;/Context&gt;&lt;/Host&gt;并修改默认引擎中的 defaultHost=“www.test.com" 配置电脑的 hosts 文件，添加映射 127.0.0.1 到 www.test.com 访问： www.test.com:8888 网站默认端口是 80 ，只要端口改成 80 ，就可以省略端口号 流程：www.test.com -&gt; host找映射关系 -&gt; server.xml 找 Engine 的 defaultHost -&gt; 通过 “/” 映射到 D:\study\JspProject 为了后续学习，将以上恢复改端口、改Engine、删Hosts JSP执行流程第一次访问服务端将jsp翻译成java（Servlet文件），再将Java编译成class文件 最终存放在 D:\study\apache-tomcat-8.5.30\work\Catalina\localhost\JspProject\org\apache\jsp 第二次访问直接访问class（如果服务端修改了代码，将会在访问中重新翻译和编译） Jsp和Servlet可以相互转换]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
</search>
